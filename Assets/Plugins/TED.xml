<?xml version="1.0"?>
<doc>
    <assembly>
        <name>TED</name>
    </assembly>
    <members>
        <member name="T:TED.Comparer`1">
            <summary>
            Defines the EqualityComparer to use in indices for the specified type.
            This defines both how to compare equality and also how to compute hash codes.
            </summary>
        </member>
        <member name="F:TED.Comparer`1.Default">
            <summary>
            Equality and hash function implementation to use for indexing.
            IMPORTANT: If you change this, do it before defining predicates.
            </summary>
        </member>
        <member name="T:TED.Compiler.CompiledHelpersForAttribute">
            <summary>
            Metadata stating the attached class contains the compiled rules for the named TED Program object.
            </summary>
        </member>
        <member name="F:TED.Compiler.CompiledHelpersForAttribute.ProgramName">
            <summary>
            Name of the table from whose rules this method is compiled.
            </summary>
        </member>
        <member name="M:TED.Compiler.Compiler.WithLiftedScope(System.Action)">
            <summary>
            Compile the code compiled by generator, but move any variables it declares using LocalVariable to the beginning.
            This is needed because some parts of the state machine generated by the compiler have data dependencies that the
            C# compiler's control flow analyzer can't follow and so a direct translation of the output generates bogus CS0165
            errors complaining that local variables are used before they're initialized.  Wrapping code in this forces the
            variables to be initialized early.  You only need to use this if you use CompileJumpTable to create jumps into the
            middle of the block generated by this.  As of this writing, the only use case for this is the Or[] primitive.
            </summary>
        </member>
        <member name="M:TED.Compiler.Compiler.LocalVariable(System.String,System.Type,System.String,System.Boolean)">
            <summary>
            Generates the code necessary to have a local variable here with the specified name, type, and initializer.
            This is usually just a var name = initializer statement, but if we have lifted scope, the declaration will
            be moved earlier and the line generated here will just assign the value.
            </summary>
            <param name="name">Name to give to the variable</param>
            <param name="type">type to give to the variable</param>
            <param name="initializer">text of expression for its initial value</param>
            <param name="liftIfNecessary">If false, never lift.</param>
            <returns>name</returns>
        </member>
        <member name="M:TED.Compiler.Compiler.Field(System.String,System.Type,System.String)">
            <summary>
            Add the specified field with the specified type an initializer to the class containing the compiled code.
            This can be used to link to outside data (e.g. tables) or to retain state from update to update (e.g. RNGs).
            </summary>
            <param name="name">Name to give to the field</param>
            <param name="type">date type for the field</param>
            <param name="initializer">Expression for an initial value.  This is assigned during linking.</param>
            <returns>The name</returns>
        </member>
        <member name="M:TED.Compiler.Compiler.CompileBody(System.Collections.Generic.IEnumerable{TED.Interpreter.Call},TED.Compiler.Continuation,System.String)">
            <summary>
            Compile a series of goals (basically a conjunction)
            </summary>
            <param name="body">Goals to compile</param>
            <param name="fail">Where to fail to if the body fails</param>
            <param name="identifierSuffix">String that if placed after an identifier will guarantee the identifier is unique</param>
            <returns>Continuation that will restart this body</returns>
        </member>
        <member name="M:TED.Compiler.Compiler.CompileGoal(TED.Interpreter.Call,TED.Compiler.Continuation,System.String)">
            <summary>
            Compile a single goal
            </summary>
            <param name="call">Goal to compile</param>
            <param name="fail">Where this goal should fail to if it fials</param>
            <param name="identifierSuffix">String that if placed after an identifier will guarantee the identifier is unique</param>
            <returns>Continuation that will restart this goal</returns>
        </member>
        <member name="M:TED.Compiler.Compiler.PatternValueExpression(TED.Interpreter.IPattern)">
            <summary>
            Returns a string that, when executed will give you the value of the specified pattern.
            </summary>
            <param name="pattern">Pattern to get the value of </param>
            <returns>Expression that computes the vlaue of the pattern (usually a tuple)</returns>
            <exception cref="T:System.InvalidOperationException">If pattern is not fully instantiated</exception>
        </member>
        <member name="M:TED.Compiler.Compiler.CompilePatternMatch(System.String,TED.Interpreter.IPattern,TED.Compiler.Continuation)">
            <summary>
            Emit code to match tupleVar to the specified pattern.
            This will update variables or compare them to tuple values, depending on the read/write modes of the pattern's arguments.
            </summary>
            <param name="tupleVar">Name of the variable containing the tuple</param>
            <param name="p">Pattern to match the tuple to</param>
            <param name="fail">Where to branch to if the match fails (falls through for success)</param>
        </member>
        <member name="M:TED.Compiler.Compiler.CompileMatch(System.String,TED.Interpreter.IMatchOperation,TED.Compiler.Continuation)">
            <summary>
            Emit code to match item to the specified pattern argument (variable+read/write mode or constant).
            This will update variables or compare them to tuple values, depending on the read/write modes of the pattern's arguments.
            </summary>
            <param name="item">Code for expression containing the item</param>
            <param name="patternArg">Match operation</param>
            <param name="fail">Target to branch to upon failure (falls through for success)</param>
        </member>
        <member name="M:TED.Compiler.Compiler.CompileJumpTable(System.String,System.Collections.Generic.IEnumerable{TED.Compiler.Continuation})">
            <summary>
            Emits code to branch to the controlExpression'th label in targets.
            </summary>
            <param name="controlExpression">Integer variable containing the number of the target to branch to</param>
            <param name="targets">The targets, in order</param>
        </member>
        <member name="T:TED.Constant`1">
            <summary>
            Terms that represent constants of type T
            </summary>
        </member>
        <member name="F:TED.Constant`1.Value">
            <summary>
            The actual constant
            </summary>
        </member>
        <member name="P:TED.Constant`1.ValueUntyped">
            <inheritdoc />
        </member>
        <member name="M:TED.Constant`1.#ctor(`0)">
            <summary>
            Make a Constant object to wrap the specified constant
            </summary>
            <param name="value">value to wrap</param>
        </member>
        <member name="M:TED.Constant`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:TED.Constant`1.MakeEvaluator(TED.Preprocessing.GoalAnalyzer)">
            <inheritdoc />
        </member>
        <member name="M:TED.Constant`1.IsSameConstant(TED.Term)">
            <inheritdoc />
        </member>
        <member name="M:TED.Constant`1.ToSourceExpression(TED.Compiler.Compiler)">
            <inheritdoc />
        </member>
        <member name="T:TED.Definition">
            <summary>
            Untyped base class of all definitions
            A definition is basically a macro
            It's a predicate that gets in-lined whenever it's called.
            Definitions currently only allow one rule.
            </summary>
        </member>
        <member name="F:TED.Definition.Body">
            <summary>
            Sequence of goals into which this definition should be expanded
            </summary>
        </member>
        <member name="F:TED.Definition.Rules">
            <summary>
            Rules defining the Definition if it's defined by separate rules
            </summary>
        </member>
        <member name="M:TED.Definition.#ctor(System.String)">
            <inheritdoc />
        </member>
        <member name="M:TED.Definition.op_Implicit(TED.Definition)~TED.Interpreter.Goal">
            <summary>
            A call to this definition using it's "default" arguments
            </summary>
        </member>
        <member name="T:TED.Definition.DefinitionGoal">
            <summary>
            Goal representing a call to a definition
            This will get expanded in-line by the calling rule at preprocessing time
            </summary>
        </member>
        <member name="F:TED.Definition.DefinitionGoal.Definition">
            <summary>
            The definition being called
            </summary>
        </member>
        <member name="M:TED.Definition.DefinitionGoal.#ctor(TED.Definition,TED.Term[])">
            <summary>
            Make a goal to call the definition with the specified arguments
            </summary>
        </member>
        <member name="P:TED.Definition.DefinitionGoal.Predicate">
            <inheritdoc />
        </member>
        <member name="M:TED.Definition.DefinitionGoal.MakeSubstitution">
            <summary>
            Make a substitution that will substitute the formal arguments of the definition
            with the actual arguments passed in this goal
            </summary>
        </member>
        <member name="M:TED.Definition.DefinitionGoal.Expand">
            <summary>
            Generate a copy of the goals of the substitution with the actual arguments
            substituted for the formal arguments
            </summary>
            <returns>Substituted goals</returns>
            <exception cref="T:System.Exception">If not body has yet been specified for the definition</exception>
        </member>
        <member name="M:TED.Definition.DefinitionGoal.If(TED.Interpreter.Goal[])">
            <summary>
            Add a new goal to the definition rules
            </summary>
            <param name="body"></param>
        </member>
        <member name="M:TED.Definition.DefinitionGoal.Fact">
            <summary>
            Add a rule to the definition with no subgoals
            </summary>
        </member>
        <member name="T:TED.Definition`1">
            <summary>
            A one-argument predicate defined by a single rule.
            Calls to the predicate are always inlined, so the predicate doesn't have to have a finite extension.
            </summary>
        </member>
        <member name="M:TED.Definition`1.#ctor(System.String,TED.Var{`0})">
            <summary>
            Make a one-argument predicate defined by a single rule.
            Calls to the predicate are always inlined, so the predicate doesn't have to have a finite extension.
            </summary>
        </member>
        <member name="F:TED.Definition`1.Arg1">
            <summary>
            First argument
            </summary>
        </member>
        <member name="P:TED.Definition`1.Item(TED.Term{`0})">
            <summary>
            Make a call to the predicate.  Since this is a definition, it will be inlined in the rule it's contained in.
            </summary>
        </member>
        <member name="M:TED.Definition`1.Is(TED.Interpreter.Goal[])">
            <summary>
            Specify the sequence of goals into which calls to this definition should be transformed.
            </summary>
            <param name="body">Goals to substitute for the definition</param>
            <returns>The definition object</returns>
            <exception cref="T:System.InvalidOperationException">If a body has already been specified</exception>
        </member>
        <member name="M:TED.Definition`1.If(TED.Interpreter.Goal[])">
            <summary>
            Default argument If
            </summary>
            <param name="body"></param>
        </member>
        <member name="T:TED.Definition`1.Goal">
            <inheritdoc />
        </member>
        <member name="M:TED.Definition`1.Goal.#ctor(TED.Definition{`0},TED.Term{`0})">
            <inheritdoc />
        </member>
        <member name="T:TED.Definition`2">
            <summary>
            A two-argument predicate defined by a single rule.
            Calls to the predicate are always inlined, so the predicate doesn't have to have a finite extension.
            </summary>
        </member>
        <member name="M:TED.Definition`2.#ctor(System.String,TED.Var{`0},TED.Var{`1})">
            <summary>
            Make a two-argument predicate defined by a single rule.
            Calls to the predicate are always inlined, so the predicate doesn't have to have a finite extension.
            </summary>
        </member>
        <member name="F:TED.Definition`2.Arg1">
            <summary>
            First Argument
            </summary>
        </member>
        <member name="F:TED.Definition`2.Arg2">
            <summary>
            Second Argument
            </summary>
        </member>
        <member name="P:TED.Definition`2.Item(TED.Term{`0},TED.Term{`1})">
            <summary>
            Make a call to the predicate.  Since this is a definition, it will be inlined in the rule it's contained in.
            </summary>
        </member>
        <member name="M:TED.Definition`2.Is(TED.Interpreter.Goal[])">
            <summary>
            Specify the sequence of goals into which calls to this definition should be transformed.
            </summary>
            <param name="body">Goals to substitute for the definition</param>
            <returns>The definition object</returns>
            <exception cref="T:System.InvalidOperationException">If a body has already been specified</exception>
        </member>
        <member name="M:TED.Definition`2.If(TED.Interpreter.Goal[])">
            <summary>
            Default argument If
            </summary>
            <param name="body"></param>
        </member>
        <member name="T:TED.Definition`2.Goal">
            <summary>
            Make a call to the predicate.  Since this is a definition, it will be inlined in the rule it's contained in.
            </summary>
        </member>
        <member name="F:TED.Definition`2.Goal.arg1">
            <summary>
            First argument
            </summary>
        </member>
        <member name="F:TED.Definition`2.Goal.arg2">
            <summary>
            Second argument
            </summary>
        </member>
        <member name="M:TED.Definition`2.Goal.#ctor(TED.Definition{`0,`1},TED.Term{`0},TED.Term{`1})">
            <inheritdoc />
        </member>
        <member name="T:TED.Definition`3">
            <summary>
            A three-argument predicate defined by a single rule.
            Calls to the predicate are always inlined, so the predicate doesn't have to have a finite extension.
            </summary>
        </member>
        <member name="M:TED.Definition`3.#ctor(System.String,TED.Var{`0},TED.Var{`1},TED.Var{`2})">
            <summary>
            Make a three-argument predicate defined by a single rule.
            Calls to the predicate are always inlined, so the predicate doesn't have to have a finite extension.
            </summary>
        </member>
        <member name="F:TED.Definition`3.Arg1">
            <summary>
            First Argument
            </summary>
        </member>
        <member name="F:TED.Definition`3.Arg2">
            <summary>
            Second Argument
            </summary>
        </member>
        <member name="F:TED.Definition`3.Arg3">
            <summary>
            Third argument
            </summary>
        </member>
        <member name="P:TED.Definition`3.Item(TED.Term{`0},TED.Term{`1},TED.Term{`2})">
            <summary>
            Make a call to the predicate.  Since this is a definition, it will be inlined in the rule it's contained in.
            </summary>
            <summary>
            Make a call to the predicate.  Since this is a definition, it will be inlined in the rule it's contained in.
            </summary>
        </member>
        <member name="M:TED.Definition`3.Is(TED.Interpreter.Goal[])">
            <summary>
            Specify the sequence of goals into which calls to this definition should be transformed.
            </summary>
            <param name="body">Goals to substitute for the definition</param>
            <returns>The definition object</returns>
            <exception cref="T:System.InvalidOperationException">If a body has already been specified</exception>
        </member>
        <member name="M:TED.Definition`3.If(TED.Interpreter.Goal[])">
            <summary>
            Default argument If
            </summary>
            <param name="body"></param>
        </member>
        <member name="T:TED.Definition`3.Goal">
            <inheritdoc />
        </member>
        <member name="F:TED.Definition`3.Goal.arg1">
            <summary>
            First argument
            </summary>
        </member>
        <member name="F:TED.Definition`3.Goal.arg2">
            <summary>
            Second argument
            </summary>
        </member>
        <member name="F:TED.Definition`3.Goal.arg3">
            <summary>
            Third argument
            </summary>
        </member>
        <member name="M:TED.Definition`3.Goal.#ctor(TED.Definition{`0,`1,`2},TED.Term{`0},TED.Term{`1},TED.Term{`2})">
            <inheritdoc />
        </member>
        <member name="T:TED.Definition`4">
            <summary>
            A four-argument predicate defined by a single rule.
            Calls to the predicate are always inlined, so the predicate doesn't have to have a finite extension.
            </summary>
        </member>
        <member name="M:TED.Definition`4.#ctor(System.String,TED.Var{`0},TED.Var{`1},TED.Var{`2},TED.Var{`3})">
            <summary>
            Make a four-argument predicate defined by a single rule.
            Calls to the predicate are always inlined, so the predicate doesn't have to have a finite extension.
            </summary>
        </member>
        <member name="F:TED.Definition`4.Arg1">
            <summary>
            First Argument
            </summary>
        </member>
        <member name="F:TED.Definition`4.Arg2">
            <summary>
            Second Argument
            </summary>
        </member>
        <member name="F:TED.Definition`4.Arg3">
            <summary>
            Third argument
            </summary>
        </member>
        <member name="F:TED.Definition`4.Arg4">
            <summary>
            Fourth argument
            </summary>
        </member>
        <member name="P:TED.Definition`4.Item(TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3})">
            <summary>
            Make a call to the predicate.  Since this is a definition, it will be inlined in the rule it's contained in.
            </summary>
            <summary>
            Make a call to the predicate.  Since this is a definition, it will be inlined in the rule it's contained in.
            </summary>
        </member>
        <member name="M:TED.Definition`4.Is(TED.Interpreter.Goal[])">
            <summary>
            Specify the sequence of goals into which calls to this definition should be transformed.
            </summary>
            <param name="body">Goals to substitute for the definition</param>
            <returns>The definition object</returns>
            <exception cref="T:System.InvalidOperationException">If a body has already been specified</exception>
        </member>
        <member name="M:TED.Definition`4.If(TED.Interpreter.Goal[])">
            <summary>
            Default argument If
            </summary>
            <param name="body"></param>
        </member>
        <member name="T:TED.Definition`4.Goal">
            <inheritdoc />
        </member>
        <member name="F:TED.Definition`4.Goal.arg1">
            <summary>
            First argument
            </summary>
        </member>
        <member name="F:TED.Definition`4.Goal.arg2">
            <summary>
            Second argument
            </summary>
        </member>
        <member name="F:TED.Definition`4.Goal.arg3">
            <summary>
            Third argument
            </summary>
        </member>
        <member name="F:TED.Definition`4.Goal.arg4">
            <summary>
            Fourth argument
            </summary>
        </member>
        <member name="M:TED.Definition`4.Goal.#ctor(TED.Definition{`0,`1,`2,`3},TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3})">
            <inheritdoc />
        </member>
        <member name="T:TED.Definition`5">
            <summary>
            A five-argument predicate defined by a single rule.
            Calls to the predicate are always inlined, so the predicate doesn't have to have a finite extension.
            </summary>
        </member>
        <member name="M:TED.Definition`5.#ctor(System.String,TED.Var{`0},TED.Var{`1},TED.Var{`2},TED.Var{`3},TED.Var{`4})">
            <summary>
            Make a five-argument predicate defined by a single rule.
            Calls to the predicate are always inlined, so the predicate doesn't have to have a finite extension.
            </summary>
        </member>
        <member name="F:TED.Definition`5.Arg1">
            <summary>
            First Argument
            </summary>
        </member>
        <member name="F:TED.Definition`5.Arg2">
            <summary>
            Second Argument
            </summary>
        </member>
        <member name="F:TED.Definition`5.Arg3">
            <summary>
            Third argument
            </summary>
        </member>
        <member name="F:TED.Definition`5.Arg4">
            <summary>
            Fourth argument
            </summary>
        </member>
        <member name="F:TED.Definition`5.Arg5">
            <summary>
            Fifth argument
            </summary>
        </member>
        <member name="P:TED.Definition`5.Item(TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3},TED.Term{`4})">
            <summary>
            Make a call to the predicate.  Since this is a definition, it will be inlined in the rule it's contained in.
            </summary>
            <summary>
            Make a call to the predicate.  Since this is a definition, it will be inlined in the rule it's contained in.
            </summary>
        </member>
        <member name="M:TED.Definition`5.Is(TED.Interpreter.Goal[])">
            <summary>
            Specify the sequence of goals into which calls to this definition should be transformed.
            </summary>
            <param name="body">Goals to substitute for the definition</param>
            <returns>The definition object</returns>
            <exception cref="T:System.InvalidOperationException">If a body has already been specified</exception>
        </member>
        <member name="M:TED.Definition`5.If(TED.Interpreter.Goal[])">
            <summary>
            Default argument If
            </summary>
            <param name="body"></param>
        </member>
        <member name="T:TED.Definition`5.Goal">
            <inheritdoc />
        </member>
        <member name="F:TED.Definition`5.Goal.arg1">
            <summary>
            First argument
            </summary>
        </member>
        <member name="F:TED.Definition`5.Goal.arg2">
            <summary>
            Second argument
            </summary>
        </member>
        <member name="F:TED.Definition`5.Goal.arg3">
            <summary>
            Third argument
            </summary>
        </member>
        <member name="F:TED.Definition`5.Goal.arg4">
            <summary>
            Fourth argument
            </summary>
        </member>
        <member name="F:TED.Definition`5.Goal.arg5">
            <summary>
            Fifth argument
            </summary>
        </member>
        <member name="M:TED.Definition`5.Goal.#ctor(TED.Definition{`0,`1,`2,`3,`4},TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3},TED.Term{`4})">
            <inheritdoc />
        </member>
        <member name="T:TED.Definition`6">
            <summary>
            A six-argument predicate defined by a single rule.
            Calls to the predicate are always inlined, so the predicate doesn't have to have a finite extension.
            </summary>
        </member>
        <member name="M:TED.Definition`6.#ctor(System.String,TED.Var{`0},TED.Var{`1},TED.Var{`2},TED.Var{`3},TED.Var{`4},TED.Var{`5})">
            <summary>
            Make a six-argument predicate defined by a single rule.
            Calls to the predicate are always inlined, so the predicate doesn't have to have a finite extension.
            </summary>
        </member>
        <member name="F:TED.Definition`6.Arg1">
            <summary>
            First Argument
            </summary>
        </member>
        <member name="F:TED.Definition`6.Arg2">
            <summary>
            Second Argument
            </summary>
        </member>
        <member name="F:TED.Definition`6.Arg3">
            <summary>
            Third argument
            </summary>
        </member>
        <member name="F:TED.Definition`6.Arg4">
            <summary>
            Fourth argument
            </summary>
        </member>
        <member name="F:TED.Definition`6.Arg5">
            <summary>
            Fifth argument
            </summary>
        </member>
        <member name="F:TED.Definition`6.Arg6">
            <summary>
            Sixth argument
            </summary>
        </member>
        <member name="P:TED.Definition`6.Item(TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3},TED.Term{`4},TED.Term{`5})">
            <summary>
            Make a call to the predicate.  Since this is a definition, it will be inlined in the rule it's contained in.
            </summary>
        </member>
        <member name="M:TED.Definition`6.Is(TED.Interpreter.Goal[])">
            <summary>
            Specify the sequence of goals into which calls to this definition should be transformed.
            </summary>
            <param name="body">Goals to substitute for the definition</param>
            <returns>The definition object</returns>
            <exception cref="T:System.InvalidOperationException">If a body has already been specified</exception>
        </member>
        <member name="M:TED.Definition`6.If(TED.Interpreter.Goal[])">
            <summary>
            Default argument If
            </summary>
            <param name="body"></param>
        </member>
        <member name="T:TED.Definition`6.Goal">
            <inheritdoc />
        </member>
        <member name="F:TED.Definition`6.Goal.arg1">
            <summary>
            First argument
            </summary>
        </member>
        <member name="F:TED.Definition`6.Goal.arg2">
            <summary>
            Second argument
            </summary>
        </member>
        <member name="F:TED.Definition`6.Goal.arg3">
            <summary>
            Third argument
            </summary>
        </member>
        <member name="F:TED.Definition`6.Goal.arg4">
            <summary>
            Fourth argument
            </summary>
        </member>
        <member name="F:TED.Definition`6.Goal.arg5">
            <summary>
            Fourth argument
            </summary>
        </member>
        <member name="F:TED.Definition`6.Goal.arg6">
            <summary>
            Sixth argument
            </summary>
        </member>
        <member name="M:TED.Definition`6.Goal.#ctor(TED.Definition{`0,`1,`2,`3,`4,`5},TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3},TED.Term{`4},TED.Term{`5})">
            <inheritdoc />
        </member>
        <member name="T:TED.DuplicateKeyException">
            <summary>
            Exception indicating that a row is being added to a table that already contains a different row with the same key value
            </summary>
        </member>
        <member name="M:TED.DuplicateKeyException.#ctor(TED.TablePredicate,System.Object)">
            <summary>
            Exception indicating that a row is being added to a table that already contains a different row with the same key value
            </summary>
        </member>
        <member name="M:TED.DuplicateKeyException.NullSafeToString(System.Object)">
            <summary>
            Convert value to a string, returning the null value as "null"
            </summary>
        </member>
        <member name="T:TED.Function">
            <summary>
            Untyped base class for objects that wrap C# functions
            </summary>
        </member>
        <member name="F:TED.Function.Name">
            <summary>
            Name, for debugging purposes
            </summary>
        </member>
        <member name="M:TED.Function.#ctor(System.String,System.Boolean)">
            <summary>
            Make a TedFunction with the specified name
            </summary>
        </member>
        <member name="M:TED.Function.ToString">
            <inheritdoc />
        </member>
        <member name="P:TED.Function.RenderAsOperator">
            <summary>
            True if calls to this function should be printed as an operator rather than in F(args) format.
            </summary>
        </member>
        <member name="P:TED.Function.IsPure">
            <summary>
            True if the function always returns the same value for the same inputs, and has no side-effects.
            </summary>
        </member>
        <member name="F:TED.Function.CustomExpressionCompiler">
            <summary>
            Custom delegate for generating expression strings for this function given strings for its arguments
            </summary>
        </member>
        <member name="T:TED.Function`1">
            <summary>
            A wrapper for a C# function to allow it to be called from TED expressions
            </summary>
        </member>
        <member name="M:TED.Function`1.#ctor(System.String,System.Func{`0},System.Boolean)">
            <summary>
            Make a new TedFunction to wrap the specified C# function
            </summary>
        </member>
        <member name="P:TED.Function`1.Item(TED.Term{`0})">
            <summary>
            True when result is the result of this function.
            </summary>
            <param name="result">Output of this function</param>
        </member>
        <member name="M:TED.Function`1.Call">
            <summary>
            Make a call to this parameterless function
            </summary>
            <returns></returns>
        </member>
        <member name="T:TED.Function`2">
            <summary>
            A wrapper for a C# function to allow it to be called from TED expressions
            </summary>
        </member>
        <member name="M:TED.Function`2.#ctor(System.String,System.Func{`0,`1},System.Boolean)">
            <summary>
            Make a new TedFunction to wrap the specified C# function
            </summary>
        </member>
        <member name="P:TED.Function`2.Item(TED.Term{`0})">
            <summary>
            Make a call to the function
            </summary>
        </member>
        <member name="P:TED.Function`2.Item(TED.Term{`0},TED.Term{`1})">
            <summary>
            True when result is the result of this function.
            </summary>
            <param name="arg1">First input to function</param>
            <param name="result">Output of this function</param>
        </member>
        <member name="T:TED.Function`3">
            <summary>
            A wrapper for a C# function to allow it to be called from TED expressions
            </summary>
        </member>
        <member name="M:TED.Function`3.#ctor(System.String,System.Func{`0,`1,`2},System.Boolean)">
            <summary>
            Make a new TedFunction to wrap the specified C# function
            </summary>
        </member>
        <member name="P:TED.Function`3.Item(TED.Term{`0},TED.Term{`1})">
            <summary>
            Make a call to the function
            </summary>
        </member>
        <member name="P:TED.Function`3.Item(TED.Term{`0},TED.Term{`1},TED.Term{`2})">
            <summary>
            True when result is the result of this function.
            </summary>
            <param name="arg1">First input to function</param>
            <param name="arg2">Second input</param>
            <param name="result">Output of this function</param>
        </member>
        <member name="T:TED.Function`4">
            <summary>
            A wrapper for a C# function to allow it to be called from TED expressions
            </summary>
        </member>
        <member name="M:TED.Function`4.#ctor(System.String,System.Func{`0,`1,`2,`3},System.Boolean)">
            <summary>
            Make a new TedFunction to wrap the specified C# function
            </summary>
        </member>
        <member name="P:TED.Function`4.Item(TED.Term{`0},TED.Term{`1},TED.Term{`2})">
            <summary>
            Make a call to the function
            </summary>
        </member>
        <member name="P:TED.Function`4.Item(TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3})">
            <summary>
            True when result is the result of this function.
            </summary>
            <param name="arg1">First input to function</param>
            <param name="arg2">Second input</param>
            <param name="arg3">Third input</param>
            <param name="result">Output of this function</param>
        </member>
        <member name="T:TED.Function`5">
            <summary>
            A wrapper for a C# function to allow it to be called from TED expressions
            </summary>
        </member>
        <member name="M:TED.Function`5.#ctor(System.String,System.Func{`0,`1,`2,`3,`4},System.Boolean)">
            <summary>
            Make a new TedFunction to wrap the specified C# function
            </summary>
        </member>
        <member name="P:TED.Function`5.Item(TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3})">
            <summary>
            Make a call to the function
            </summary>
        </member>
        <member name="P:TED.Function`5.Item(TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3},TED.Term{`4})">
            <summary>
            True when result is the result of this function.
            </summary>
            <param name="arg1">First input to function</param>
            <param name="arg2">Second input</param>
            <param name="arg3">Third input</param>
            <param name="arg4">Fourth input</param>
            <param name="result">Output of this function</param>
        </member>
        <member name="T:TED.Function`6">
            <summary>
            A wrapper for a C# function to allow it to be called from TED expressions
            </summary>
        </member>
        <member name="M:TED.Function`6.#ctor(System.String,System.Func{`0,`1,`2,`3,`4,`5},System.Boolean)">
            <summary>
            Make a new TedFunction to wrap the specified C# function
            </summary>
        </member>
        <member name="P:TED.Function`6.Item(TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3},TED.Term{`4})">
            <summary>
            Make a call to the function
            </summary>
        </member>
        <member name="P:TED.Function`6.Item(TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3},TED.Term{`4},TED.Term{`5})">
            <summary>
            True when result is the result of this function.
            </summary>
            <param name="arg1">First input to function</param>
            <param name="arg2">Second input</param>
            <param name="arg3">Third input</param>
            <param name="arg4">Fourth input</param>
            <param name="arg5">Fifth input</param>
            <param name="result">Output of this function</param>
        </member>
        <member name="T:TED.Function`7">
            <summary>
            A wrapper for a C# function to allow it to be called from TED expressions
            </summary>
        </member>
        <member name="M:TED.Function`7.#ctor(System.String,System.Func{`0,`1,`2,`3,`4,`5,`6},System.Boolean)">
            <summary>
            Make a new TedFunction to wrap the specified C# function
            </summary>
        </member>
        <member name="P:TED.Function`7.Item(TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3},TED.Term{`4},TED.Term{`5})">
            <summary>
            Make a call to the function
            </summary>
        </member>
        <member name="P:TED.Function`7.Item(TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3},TED.Term{`4},TED.Term{`5},TED.Term{`6})">
            <summary>
            True when result is the result of this function.
            </summary>
            <param name="arg1">First input to function</param>
            <param name="arg2">Second input</param>
            <param name="arg3">Third input</param>
            <param name="arg4">Fourth input</param>
            <param name="arg5">Fifth input</param>
            <param name="arg6">Sixth input</param>
            <param name="result">Output of this function</param>
        </member>
        <member name="T:TED.Function`8">
            <summary>
            A wrapper for a C# function to allow it to be called from TED expressions
            </summary>
        </member>
        <member name="M:TED.Function`8.#ctor(System.String,System.Func{`0,`1,`2,`3,`4,`5,`6,`7},System.Boolean)">
            <summary>
            Make a new TedFunction to wrap the specified C# function
            </summary>
        </member>
        <member name="P:TED.Function`8.Item(TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3},TED.Term{`4},TED.Term{`5},TED.Term{`6})">
            <summary>
            Make a call to the function
            </summary>
        </member>
        <member name="P:TED.Function`8.Item(TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3},TED.Term{`4},TED.Term{`5},TED.Term{`6},TED.Term{`7})">
            <summary>
            True when result is the result of this function.
            </summary>
            <param name="arg1">First input to function</param>
            <param name="arg2">Second input</param>
            <param name="arg3">Third input</param>
            <param name="arg4">Fourth input</param>
            <param name="arg5">Fifth input</param>
            <param name="arg6">Sixth input</param>
            <param name="arg7">Seventh input</param>
            <param name="result">Output of this function</param>
        </member>
        <member name="T:TED.FunctionalExpression`1">
            <summary>
            Base class for terms whose value is of type T but where the value is computed from other Terms by some function.
            </summary>
        </member>
        <member name="M:TED.FunctionalExpression`1.HoistInfo">
            <inheritdoc />
        </member>
        <member name="M:TED.FunctionalExpression`1.ApplySubstitution(TED.Preprocessing.Substitution)">
            <inheritdoc />
        </member>
        <member name="T:TED.InstantiationException">
            <summary>
            Exception that gets thrown when an bound value is passed into a predicate that needs an unbound variable, or vice-versa
            </summary>
        </member>
        <member name="M:TED.InstantiationException.#ctor(System.String)">
            <summary>
            Make an exception signaling that a predicate is being called with an unbound variable that must be bound or vice-versa.
            </summary>
        </member>
        <member name="M:TED.InstantiationException.#ctor(TED.Predicate,TED.Term)">
            <summary>
            Make an exception stating that the specified predicate was called with the specified term as an argument
            and that term either wasn't bound when it should have been was was bound when it shouldn't have.
            </summary>
        </member>
        <member name="T:TED.Interpreter.Call">
            <summary>
            Untyped base class for all calls to predicates.
            These are essentially iterators for the call: they contain the state information used for
            backtracking.  Calls to different kinds of predicates or with different mode patterns may
            have different call objects because they need different state information
            </summary>
        </member>
        <member name="F:TED.Interpreter.Call.Table">
            <summary>
            The predicate being called
            </summary>
        </member>
        <member name="P:TED.Interpreter.Call.IsPure">
            <summary>
            True if the call always produces the same results for the same input tables, and has no side effects of its own.
            </summary>
        </member>
        <member name="M:TED.Interpreter.Call.#ctor(TED.Predicate)">
            <summary>
            Make an object to interpret a particular goal in a particular rule.
            </summary>
            <param name="table"></param>
        </member>
        <member name="P:TED.Interpreter.Call.ArgumentPattern">
            <summary>
            The formal arguments in the call - the variables and constants for each argument
            </summary>
        </member>
        <member name="M:TED.Interpreter.Call.Reset">
            <summary>
            Called before the start of a call.  Initializes any backtracking state for the call
            </summary>
        </member>
        <member name="M:TED.Interpreter.Call.NextSolution">
            <summary>
            Find the first/next solution to the call, writing any variables that need to be bound by it
            </summary>
            <returns>True if it found another solution</returns>
        </member>
        <member name="M:TED.Interpreter.Call.ToString">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.Call.Compile(TED.Compiler.Compiler,TED.Compiler.Continuation,System.String)">
            <summary>
            Generate C# source code for executing this call.
            </summary>
            <param name="compiler">Compiler object generating the source code</param>
            <param name="fail">Continuation to invoke if the call fails.</param>
            <param name="identifierSuffix">Suffix unique to this call that can be added to identifiers in output source to prevent conflicts</param>
            <returns>Continuation the next call in the rule should invoke upon failure</returns>
        </member>
        <member name="T:TED.Interpreter.FunctionCall`1">
            <summary>
            A wrapper for a zero-argument function
            </summary>
            <typeparam name="TOut">Type of the result of the function</typeparam>
        </member>
        <member name="F:TED.Interpreter.FunctionCall`1.Function">
            <summary>
            The function to be called
            </summary>
        </member>
        <member name="M:TED.Interpreter.FunctionCall`1.#ctor(TED.Function{`0})">
            <summary>
            Make a term representing a call to a TEDFunction
            </summary>
        </member>
        <member name="P:TED.Interpreter.FunctionCall`1.IsPure">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.FunctionCall`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.FunctionCall`1.ToSourceExpression(TED.Compiler.Compiler)">
            <inheritdoc />
        </member>
        <member name="T:TED.Interpreter.FunctionCall`2">
            <summary>
            A wrapper for a 1-argument function
            </summary>
            <typeparam name="TIn1">Type of the input of the function</typeparam>
            <typeparam name="TOut">Type of the result of the function</typeparam>
        </member>
        <member name="F:TED.Interpreter.FunctionCall`2.Function">
            <summary>
            The function to be called
            </summary>
        </member>
        <member name="P:TED.Interpreter.FunctionCall`2.IsPure">
            <inheritdoc />
        </member>
        <member name="F:TED.Interpreter.FunctionCall`2.Arg1">
            <summary>
            The argument to the function
            </summary>
        </member>
        <member name="M:TED.Interpreter.FunctionCall`2.#ctor(TED.Function{`0,`1},TED.Term{`0})">
            <summary>
            Make a term representing a call to a TEDFunction
            </summary>
        </member>
        <member name="M:TED.Interpreter.FunctionCall`2.ToString">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.FunctionCall`2.ToSourceExpression(TED.Compiler.Compiler)">
            <inheritdoc />
        </member>
        <member name="T:TED.Interpreter.FunctionCall`3">
            <summary>
            A wrapper for a 2-argument function
            </summary>
            <typeparam name="TIn1">Type of the first input of the function</typeparam>
            <typeparam name="TIn2">Type of the second input of the function</typeparam>
            <typeparam name="TOut">Type of the result of the function</typeparam>
        </member>
        <member name="F:TED.Interpreter.FunctionCall`3.Function">
            <summary>
            The function to be called
            </summary>
        </member>
        <member name="P:TED.Interpreter.FunctionCall`3.IsPure">
            <inheritdoc />
        </member>
        <member name="F:TED.Interpreter.FunctionCall`3.Arg1">
            <summary>
            The first argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.FunctionCall`3.Arg2">
            <summary>
             The second argument
            </summary>
        </member>
        <member name="M:TED.Interpreter.FunctionCall`3.#ctor(TED.Function{`0,`1,`2},TED.Term{`0},TED.Term{`1})">
            <summary>
            Make a term representing a call to a TEDFunction
            </summary>
        </member>
        <member name="M:TED.Interpreter.FunctionCall`3.ToString">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.FunctionCall`3.ToSourceExpression(TED.Compiler.Compiler)">
            <inheritdoc />
        </member>
        <member name="T:TED.Interpreter.FunctionCall`4">
            <summary>
            A wrapper for a 3-argument function
            </summary>
            <typeparam name="TIn1">Type of the first input of the function</typeparam>
            <typeparam name="TIn2">Type of the second input of the function</typeparam>
            <typeparam name="TIn3">Type of the third input of the function</typeparam>
            <typeparam name="TOut">Type of the result of the function</typeparam>
        </member>
        <member name="F:TED.Interpreter.FunctionCall`4.Function">
            <summary>
            The function to be called
            </summary>
        </member>
        <member name="P:TED.Interpreter.FunctionCall`4.IsPure">
            <inheritdoc />
        </member>
        <member name="F:TED.Interpreter.FunctionCall`4.Arg1">
            <summary>
            The first argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.FunctionCall`4.Arg2">
            <summary>
             The second argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.FunctionCall`4.Arg3">
            <summary>
            The third argument
            </summary>
        </member>
        <member name="M:TED.Interpreter.FunctionCall`4.#ctor(TED.Function{`0,`1,`2,`3},TED.Term{`0},TED.Term{`1},TED.Term{`2})">
            <summary>
            Make a term representing a call to a TEDFunction
            </summary>
        </member>
        <member name="M:TED.Interpreter.FunctionCall`4.ToString">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.FunctionCall`4.ToSourceExpression(TED.Compiler.Compiler)">
            <inheritdoc />
        </member>
        <member name="T:TED.Interpreter.FunctionCall`5">
            <summary>
            A wrapper for a 4-argument function
            </summary>
            <typeparam name="TIn1">Type of the first input of the function</typeparam>
            <typeparam name="TIn2">Type of the second input of the function</typeparam>
            <typeparam name="TIn3">Type of the third input of the function</typeparam>
            <typeparam name="TIn4">Type of the fourth input of the function</typeparam>
            <typeparam name="TOut">Type of the result of the function</typeparam>
        </member>
        <member name="F:TED.Interpreter.FunctionCall`5.Function">
            <summary>
            The function to be called
            </summary>
        </member>
        <member name="P:TED.Interpreter.FunctionCall`5.IsPure">
            <inheritdoc />
        </member>
        <member name="F:TED.Interpreter.FunctionCall`5.Arg1">
            <summary>
            The first argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.FunctionCall`5.Arg2">
            <summary>
             The second argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.FunctionCall`5.Arg3">
            <summary>
            The third argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.FunctionCall`5.Arg4">
            <summary>
            The fourth argument
            </summary>
        </member>
        <member name="M:TED.Interpreter.FunctionCall`5.#ctor(TED.Function{`0,`1,`2,`3,`4},TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3})">
            <summary>
            Make a term representing a call to a TEDFunction
            </summary>
        </member>
        <member name="M:TED.Interpreter.FunctionCall`5.ToString">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.FunctionCall`5.ToSourceExpression(TED.Compiler.Compiler)">
            <inheritdoc />
        </member>
        <member name="T:TED.Interpreter.FunctionCall`6">
            <summary>
            A wrapper for a 5-argument function
            </summary>
            <typeparam name="TIn1">Type of the first input of the function</typeparam>
            <typeparam name="TIn2">Type of the second input of the function</typeparam>
            <typeparam name="TIn3">Type of the third input of the function</typeparam>
            <typeparam name="TIn4">Type of the fourth input of the function</typeparam>
            <typeparam name="TIn5">Type of the fifth input of the function</typeparam>
            <typeparam name="TOut">Type of the result of the function</typeparam>
        </member>
        <member name="F:TED.Interpreter.FunctionCall`6.Function">
            <summary>
            The function to be called
            </summary>
        </member>
        <member name="P:TED.Interpreter.FunctionCall`6.IsPure">
            <inheritdoc />
        </member>
        <member name="F:TED.Interpreter.FunctionCall`6.Arg1">
            <summary>
            The first argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.FunctionCall`6.Arg2">
            <summary>
             The second argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.FunctionCall`6.Arg3">
            <summary>
            The third argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.FunctionCall`6.Arg4">
            <summary>
            The fourth argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.FunctionCall`6.Arg5">
            <summary>
            The fifth argument
            </summary>
        </member>
        <member name="M:TED.Interpreter.FunctionCall`6.#ctor(TED.Function{`0,`1,`2,`3,`4,`5},TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3},TED.Term{`4})">
            <summary>
            Make a term representing a call to a TEDFunction
            </summary>
        </member>
        <member name="M:TED.Interpreter.FunctionCall`6.ToString">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.FunctionCall`6.ToSourceExpression(TED.Compiler.Compiler)">
            <inheritdoc />
        </member>
        <member name="T:TED.Interpreter.FunctionCall`7">
            <summary>
            A wrapper for a 6-argument function
            </summary>
            <typeparam name="TIn1">Type of the first input of the function</typeparam>
            <typeparam name="TIn2">Type of the second input of the function</typeparam>
            <typeparam name="TIn3">Type of the third input of the function</typeparam>
            <typeparam name="TIn4">Type of the fourth input of the function</typeparam>
            <typeparam name="TIn5">Type of the fifth input of the function</typeparam>
            <typeparam name="TIn6">Type of the sixth input of the function</typeparam>
            <typeparam name="TOut">Type of the result of the function</typeparam>
        </member>
        <member name="F:TED.Interpreter.FunctionCall`7.Function">
            <summary>
            The function to be called
            </summary>
        </member>
        <member name="P:TED.Interpreter.FunctionCall`7.IsPure">
            <inheritdoc />
        </member>
        <member name="F:TED.Interpreter.FunctionCall`7.Arg1">
            <summary>
            The first argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.FunctionCall`7.Arg2">
            <summary>
             The second argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.FunctionCall`7.Arg3">
            <summary>
            The third argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.FunctionCall`7.Arg4">
            <summary>
            The fourth argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.FunctionCall`7.Arg5">
            <summary>
            The fifth argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.FunctionCall`7.Arg6">
            <summary>
            The sixth argument
            </summary>
        </member>
        <member name="M:TED.Interpreter.FunctionCall`7.#ctor(TED.Function{`0,`1,`2,`3,`4,`5,`6},TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3},TED.Term{`4},TED.Term{`5})">
            <summary>
            Make a term representing a call to a TEDFunction
            </summary>
        </member>
        <member name="M:TED.Interpreter.FunctionCall`7.ToString">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.FunctionCall`7.ToSourceExpression(TED.Compiler.Compiler)">
            <inheritdoc />
        </member>
        <member name="T:TED.Interpreter.FunctionCall`8">
            <summary>
            A wrapper for a 7-argument function
            </summary>
            <typeparam name="TIn1">Type of the first input of the function</typeparam>
            <typeparam name="TIn2">Type of the second input of the function</typeparam>
            <typeparam name="TIn3">Type of the third input of the function</typeparam>
            <typeparam name="TIn4">Type of the fourth input of the function</typeparam>
            <typeparam name="TIn5">Type of the fifth input of the function</typeparam>
            <typeparam name="TIn6">Type of the sixth input of the function</typeparam>
            <typeparam name="TIn7">Type of the seventh input of the function</typeparam>
            <typeparam name="TOut">Type of the result of the function</typeparam>
        </member>
        <member name="F:TED.Interpreter.FunctionCall`8.Function">
            <summary>
            The function to be called
            </summary>
        </member>
        <member name="P:TED.Interpreter.FunctionCall`8.IsPure">
            <inheritdoc />
        </member>
        <member name="F:TED.Interpreter.FunctionCall`8.Arg1">
            <summary>
            The first argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.FunctionCall`8.Arg2">
            <summary>
             The second argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.FunctionCall`8.Arg3">
            <summary>
            The third argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.FunctionCall`8.Arg4">
            <summary>
            The fourth argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.FunctionCall`8.Arg5">
            <summary>
            The fifth argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.FunctionCall`8.Arg6">
            <summary>
            The sixth argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.FunctionCall`8.Arg7">
            <summary>
            The seventh argument
            </summary>
        </member>
        <member name="M:TED.Interpreter.FunctionCall`8.#ctor(TED.Function{`0,`1,`2,`3,`4,`5,`6,`7},TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3},TED.Term{`4},TED.Term{`5},TED.Term{`6})">
            <summary>
            Make a term representing a call to a TEDFunction
            </summary>
        </member>
        <member name="M:TED.Interpreter.FunctionCall`8.ToString">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.FunctionCall`8.ToSourceExpression(TED.Compiler.Compiler)">
            <inheritdoc />
        </member>
        <member name="T:TED.Interpreter.Goal">
             <summary>
             Untyped base class for the abstract syntax tree of a goal (a predicate applied to arguments)
             These are used:
             - As the heads of rules
             - In the bodies of rules
             - As arguments to higher-order predicates appearing in the bodies of rules.
            
             Goals are different from calls.  A Goal is the AST representing a predicate applied to arguments
             these are then "compiled" into Call objects when they're used in the body of a rule.
             </summary>
        </member>
        <member name="F:TED.Interpreter.Goal.Arguments">
            <summary>
            All arguments, as an array.  Used by the printer
            </summary>
        </member>
        <member name="P:TED.Interpreter.Goal.Predicate">
            <summary>
            The predicate being called
            </summary>
        </member>
        <member name="M:TED.Interpreter.Goal.#ctor(TED.Term[])">
            <summary>
            Make an object representing a specific goal, i.e. a specific call to a predicate within a rule.
            </summary>
        </member>
        <member name="P:TED.Interpreter.Goal.IsConstant">
            <summary>
            True if all arguments are constants.
            </summary>
        </member>
        <member name="M:TED.Interpreter.Goal.RenameArguments(TED.Preprocessing.Substitution)">
            <summary>
            Apply a substitution to the arguments of this goal
            </summary>
            <param name="s">Substitution to apply</param>
            <returns>Transformed goal</returns>
        </member>
        <member name="M:TED.Interpreter.Goal.MakeCall(TED.Preprocessing.GoalAnalyzer)">
            <summary>
            Return the call object 
            </summary>
            <param name="ga">Goal scanner used at "compile time" to do binding analysis of variables and track dependencies.</param>
            <returns>The Call object</returns>
        </member>
        <member name="M:TED.Interpreter.Goal.op_LogicalNot(TED.Interpreter.Goal)">
            <summary>
            True if the goal is false
            Sugar for a call to Language.Not.
            </summary>
            <param name="g">Goal to negate</param>
            <returns></returns>
        </member>
        <member name="M:TED.Interpreter.Goal.op_BitwiseAnd(TED.Interpreter.Goal,TED.Interpreter.Goal)">
            <summary>
            True if both the left-hand side and right-hand side goals are true.
            Sugar for a call to Language.And.
            </summary>
            <param name="lhs">Left-hand side goal to and</param>
            <param name="rhs">Right-hand side goal to and</param>
            <returns></returns>
        </member>
        <member name="M:TED.Interpreter.Goal.op_BitwiseOr(TED.Interpreter.Goal,TED.Interpreter.Goal)">
            <summary>
            True if either the left-hand side or right-hand side goals are true.
            Sugar for a call to Language.Or.
            </summary>
            <param name="lhs">Left-hand side goal to or</param>
            <param name="rhs">Right-hand side goal to or</param>
            <returns></returns>
        </member>
        <member name="M:TED.Interpreter.Goal.op_Explicit(System.Boolean)~TED.Interpreter.Goal">
            <summary>
            Convert a boolean to either Language.True, which is a predicate that always succeeds, or Language.False,
            which always fails.
            </summary>
        </member>
        <member name="M:TED.Interpreter.Goal.FoldConstant">
            <summary>
            If this is a goal all of whose arguments are constants, and if the predicate is evaluable
            at preprocessing time, then replace it with Language.True or Language.False.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TED.Interpreter.Goal.ToString">
            <summary>
            Convert the goal to a human-readable string, for purposes of printing.
            </summary>
        </member>
        <member name="M:TED.Interpreter.Goal.ToString(System.Text.StringBuilder)">
            <summary>
            Add the printed representation of the goal to this StringBuilder.
            </summary>
        </member>
        <member name="P:TED.Interpreter.Goal.DebugName">
            <summary>
            This is just so that this appears in human-readable form in the debugger
            </summary>
        </member>
        <member name="T:TED.Interpreter.IColumnSpec">
            <summary>
            A specification of a column/argument in the declaration of a table predicate
            </summary>
        </member>
        <member name="P:TED.Interpreter.IColumnSpec.UntypedVariable">
            <summary>
            Default variable for this column
            </summary>
        </member>
        <member name="P:TED.Interpreter.IColumnSpec.IndexMode">
            <summary>
            Whether to index this column
            </summary>
        </member>
        <member name="P:TED.Interpreter.IColumnSpec.ColumnName">
            <summary>
            Name of this column
            </summary>
        </member>
        <member name="P:TED.Interpreter.IColumnSpec.Priority">
            <summary>
            For general indices, the priority of this index
            </summary>
        </member>
        <member name="P:TED.Interpreter.IColumnSpec.JointPartial">
            <summary>
            This is part of a joint key
            </summary>
        </member>
        <member name="T:TED.Interpreter.IColumnSpec`1">
            <summary>
            Used in the constructor of a TablePredicate to specify information about a column (argument) of the table
            </summary>
        </member>
        <member name="P:TED.Interpreter.IColumnSpec`1.TypedVariable">
            <summary>
            Default variable for this column
            </summary>
        </member>
        <member name="P:TED.Interpreter.IndexedColumnSpec`1.TypedVariable">
            <summary>
            Default variable for this column
            </summary>
        </member>
        <member name="P:TED.Interpreter.IndexedColumnSpec`1.IndexMode">
            <summary>
            Whether to maintain an index for the column
            </summary>
        </member>
        <member name="P:TED.Interpreter.IndexedColumnSpec`1.JointPartial">
            <summary>
            This is part of a joint key
            </summary>
        </member>
        <member name="M:TED.Interpreter.IndexedColumnSpec`1.#ctor(TED.Var{`0},TED.Tables.IndexMode,System.Nullable{System.Int32},System.Boolean)">
            <summary>
            Specify information about a column/argument of a table
            </summary>
            <param name="defaultVariable">Default variable to use</param>
            <param name="indexMode">Whether to maintain an index</param>
            <param name="priority">Relative priority for using this index in a call versus other indices</param>
            <param name="jointPartial">True if this column is part of a joint key</param>
        </member>
        <member name="T:TED.Interpreter.IConstant">
            <summary>
            Untyped base interface to identify Terms as being Constant[T] for some T.
            THE ONLY CLASS THAT SHOULD IMPLEMENT THIS IS Constant[T]!  This only exists to give us a way of asking if a Term is a Constant[T]
            without knowing in advance what T is.
            </summary>
        </member>
        <member name="P:TED.Interpreter.IConstant.Type">
            <summary>
            The type of the constant's value
            </summary>
        </member>
        <member name="M:TED.Interpreter.IConstant.IsSameConstant(TED.Term)">
            <summary>
            True if this and t are both Constants of the same type, with the same value.
            </summary>
        </member>
        <member name="P:TED.Interpreter.IConstant.ValueUntyped">
            <summary>
            The value of the constant
            </summary>
        </member>
        <member name="T:TED.Interpreter.IDefinitionArgument">
            <summary>
            A formal argument for a Definition
            This is an IVariable plus an optional input-output mode
            </summary>
        </member>
        <member name="P:TED.Interpreter.IDefinitionArgument.UntypedVariable">
            <summary>
            The variable that is the formal argument
            </summary>
        </member>
        <member name="P:TED.Interpreter.IDefinitionArgument.Mode">
            <summary>
            Optional mode constraining whether the argument must be input, output, or a literal constant.
            </summary>
        </member>
        <member name="T:TED.Interpreter.IDefinitionArgument`1">
            <summary>
            A formal argument for a Definition
            This is an Var[T] plus an optional input-output mode
            </summary>
        </member>
        <member name="P:TED.Interpreter.IDefinitionArgument`1.TypedVariable">
            <summary>
            The variable that is the formal argument
            </summary>
        </member>
        <member name="T:TED.Interpreter.ModeConstrainedArgument`1">
            <summary>
            An argument for a Definition that has a type constraint added to it.
            </summary>
        </member>
        <member name="P:TED.Interpreter.ModeConstrainedArgument`1.TypedVariable">
            <inheritdoc />
        </member>
        <member name="P:TED.Interpreter.ModeConstrainedArgument`1.UntypedVariable">
            <inheritdoc />
        </member>
        <member name="P:TED.Interpreter.ModeConstrainedArgument`1.Mode">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.ModeConstrainedArgument`1.#ctor(TED.Var{`0},TED.Interpreter.InstantiationConstraint)">
            <summary>
            Make a constrained version of the specified formal argument
            </summary>
            <param name="variable">Variable used as a formal argument</param>
            <param name="mode">Input/output mode to constraint it to</param>
        </member>
        <member name="T:TED.Interpreter.IFunctionalExpression">
            <summary>
            Functions as an untyped base class for FunctionalExpression[T]
            </summary>
        </member>
        <member name="M:TED.Interpreter.IFunctionalExpression.HoistInfo">
            <summary>
            Return the information necessary to hoist a FunctionalExpression from a goal.
            This is only implemented for the FunctionalExpression class.
            </summary>
            <returns>The expression, a variable of the right type to hold it's value, and a call to the Eval primitive to compute it</returns>
            <exception cref="T:System.NotImplementedException">If this object isn't a FunctionalExpression</exception>
        </member>
        <member name="T:TED.Interpreter.InstantiationConstraint">
            <summary>
            Specifies a limitation on the binding state of an argument to a definition.
            </summary>
        </member>
        <member name="F:TED.Interpreter.InstantiationConstraint.In">
            <summary>
            Argument must be an input (i.e. already bound)
            </summary>
        </member>
        <member name="F:TED.Interpreter.InstantiationConstraint.Out">
            <summary>
            Argument must be an output (i.e. not yet bound)
            </summary>
        </member>
        <member name="F:TED.Interpreter.InstantiationConstraint.Constant">
            <summary>
            Argument must be a literal constant
            </summary>
        </member>
        <member name="T:TED.Interpreter.IPattern">
            <summary>
            Interface common to all the different generic Pattern types and their instantiations
            Functions as a base class for the patterns (can't use a real base class because they're structs)
            </summary>
        </member>
        <member name="P:TED.Interpreter.IPattern.IsInstantiated">
            <summary>
            True if all the arguments in the pattern are instantiated.
            That is, they are either constants or variables that have already been given values by some previous call in the rule.
            </summary>
        </member>
        <member name="M:TED.Interpreter.IPattern.IsReadModeAt(System.Int32)">
            <summary>
            True if the index'th input is read mode
            </summary>
        </member>
        <member name="M:TED.Interpreter.IPattern.ArgumentCell(System.Int32)">
            <summary>
            The cell backing the specified argument
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="P:TED.Interpreter.IPattern.Arguments">
            <summary>
            The MatchOperation[T] operations for each of the arguments in the pattern.
            </summary>
        </member>
        <member name="T:TED.Interpreter.IVariable">
            <summary>
            Untyped base interface to identify Terms as being Var[T] for some T.
            THE ONLY CLASS THAT SHOULD IMPLEMENT THIS IS Var[T]!  This only exists to give us a way of asking if a Term is a Var[T]
            without knowing in advance what T is.
            </summary>
        </member>
        <member name="P:TED.Interpreter.IVariable.VariableName">
            <summary>
            Name of the variable
            </summary>
        </member>
        <member name="P:TED.Interpreter.IVariable.Type">
            <summary>
            The type of the variable's value
            </summary>
        </member>
        <member name="M:TED.Interpreter.IVariable.EquateTo(TED.Term)">
            <summary>
            Returns a goal that will succeed iff this variable matches the specified term
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="T:TED.Interpreter.IMatchOperation">
            <summary>
            Base interface for the generic MatchOperation[T] type.
            </summary>
        </member>
        <member name="P:TED.Interpreter.IMatchOperation.Cell">
            <summary>
            ValueCell that holds the data to be matched
            </summary>
        </member>
        <member name="P:TED.Interpreter.IMatchOperation.Type">
            <summary>
            Type of the cell
            </summary>
        </member>
        <member name="P:TED.Interpreter.IMatchOperation.Opcode">
            <summary>
            Matching mode (opcode) used by the match, e.g. read, write, ignore.
            </summary>
        </member>
        <member name="T:TED.Interpreter.Opcode">
            <summary>
            How to match this formal argument in a pattern to the value in a table row.
            </summary>
        </member>
        <member name="F:TED.Interpreter.Opcode.Read">
            <summary>
            The argument is a variable and it's already been bound to a value by a previous call.
            So match the value of the variable's ValueCell to the value.
            </summary>
        </member>
        <member name="F:TED.Interpreter.Opcode.Write">
            <summary>
            The argument is a variable that has not yet been bound to a variable.
            So write the value into the variable's ValueCell
            </summary>
        </member>
        <member name="F:TED.Interpreter.Opcode.Constant">
            <summary>
            The value is a constant stored in a ValueCell, so match the value passed to the one in the ValueCell
            </summary>
        </member>
        <member name="F:TED.Interpreter.Opcode.Ignore">
            <summary>
            The argument is a variable that isn't used anywhere else.  So don't bother doing anything.
            </summary>
        </member>
        <member name="T:TED.Interpreter.MatchOperation`1">
            <summary>
            Represents an instance of an argument being passed to a predicate
            Represents:
            - What is being passed (variable or constant, both represented by a ValueCell)
            - Whether it is
                - The first use of a variable, and so needs to be stored into the variable (Write mode)
                - It's a constant (Constant mode) or variable that's already been set (Read mode)
                - It's ignored
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:TED.Interpreter.MatchOperation`1.opcode">
            <summary>
            Whether we are reading, writing or ignoring the argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.MatchOperation`1.ValueCell">
            <summary>
            The value cell to contain the argument value
            </summary>
        </member>
        <member name="P:TED.Interpreter.MatchOperation`1.IsInstantiated">
            <summary>
            Are we comparing to a known value?
            </summary>
        </member>
        <member name="M:TED.Interpreter.MatchOperation`1.Constant(`0)">
            <summary>
            A MatchOperation that tests whether the value we're matching to is a specified constant
            </summary>
        </member>
        <member name="M:TED.Interpreter.MatchOperation`1.Read(TED.Interpreter.ValueCell{`0})">
            <summary>
            A MatchOperation that tests whether the value we're matching is the value of a bound variable
            </summary>
        </member>
        <member name="M:TED.Interpreter.MatchOperation`1.Write(TED.Interpreter.ValueCell{`0})">
            <summary>
            A MatchOperation that stores the value being matched to into a variable (variable should not be previously bound)
            </summary>
        </member>
        <member name="M:TED.Interpreter.MatchOperation`1.Write(`0@)">
            <summary>
            Write the value of the variable or constant in the MatchOperation to the specified location
            </summary>
            <param name="target"></param>
        </member>
        <member name="M:TED.Interpreter.MatchOperation`1.Match(`0@)">
            <summary>
            Return the value of the variable or constant in this MatchOperation.
            </summary>
            <param name="target"></param>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="P:TED.Interpreter.MatchOperation`1.Value">
            <summary>
            Return the value of the variable or constant in this MatchOperation.
            </summary>
        </member>
        <member name="M:TED.Interpreter.MatchOperation`1.ToString">
            <inheritdoc />
        </member>
        <member name="P:TED.Interpreter.MatchOperation`1.Cell">
            <inheritdoc />
        </member>
        <member name="P:TED.Interpreter.MatchOperation`1.Type">
            <inheritdoc />
        </member>
        <member name="P:TED.Interpreter.MatchOperation`1.Opcode">
            <inheritdoc />
        </member>
        <member name="T:TED.Interpreter.Pattern">
            <summary>
            Describes how to match or write the value of the arguments in a Goal
            Compiled from the arguments to a Goal object
            </summary>
        </member>
        <member name="P:TED.Interpreter.Pattern.IsInstantiated">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.Pattern.IsReadModeAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.Pattern.ToString">
            <inheritdoc />
        </member>
        <member name="P:TED.Interpreter.Pattern.Arguments">
            <inheritdoc />
        </member>
        <member name="T:TED.Interpreter.Pattern`1">
            <summary>
            Describes how to match or write the value of the arguments in a Goal
            Compiled from the arguments to a Goal object
            </summary>
            <typeparam name="T1">Type of the goal's argument</typeparam>
        </member>
        <member name="F:TED.Interpreter.Pattern`1.Arg1">
            <summary>
            Argument
            </summary>
        </member>
        <member name="M:TED.Interpreter.Pattern`1.#ctor(TED.Interpreter.MatchOperation{`0})">
            <summary>
            Make a pattern with the specified arguments
            </summary>
        </member>
        <member name="M:TED.Interpreter.Pattern`1.Write(`0@)">
            <summary>
            Write the values from the pattern out to a row in a table after a successful match
            </summary>
        </member>
        <member name="P:TED.Interpreter.Pattern`1.Value">
            <summary>
            The value the pattern was successfully matched to
            </summary>
        </member>
        <member name="M:TED.Interpreter.Pattern`1.Match(`0@)">
            <summary>
            Attempt to match this pattern to a row, storing the relevant values into
            any Cells contained in the pattern, when those arguments are in write mode.
            </summary>
        </member>
        <member name="P:TED.Interpreter.Pattern`1.IsInstantiated">
            <summary>
            True if all arguments in the pattern are instantiated.
            </summary>
        </member>
        <member name="M:TED.Interpreter.Pattern`1.IsReadModeAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.Pattern`1.ArgumentCell(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.Pattern`1.ToString">
            <inheritdoc />
        </member>
        <member name="P:TED.Interpreter.Pattern`1.Arguments">
            <inheritdoc />
        </member>
        <member name="T:TED.Interpreter.Pattern`2">
            <summary>
            Describes how to match or write the value of the arguments in a Goal
            Compiled from the arguments to a Goal object
            </summary>
            <typeparam name="T1">Type of the goal's first argument</typeparam>
            <typeparam name="T2">Type of the goal's second argument</typeparam>
        </member>
        <member name="F:TED.Interpreter.Pattern`2.Arg1">
            <summary>
            First argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.Pattern`2.Arg2">
            <summary>
            Second argument
            </summary>
        </member>
        <member name="M:TED.Interpreter.Pattern`2.#ctor(TED.Interpreter.MatchOperation{`0},TED.Interpreter.MatchOperation{`1})">
            <summary>
            Make a pattern with the specified arguments
            </summary>
        </member>
        <member name="M:TED.Interpreter.Pattern`2.Write(System.ValueTuple{`0,`1}@)">
            <summary>
            Write the values from the pattern out to a row in a table after a successful match
            </summary>
        </member>
        <member name="P:TED.Interpreter.Pattern`2.Value">
            <summary>
            The value the pattern was successfully matched to
            </summary>
        </member>
        <member name="M:TED.Interpreter.Pattern`2.Match(System.ValueTuple{`0,`1}@)">
            <summary>
            Attempt to match this pattern to a row, storing the relevant values into
            any Cells contained in the pattern, when those arguments are in write mode.
            </summary>
        </member>
        <member name="P:TED.Interpreter.Pattern`2.IsInstantiated">
            <summary>
            True if all arguments in the pattern are instantiated.
            </summary>
        </member>
        <member name="M:TED.Interpreter.Pattern`2.IsReadModeAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.Pattern`2.ArgumentCell(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.Pattern`2.ToString">
            <inheritdoc />
        </member>
        <member name="P:TED.Interpreter.Pattern`2.Arguments">
            <inheritdoc />
        </member>
        <member name="T:TED.Interpreter.Pattern`3">
            <summary>
            Describes how to match or write the value of the arguments in a Goal
            Compiled from the arguments to a Goal object
            </summary>
            <typeparam name="T1">Type of the goal's first argument</typeparam>
            <typeparam name="T2">Type of the goal's second argument</typeparam>
            <typeparam name="T3">Type of the goal's third argument</typeparam>
        </member>
        <member name="F:TED.Interpreter.Pattern`3.Arg1">
            <summary>
            First argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.Pattern`3.Arg2">
            <summary>
            Second argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.Pattern`3.Arg3">
            <summary>
            Third argument
            </summary>
        </member>
        <member name="M:TED.Interpreter.Pattern`3.#ctor(TED.Interpreter.MatchOperation{`0},TED.Interpreter.MatchOperation{`1},TED.Interpreter.MatchOperation{`2})">
            <summary>
            Make a pattern with the specified arguments
            </summary>
        </member>
        <member name="M:TED.Interpreter.Pattern`3.Write(System.ValueTuple{`0,`1,`2}@)">
            <summary>
            Write the values from the pattern out to a row in a table after a successful match
            </summary>
        </member>
        <member name="P:TED.Interpreter.Pattern`3.Value">
            <summary>
            The value the pattern was successfully matched to
            </summary>
        </member>
        <member name="M:TED.Interpreter.Pattern`3.Match(System.ValueTuple{`0,`1,`2}@)">
            <summary>
            Attempt to match this pattern to a row, storing the relevant values into
            any Cells contained in the pattern, when those arguments are in write mode.
            </summary>
        </member>
        <member name="P:TED.Interpreter.Pattern`3.IsInstantiated">
            <summary>
            True if all arguments in the pattern are instantiated.
            </summary>
        </member>
        <member name="M:TED.Interpreter.Pattern`3.IsReadModeAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.Pattern`3.ArgumentCell(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.Pattern`3.ToString">
            <inheritdoc />
        </member>
        <member name="P:TED.Interpreter.Pattern`3.Arguments">
            <inheritdoc />
        </member>
        <member name="T:TED.Interpreter.Pattern`4">
            <summary>
            Describes how to match or write the value of the arguments in a Goal
            Compiled from the arguments to a Goal object
            </summary>
            <typeparam name="T1">Type of the goal's first argument</typeparam>
            <typeparam name="T2">Type of the goal's second argument</typeparam>
            <typeparam name="T3">Type of the goal's third argument</typeparam>
            <typeparam name="T4">Type of the goal's fourth argument</typeparam>
        </member>
        <member name="F:TED.Interpreter.Pattern`4.Arg1">
            <summary>
            First argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.Pattern`4.Arg2">
            <summary>
            Second argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.Pattern`4.Arg3">
            <summary>
            Third argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.Pattern`4.Arg4">
            <summary>
            Fourth argument
            </summary>
        </member>
        <member name="M:TED.Interpreter.Pattern`4.#ctor(TED.Interpreter.MatchOperation{`0},TED.Interpreter.MatchOperation{`1},TED.Interpreter.MatchOperation{`2},TED.Interpreter.MatchOperation{`3})">
            <summary>
            Make a pattern with the specified arguments
            </summary>
        </member>
        <member name="M:TED.Interpreter.Pattern`4.Write(System.ValueTuple{`0,`1,`2,`3}@)">
            <summary>
            Write the values from the pattern out to a row in a table after a successful match
            </summary>
        </member>
        <member name="P:TED.Interpreter.Pattern`4.Value">
            <summary>
            The value the pattern was successfully matched to
            </summary>
        </member>
        <member name="M:TED.Interpreter.Pattern`4.Match(System.ValueTuple{`0,`1,`2,`3}@)">
            <summary>
            Attempt to match this pattern to a row, storing the relevant values into
            any Cells contained in the pattern, when those arguments are in write mode.
            </summary>
        </member>
        <member name="P:TED.Interpreter.Pattern`4.IsInstantiated">
            <summary>
            True if all arguments in the pattern are instantiated.
            </summary>
        </member>
        <member name="M:TED.Interpreter.Pattern`4.IsReadModeAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.Pattern`4.ArgumentCell(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.Pattern`4.ToString">
            <inheritdoc />
        </member>
        <member name="P:TED.Interpreter.Pattern`4.Arguments">
            <inheritdoc />
        </member>
        <member name="T:TED.Interpreter.Pattern`5">
            <summary>
            Describes how to match or write the value of the arguments in a Goal
            Compiled from the arguments to a Goal object
            </summary>
            <typeparam name="T1">Type of the goal's first argument</typeparam>
            <typeparam name="T2">Type of the goal's second argument</typeparam>
            <typeparam name="T3">Type of the goal's third argument</typeparam>
            <typeparam name="T4">Type of the goal's fourth argument</typeparam>
            <typeparam name="T5">Type of the goal's fifth argument</typeparam>
        </member>
        <member name="F:TED.Interpreter.Pattern`5.Arg1">
            <summary>
            First argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.Pattern`5.Arg2">
            <summary>
            Second argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.Pattern`5.Arg3">
            <summary>
            Third argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.Pattern`5.Arg4">
            <summary>
            Fourth argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.Pattern`5.Arg5">
            <summary>
            Fifth argument
            </summary>
        </member>
        <member name="M:TED.Interpreter.Pattern`5.#ctor(TED.Interpreter.MatchOperation{`0},TED.Interpreter.MatchOperation{`1},TED.Interpreter.MatchOperation{`2},TED.Interpreter.MatchOperation{`3},TED.Interpreter.MatchOperation{`4})">
            <summary>
            Make a pattern with the specified arguments
            </summary>
        </member>
        <member name="M:TED.Interpreter.Pattern`5.Write(System.ValueTuple{`0,`1,`2,`3,`4}@)">
            <summary>
            Write the values from the pattern out to a row in a table after a successful match
            </summary>
        </member>
        <member name="P:TED.Interpreter.Pattern`5.Value">
            <summary>
            The value the pattern was successfully matched to
            </summary>
        </member>
        <member name="M:TED.Interpreter.Pattern`5.Match(System.ValueTuple{`0,`1,`2,`3,`4}@)">
            <summary>
            Attempt to match this pattern to a row, storing the relevant values into
            any Cells contained in the pattern, when those arguments are in write mode.
            </summary>
        </member>
        <member name="P:TED.Interpreter.Pattern`5.IsInstantiated">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.Pattern`5.IsReadModeAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.Pattern`5.ArgumentCell(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.Pattern`5.ToString">
            <inheritdoc />
        </member>
        <member name="P:TED.Interpreter.Pattern`5.Arguments">
            <inheritdoc />
        </member>
        <member name="T:TED.Interpreter.Pattern`6">
            <summary>
            Describes how to match or write the value of the arguments in a Goal
            Compiled from the arguments to a Goal object
            </summary>
            <typeparam name="T1">Type of the goal's first argument</typeparam>
            <typeparam name="T2">Type of the goal's second argument</typeparam>
            <typeparam name="T3">Type of the goal's third argument</typeparam>
            <typeparam name="T4">Type of the goal's fourth argument</typeparam>
            <typeparam name="T5">Type of the goal's fifth argument</typeparam>
            <typeparam name="T6">Type of the goal's sixth argument</typeparam>
        </member>
        <member name="F:TED.Interpreter.Pattern`6.Arg1">
            <summary>
            First argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.Pattern`6.Arg2">
            <summary>
            Second argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.Pattern`6.Arg3">
            <summary>
            Third argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.Pattern`6.Arg4">
            <summary>
            Fourth argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.Pattern`6.Arg5">
            <summary>
            Fifth argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.Pattern`6.Arg6">
            <summary>
            Sixth argument
            </summary>
        </member>
        <member name="M:TED.Interpreter.Pattern`6.#ctor(TED.Interpreter.MatchOperation{`0},TED.Interpreter.MatchOperation{`1},TED.Interpreter.MatchOperation{`2},TED.Interpreter.MatchOperation{`3},TED.Interpreter.MatchOperation{`4},TED.Interpreter.MatchOperation{`5})">
            <summary>
            Make a pattern with the specified arguments
            </summary>
        </member>
        <member name="M:TED.Interpreter.Pattern`6.Write(System.ValueTuple{`0,`1,`2,`3,`4,`5}@)">
            <summary>
            Write the values from the pattern out to a row in a table after a successful match
            </summary>
        </member>
        <member name="P:TED.Interpreter.Pattern`6.Value">
            <summary>
            The value the pattern was successfully matched to
            </summary>
        </member>
        <member name="M:TED.Interpreter.Pattern`6.Match(System.ValueTuple{`0,`1,`2,`3,`4,`5}@)">
            <summary>
            Attempt to match this pattern to a row, storing the relevant values into
            any Cells contained in the pattern, when those arguments are in write mode.
            </summary>
        </member>
        <member name="P:TED.Interpreter.Pattern`6.IsInstantiated">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.Pattern`6.IsReadModeAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.Pattern`6.ArgumentCell(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.Pattern`6.ToString">
            <inheritdoc />
        </member>
        <member name="P:TED.Interpreter.Pattern`6.Arguments">
            <inheritdoc />
        </member>
        <member name="T:TED.Interpreter.Pattern`7">
            <summary>
            Describes how to match or write the value of the arguments in a Goal
            Compiled from the arguments to a Goal object
            </summary>
            <typeparam name="T1">Type of the goal's first argument</typeparam>
            <typeparam name="T2">Type of the goal's second argument</typeparam>
            <typeparam name="T3">Type of the goal's third argument</typeparam>
            <typeparam name="T4">Type of the goal's fourth argument</typeparam>
            <typeparam name="T5">Type of the goal's fifth argument</typeparam>
            <typeparam name="T6">Type of the goal's sixth argument</typeparam>
            <typeparam name="T7">Type of the goal's seventh argument</typeparam>
        </member>
        <member name="F:TED.Interpreter.Pattern`7.Arg1">
            <summary>
            First argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.Pattern`7.Arg2">
            <summary>
            Second argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.Pattern`7.Arg3">
            <summary>
            Third argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.Pattern`7.Arg4">
            <summary>
            Fourth argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.Pattern`7.Arg5">
            <summary>
            Fifth argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.Pattern`7.Arg6">
            <summary>
            Sixth argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.Pattern`7.Arg7">
            <summary>
            Seventh argument
            </summary>
        </member>
        <member name="M:TED.Interpreter.Pattern`7.#ctor(TED.Interpreter.MatchOperation{`0},TED.Interpreter.MatchOperation{`1},TED.Interpreter.MatchOperation{`2},TED.Interpreter.MatchOperation{`3},TED.Interpreter.MatchOperation{`4},TED.Interpreter.MatchOperation{`5},TED.Interpreter.MatchOperation{`6})">
            <summary>
            Make a pattern with the specified arguments
            </summary>
        </member>
        <member name="M:TED.Interpreter.Pattern`7.Write(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6}@)">
            <summary>
            Write the values from the pattern out to a row in a table after a successful match
            </summary>
        </member>
        <member name="P:TED.Interpreter.Pattern`7.Value">
            <summary>
            The value the pattern was successfully matched to
            </summary>
        </member>
        <member name="M:TED.Interpreter.Pattern`7.Match(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6}@)">
            <summary>
            Attempt to match this pattern to a row, storing the relevant values into
            any Cells contained in the pattern, when those arguments are in write mode.
            </summary>
        </member>
        <member name="P:TED.Interpreter.Pattern`7.IsInstantiated">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.Pattern`7.IsReadModeAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.Pattern`7.ArgumentCell(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.Pattern`7.ToString">
            <inheritdoc />
        </member>
        <member name="P:TED.Interpreter.Pattern`7.Arguments">
            <inheritdoc />
        </member>
        <member name="T:TED.Interpreter.Pattern`8">
            <summary>
            Describes how to match or write the value of the arguments in a Goal
            Compiled from the arguments to a Goal object
            </summary>
            <typeparam name="T1">Type of the goal's first argument</typeparam>
            <typeparam name="T2">Type of the goal's second argument</typeparam>
            <typeparam name="T3">Type of the goal's third argument</typeparam>
            <typeparam name="T4">Type of the goal's fourth argument</typeparam>
            <typeparam name="T5">Type of the goal's fifth argument</typeparam>
            <typeparam name="T6">Type of the goal's sixth argument</typeparam>
            <typeparam name="T7">Type of the goal's seventh argument</typeparam>
            <typeparam name="T8">Type of the goal's either argument</typeparam>
        </member>
        <member name="F:TED.Interpreter.Pattern`8.Arg1">
            <summary>
            First argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.Pattern`8.Arg2">
            <summary>
            Second argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.Pattern`8.Arg3">
            <summary>
            Third argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.Pattern`8.Arg4">
            <summary>
            Fourth argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.Pattern`8.Arg5">
            <summary>
            Fifth argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.Pattern`8.Arg6">
            <summary>
            Sixth argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.Pattern`8.Arg7">
            <summary>
            Seventh argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.Pattern`8.Arg8">
            <summary>
            Eighth argument
            </summary>
        </member>
        <member name="M:TED.Interpreter.Pattern`8.#ctor(TED.Interpreter.MatchOperation{`0},TED.Interpreter.MatchOperation{`1},TED.Interpreter.MatchOperation{`2},TED.Interpreter.MatchOperation{`3},TED.Interpreter.MatchOperation{`4},TED.Interpreter.MatchOperation{`5},TED.Interpreter.MatchOperation{`6},TED.Interpreter.MatchOperation{`7})">
            <summary>
            Make a pattern with the specified arguments
            </summary>
        </member>
        <member name="M:TED.Interpreter.Pattern`8.Write(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6,System.ValueTuple{`7}}@)">
            <summary>
            Write the values from the pattern out to a row in a table after a successful match
            </summary>
        </member>
        <member name="P:TED.Interpreter.Pattern`8.Value">
            <summary>
            The value the pattern was successfully matched to
            </summary>
        </member>
        <member name="M:TED.Interpreter.Pattern`8.Match(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6,System.ValueTuple{`7}}@)">
            <summary>
            Attempt to match this pattern to a row, storing the relevant values into
            any Cells contained in the pattern, when those arguments are in write mode.
            </summary>
        </member>
        <member name="P:TED.Interpreter.Pattern`8.IsInstantiated">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.Pattern`8.IsReadModeAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.Pattern`8.ArgumentCell(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.Pattern`8.ToString">
            <inheritdoc />
        </member>
        <member name="P:TED.Interpreter.Pattern`8.Arguments">
            <inheritdoc />
        </member>
        <member name="T:TED.Interpreter.Rule">
            <summary>
            Untyped base class of all Rules
            Rule objects are the preprocessed form of rules specified using .If or .Fact.
            They consist of the Pattern for the head of the rule and an array of call objects
            for each of the subgoals in the body
            </summary>
        </member>
        <member name="F:TED.Interpreter.Rule.Predicate">
            <summary>
            Predicate this rule applies to.
            Rules can only be applied to TablePredicates, not primitives or definitions
            </summary>
        </member>
        <member name="P:TED.Interpreter.Rule.Head">
            <summary>
            Pattern object for the head of the rule.
            The head of a rule is its "conclusion" - the thing that has to be true when the body is true.
            </summary>
        </member>
        <member name="F:TED.Interpreter.Rule.Body">
            <summary>
            Body of the rule - a sequence of Call objects for each goal in the If.
            </summary>
        </member>
        <member name="F:TED.Interpreter.Rule.Dependencies">
            <summary>
            All the TablePredicates called directly by this rule.
            These tables must be computed before this rule runs.
            </summary>
        </member>
        <member name="F:TED.Interpreter.Rule.ValueCells">
            <summary>
            Cells holding the values of the variables in the rule.
            </summary>
        </member>
        <member name="P:TED.Interpreter.Rule.IsPure">
            <summary>
            True if the rule only calls pure predicates.
            </summary>
        </member>
        <member name="P:TED.Interpreter.Rule.TotalExecutionTime">
            <summary>
            Total execution time spent in this rule.
            </summary>
        </member>
        <member name="F:TED.Interpreter.Rule.InstantaneousExecutionTime">
            <summary>
            Execution time for the most recent execution of this rule.
            </summary>
        </member>
        <member name="F:TED.Interpreter.Rule.AverageExecutionTime">
            <summary>
            Average number of milliseconds required to run this rule
            </summary>
        </member>
        <member name="M:TED.Interpreter.Rule.WriteHead">
            <summary>
            Called after the body has computed a row and written the values of variables into it.
            Writes the values of each element of the row into the table.
            </summary>
        </member>
        <member name="M:TED.Interpreter.Rule.AddAllSolutions">
            <summary>
            Repeatedly runs all the calls in the body and backtracks them to completion
            Calls WriteHead each time a solution is found to write it into the table.
            </summary>
        </member>
        <member name="M:TED.Interpreter.Rule.ToString">
            <inheritdoc />
        </member>
        <member name="T:TED.Interpreter.Rule`1">
            <summary>
            Represents the final, "compiled" representation of a rule.
            </summary>
            <typeparam name="T1">Type of the argument to the rule's head (conclusion)</typeparam>
        </member>
        <member name="T:TED.Interpreter.Rule`2">
            <summary>
            Represents the final, "compiled" representation of a rule.
            </summary>
            <typeparam name="T1">Type of the first argument to the rule's head (conclusion)</typeparam>
            <typeparam name="T2">Type of the second argument to the rule's head</typeparam>
        </member>
        <member name="T:TED.Interpreter.Rule`3">
            <summary>
            Represents the final, "compiled" representation of a rule.
            </summary>
            <typeparam name="T1">Type of the first argument to the rule's head (conclusion)</typeparam>
            <typeparam name="T2">Type of the second argument to the rule's head</typeparam>
            <typeparam name="T3">Type of the third argument to the rule's head</typeparam>
        </member>
        <member name="T:TED.Interpreter.Rule`4">
            <summary>
            Represents the final, "compiled" representation of a rule.
            </summary>
            <typeparam name="T1">Type of the first argument to the rule's head (conclusion)</typeparam>
            <typeparam name="T2">Type of the second argument to the rule's head</typeparam>
            <typeparam name="T3">Type of the third argument to the rule's head</typeparam>
            <typeparam name="T4">Type of the fourth argument to the rule's head</typeparam>
        </member>
        <member name="T:TED.Interpreter.Rule`5">
            <summary>
            Represents the final, "compiled" representation of a rule.
            </summary>
            <typeparam name="T1">Type of the first argument to the rule's head (conclusion)</typeparam>
            <typeparam name="T2">Type of the second argument to the rule's head</typeparam>
            <typeparam name="T3">Type of the third argument to the rule's head</typeparam>
            <typeparam name="T4">Type of the fourth argument to the rule's head</typeparam>
            <typeparam name="T5">Type of the fifth argument to the rule's head</typeparam>
        </member>
        <member name="T:TED.Interpreter.Rule`6">
            <summary>
            Represents the final, "compiled" representation of a rule.
            </summary>
            <typeparam name="T1">Type of the first argument to the rule's head (conclusion)</typeparam>
            <typeparam name="T2">Type of the second argument to the rule's head</typeparam>
            <typeparam name="T3">Type of the third argument to the rule's head</typeparam>
            <typeparam name="T4">Type of the fourth argument to the rule's head</typeparam>
            <typeparam name="T5">Type of the fifth argument to the rule's head</typeparam>
            <typeparam name="T6">Type of the sixth argument to the rule's head</typeparam>
        </member>
        <member name="T:TED.Interpreter.Rule`7">
            <summary>
            Represents the final, "compiled" representation of a rule.
            </summary>
            <typeparam name="T1">Type of the first argument to the rule's head (conclusion)</typeparam>
            <typeparam name="T2">Type of the second argument to the rule's head</typeparam>
            <typeparam name="T3">Type of the third argument to the rule's head</typeparam>
            <typeparam name="T4">Type of the fourth argument to the rule's head</typeparam>
            <typeparam name="T5">Type of the fifth argument to the rule's head</typeparam>
            <typeparam name="T6">Type of the sixth argument to the rule's head</typeparam>
            <typeparam name="T7">Type of the seventh argument to the rule's head</typeparam>
        </member>
        <member name="T:TED.Interpreter.Rule`8">
            <summary>
            Represents the final, "compiled" representation of a rule.
            </summary>
            <typeparam name="T1">Type of the first argument to the rule's head (conclusion)</typeparam>
            <typeparam name="T2">Type of the second argument to the rule's head</typeparam>
            <typeparam name="T3">Type of the third argument to the rule's head</typeparam>
            <typeparam name="T4">Type of the fourth argument to the rule's head</typeparam>
            <typeparam name="T5">Type of the fifth argument to the rule's head</typeparam>
            <typeparam name="T6">Type of the sixth argument to the rule's head</typeparam>
            <typeparam name="T7">Type of the seventh argument to the rule's head</typeparam>
            <typeparam name="T8">Type of the eighth argument to the rule's head</typeparam>
        </member>
        <member name="T:TED.Interpreter.SingleRowTableCall">
            <summary>
            Untyped base class for calls to TablePredicates whose arguments are satisfiable by at most one row,
            so they don't require enumerating rows
            </summary>
        </member>
        <member name="F:TED.Interpreter.SingleRowTableCall.Primed">
            <summary>
            What row we will text next in the table
            </summary>
        </member>
        <member name="M:TED.Interpreter.SingleRowTableCall.Reset">
            <summary>
            Move back to the beginning of the table.
            </summary>
        </member>
        <member name="T:TED.Interpreter.TableCallExhaustive">
            <summary>
            The iterator that handles calls to a TablePredicate that cannot be accelerated using a hash table
            (index or RowSet).  This will test every row of the table against the call pattern.  This can be avoided
            under the right circumstances by adding an index and/or setting the Unique property of the TablePredicate.
            </summary>
        </member>
        <member name="F:TED.Interpreter.TableCallExhaustive.RowIndex">
            <summary>
            What row we will text next in the table
            </summary>
        </member>
        <member name="M:TED.Interpreter.TableCallExhaustive.Reset">
            <summary>
            Move back to the beginning of the table.
            </summary>
        </member>
        <member name="M:TED.Interpreter.TableCallExhaustive.Compile(TED.Compiler.Compiler,TED.Compiler.Continuation,System.String)">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.TableCallUsingRowSet.Compile(TED.Compiler.Compiler,TED.Compiler.Continuation,System.String)">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.TableCallWithDoubleGeneralIndex.Compile(TED.Compiler.Compiler,TED.Compiler.Continuation,System.String)">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.TableCallWithDoubleKey.Compile(TED.Compiler.Compiler,TED.Compiler.Continuation,System.String)">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.TableCallWithGeneralIndex.Compile(TED.Compiler.Compiler,TED.Compiler.Continuation,System.String)">
            <inheritdoc />
        </member>
        <member name="M:TED.Interpreter.TableCallWithKey.Compile(TED.Compiler.Compiler,TED.Compiler.Continuation,System.String)">
            <inheritdoc />
        </member>
        <member name="T:TED.Interpreter.TableGoal">
            <summary>
            A TableGoal represents a table predicate applied to arguments, e.g. p["a"], p[variable], etc.
            Untyped base class for all goals involving TablePredicates
            </summary>
        </member>
        <member name="F:TED.Interpreter.TableGoal.TablePredicate">
            <summary>
            Predicate being called
            </summary>
        </member>
        <member name="M:TED.Interpreter.TableGoal.#ctor(TED.TablePredicate,TED.Term[])">
            <summary>
            Make a new goal object
            </summary>
        </member>
        <member name="M:TED.Interpreter.TableGoal.If(TED.Interpreter.Goal[])">
            <summary>
            Add a rule for inferring this predicate from other predicates
            You cannot add rules to a table you add rows to using AddRow.
            </summary>
        </member>
        <member name="M:TED.Interpreter.TableGoal.Where(TED.Interpreter.Goal[])">
            <summary>
            Synonym for If().  This reads better on Table.Initially.Where(...) declarations
            than .If(...)
            </summary>
            <param name="subgoals"></param>
        </member>
        <member name="M:TED.Interpreter.TableGoal.Fact">
            <summary>
            Add a "fact" (rule with no subgoals) to the predicate
            IMPORTANT: this is different from adding the data directly using AddRow!
            A TablePredicate can either either rules (including facts) or you can add data manually
            using AddRow, but not both.
            </summary>
        </member>
        <member name="P:TED.Interpreter.TableGoal.Predicate">
            <inheritdoc />
        </member>
        <member name="T:TED.Interpreter.TableGoal`1">
            <summary>
            Abstract syntax tree representing a call to a 1-argument TablePredicate
            </summary>
            <typeparam name="T1">Type of predicate argument</typeparam>
        </member>
        <member name="M:TED.Interpreter.TableGoal`1.#ctor(TED.TablePredicate,TED.Term{`0})">
            <inheritdoc />
        </member>
        <member name="F:TED.Interpreter.TableGoal`1.Arg1">
            <summary>
            First (and only) argument in the call.
            </summary>
        </member>
        <member name="M:TED.Interpreter.TableGoal`1.MakePattern(TED.Preprocessing.GoalAnalyzer)">
            <summary>
            Generate a Pattern for matching the goal's argument list.
            </summary>
            <param name="tc">GoalScanner to use for read/write analysis</param>
        </member>
        <member name="M:TED.Interpreter.TableGoal`1.MakeCall(TED.Preprocessing.GoalAnalyzer)">
            <summary>
            Make a TableCall for this TableGoal
            </summary>
            <param name="ga">GoalAnalyzer to track the read/write states of argument</param>
            <returns></returns>
        </member>
        <member name="M:TED.Interpreter.TableGoal`1.If(TED.Interpreter.Goal[])">
            <summary>
            Add a rule for inferring this predicate from other predicates
            You cannot add rules to a table you add rows to using AddRow.
            </summary>
        </member>
        <member name="T:TED.Interpreter.TableGoal`2">
            <summary>
            Abstract syntax tree representing a call to a 2-argument TablePredicate
            </summary>
            <typeparam name="T1">Type of predicate's first argument</typeparam>
            <typeparam name="T2">Type of predicate's second argument</typeparam>
        </member>
        <member name="M:TED.Interpreter.TableGoal`2.#ctor(TED.TablePredicate,TED.Term{`0},TED.Term{`1})">
            <inheritdoc />
        </member>
        <member name="F:TED.Interpreter.TableGoal`2.Arg1">
            <summary>
            First argument to the call
            </summary>
        </member>
        <member name="F:TED.Interpreter.TableGoal`2.Arg2">
            <summary>
            Second argument to the call
            </summary>
        </member>
        <member name="M:TED.Interpreter.TableGoal`2.MakePattern(TED.Preprocessing.GoalAnalyzer)">
            <summary>
            Generate a Pattern for matching the goal's argument list.
            </summary>
            <param name="tc">GoalScanner to use for read/write analysis</param>
        </member>
        <member name="M:TED.Interpreter.TableGoal`2.MakeCall(TED.Preprocessing.GoalAnalyzer)">
            <summary>
            Make a TableCall for this TableGoal
            </summary>
            <param name="ga">GoalAnalyzer to track the read/write states of argument</param>
            <returns></returns>
        </member>
        <member name="M:TED.Interpreter.TableGoal`2.If(TED.Interpreter.Goal[])">
            <summary>
            Add a rule for inferring this predicate from other predicates
            You cannot add rules to a table you add rows to using AddRow.
            </summary>
        </member>
        <member name="T:TED.Interpreter.TableGoal`3">
            <summary>
            Abstract syntax tree representing a call to a 3-argument TablePredicate
            </summary>
            <typeparam name="T1">Type of predicate's first argument</typeparam>
            <typeparam name="T2">Type of predicate's second argument</typeparam>
            <typeparam name="T3">Type of predicate's third argument</typeparam>
        </member>
        <member name="M:TED.Interpreter.TableGoal`3.#ctor(TED.TablePredicate,TED.Term{`0},TED.Term{`1},TED.Term{`2})">
            <inheritdoc />
        </member>
        <member name="F:TED.Interpreter.TableGoal`3.Arg1">
            <summary>
            First call argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.TableGoal`3.Arg2">
            <summary>
            Second call argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.TableGoal`3.Arg3">
            <summary>
            Third call argument
            </summary>
        </member>
        <member name="M:TED.Interpreter.TableGoal`3.MakePattern(TED.Preprocessing.GoalAnalyzer)">
            <summary>
            Generate a Pattern for matching the goal's argument list.
            </summary>
            <param name="tc">GoalScanner to use for read/write analysis</param>
        </member>
        <member name="M:TED.Interpreter.TableGoal`3.MakeCall(TED.Preprocessing.GoalAnalyzer)">
            <summary>
            Make a TableCall for this TableGoal
            </summary>
            <param name="ga">GoalAnalyzer to track the read/write states of argument</param>
            <returns></returns>
        </member>
        <member name="M:TED.Interpreter.TableGoal`3.If(TED.Interpreter.Goal[])">
            <summary>
            Add a rule for inferring this predicate from other predicates
            You cannot add rules to a table you add rows to using AddRow.
            </summary>
        </member>
        <member name="T:TED.Interpreter.TableGoal`4">
            <summary>
            Abstract syntax tree representing a call to a 4-argument TablePredicate
            </summary>
            <typeparam name="T1">Type of predicate's first argument</typeparam>
            <typeparam name="T2">Type of predicate's second argument</typeparam>
            <typeparam name="T3">Type of predicate's third argument</typeparam>
            <typeparam name="T4">Type of predicate's fourth argument</typeparam>
        </member>
        <member name="M:TED.Interpreter.TableGoal`4.#ctor(TED.TablePredicate,TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3})">
            <inheritdoc />
        </member>
        <member name="F:TED.Interpreter.TableGoal`4.Arg1">
            <summary>
            First call argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.TableGoal`4.Arg2">
            <summary>
            Second call argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.TableGoal`4.Arg3">
            <summary>
            Third call argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.TableGoal`4.Arg4">
            <summary>
            Fourth call argument
            </summary>
        </member>
        <member name="M:TED.Interpreter.TableGoal`4.MakePattern(TED.Preprocessing.GoalAnalyzer)">
            <summary>
            Generate a Pattern for matching the goal's argument list.
            </summary>
            <param name="tc">GoalScanner to use for read/write analysis</param>
        </member>
        <member name="M:TED.Interpreter.TableGoal`4.MakeCall(TED.Preprocessing.GoalAnalyzer)">
            <summary>
            Make a TableCall for this TableGoal
            </summary>
            <param name="ga">GoalAnalyzer to track the read/write states of argument</param>
            <returns></returns>
        </member>
        <member name="M:TED.Interpreter.TableGoal`4.If(TED.Interpreter.Goal[])">
            <summary>
            Add a rule for inferring this predicate from other predicates
            You cannot add rules to a table you add rows to using AddRow.
            </summary>
        </member>
        <member name="T:TED.Interpreter.TableGoal`5">
            <summary>
            Abstract syntax tree representing a call to a 5-argument TablePredicate
            </summary>
            <typeparam name="T1">Type of predicate's first argument</typeparam>
            <typeparam name="T2">Type of predicate's second argument</typeparam>
            <typeparam name="T3">Type of predicate's third argument</typeparam>
            <typeparam name="T4">Type of predicate's fourth argument</typeparam>
            <typeparam name="T5">Type of predicate's fifth argument</typeparam>
        </member>
        <member name="M:TED.Interpreter.TableGoal`5.#ctor(TED.TablePredicate,TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3},TED.Term{`4})">
            <inheritdoc />
        </member>
        <member name="F:TED.Interpreter.TableGoal`5.Arg1">
            <summary>
            First call argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.TableGoal`5.Arg2">
            <summary>
            Second call argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.TableGoal`5.Arg3">
            <summary>
            Third call argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.TableGoal`5.Arg4">
            <summary>
            Fourth call argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.TableGoal`5.Arg5">
            <summary>
            Fifth call argument
            </summary>
        </member>
        <member name="M:TED.Interpreter.TableGoal`5.MakePattern(TED.Preprocessing.GoalAnalyzer)">
            <summary>
            Generate a Pattern for matching the goal's argument list.
            </summary>
            <param name="tc">GoalScanner to use for read/write analysis</param>
        </member>
        <member name="M:TED.Interpreter.TableGoal`5.MakeCall(TED.Preprocessing.GoalAnalyzer)">
            <summary>
            Make a TableCall for this TableGoal
            </summary>
            <param name="ga">GoalAnalyzer to track the read/write states of argument</param>
            <returns></returns>
        </member>
        <member name="M:TED.Interpreter.TableGoal`5.If(TED.Interpreter.Goal[])">
            <summary>
            Add a rule for inferring this predicate from other predicates
            You cannot add rules to a table you add rows to using AddRow.
            </summary>
        </member>
        <member name="T:TED.Interpreter.TableGoal`6">
            <summary>
            Abstract syntax tree representing a call to a 6-argument TablePredicate
            </summary>
            <typeparam name="T1">Type of predicate's first argument</typeparam>
            <typeparam name="T2">Type of predicate's second argument</typeparam>
            <typeparam name="T3">Type of predicate's third argument</typeparam>
            <typeparam name="T4">Type of predicate's fourth argument</typeparam>
            <typeparam name="T5">Type of predicate's fifth argument</typeparam>
            <typeparam name="T6">Type of predicate's sixth argument</typeparam>
        </member>
        <member name="M:TED.Interpreter.TableGoal`6.#ctor(TED.TablePredicate,TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3},TED.Term{`4},TED.Term{`5})">
            <inheritdoc />
        </member>
        <member name="F:TED.Interpreter.TableGoal`6.Arg1">
            <summary>
            First call argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.TableGoal`6.Arg2">
            <summary>
            Second call argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.TableGoal`6.Arg3">
            <summary>
            Third call argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.TableGoal`6.Arg4">
            <summary>
            Fourth call argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.TableGoal`6.Arg5">
            <summary>
            Fifth call argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.TableGoal`6.Arg6">
            <summary>
            Sixth call argument
            </summary>
        </member>
        <member name="M:TED.Interpreter.TableGoal`6.MakePattern(TED.Preprocessing.GoalAnalyzer)">
            <summary>
            Generate a Pattern for matching the goal's argument list.
            </summary>
            <param name="tc">GoalScanner to use for read/write analysis</param>
        </member>
        <member name="M:TED.Interpreter.TableGoal`6.MakeCall(TED.Preprocessing.GoalAnalyzer)">
            <summary>
            Make a TableCall for this TableGoal
            </summary>
            <param name="ga">GoalAnalyzer to track the read/write states of argument</param>
            <returns></returns>
        </member>
        <member name="M:TED.Interpreter.TableGoal`6.If(TED.Interpreter.Goal[])">
            <summary>
            Add a rule for inferring this predicate from other predicates
            You cannot add rules to a table you add rows to using AddRow.
            </summary>
        </member>
        <member name="T:TED.Interpreter.TableGoal`7">
            <summary>
            Abstract syntax tree representing a call to a 7-argument TablePredicate
            </summary>
            <typeparam name="T1">Type of predicate's first argument</typeparam>
            <typeparam name="T2">Type of predicate's second argument</typeparam>
            <typeparam name="T3">Type of predicate's third argument</typeparam>
            <typeparam name="T4">Type of predicate's fourth argument</typeparam>
            <typeparam name="T5">Type of predicate's fifth argument</typeparam>
            <typeparam name="T6">Type of predicate's sixth argument</typeparam>
            <typeparam name="T7">Type of predicate's seventh argument</typeparam>
        </member>
        <member name="M:TED.Interpreter.TableGoal`7.#ctor(TED.TablePredicate,TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3},TED.Term{`4},TED.Term{`5},TED.Term{`6})">
            <inheritdoc />
        </member>
        <member name="F:TED.Interpreter.TableGoal`7.Arg1">
            <summary>
            First call argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.TableGoal`7.Arg2">
            <summary>
            Second call argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.TableGoal`7.Arg3">
            <summary>
            Third call argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.TableGoal`7.Arg4">
            <summary>
            Fourth call argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.TableGoal`7.Arg5">
            <summary>
            Fifth call argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.TableGoal`7.Arg6">
            <summary>
            Sixth call argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.TableGoal`7.Arg7">
            <summary>
            Seventh call argument
            </summary>
        </member>
        <member name="M:TED.Interpreter.TableGoal`7.MakePattern(TED.Preprocessing.GoalAnalyzer)">
            <summary>
            Generate a Pattern for matching the goal's argument list.
            </summary>
            <param name="tc">GoalScanner to use for read/write analysis</param>
        </member>
        <member name="M:TED.Interpreter.TableGoal`7.MakeCall(TED.Preprocessing.GoalAnalyzer)">
            <summary>
            Make a TableCall for this TableGoal
            </summary>
            <param name="ga">GoalAnalyzer to track the read/write states of argument</param>
            <returns></returns>
        </member>
        <member name="M:TED.Interpreter.TableGoal`7.If(TED.Interpreter.Goal[])">
            <summary>
            Add a rule for inferring this predicate from other predicates
            You cannot add rules to a table you add rows to using AddRow.
            </summary>
        </member>
        <member name="T:TED.Interpreter.TableGoal`8">
            <summary>
            Abstract syntax tree representing a call to a 8-argument TablePredicate
            </summary>
            <typeparam name="T1">Type of predicate's first argument</typeparam>
            <typeparam name="T2">Type of predicate's second argument</typeparam>
            <typeparam name="T3">Type of predicate's third argument</typeparam>
            <typeparam name="T4">Type of predicate's fourth argument</typeparam>
            <typeparam name="T5">Type of predicate's fifth argument</typeparam>
            <typeparam name="T6">Type of predicate's sixth argument</typeparam>
            <typeparam name="T7">Type of predicate's seventh argument</typeparam>
            <typeparam name="T8">Type of predicate's eighth argument</typeparam>
        </member>
        <member name="M:TED.Interpreter.TableGoal`8.#ctor(TED.TablePredicate,TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3},TED.Term{`4},TED.Term{`5},TED.Term{`6},TED.Term{`7})">
            <inheritdoc />
        </member>
        <member name="F:TED.Interpreter.TableGoal`8.Arg1">
            <summary>
            First call argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.TableGoal`8.Arg2">
            <summary>
            Second call argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.TableGoal`8.Arg3">
            <summary>
            Third call argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.TableGoal`8.Arg4">
            <summary>
            Fourth call argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.TableGoal`8.Arg5">
            <summary>
            Fifth call argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.TableGoal`8.Arg6">
            <summary>
            Sixth call argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.TableGoal`8.Arg7">
            <summary>
            Seventh call argument
            </summary>
        </member>
        <member name="F:TED.Interpreter.TableGoal`8.Arg8">
            <summary>
            Seventh call argument
            </summary>
        </member>
        <member name="M:TED.Interpreter.TableGoal`8.MakePattern(TED.Preprocessing.GoalAnalyzer)">
            <summary>
            Generate a Pattern for matching the goal's argument list.
            </summary>
            <param name="tc">GoalScanner to use for read/write analysis</param>
        </member>
        <member name="M:TED.Interpreter.TableGoal`8.MakeCall(TED.Preprocessing.GoalAnalyzer)">
            <summary>
            Make a TableCall for this TableGoal
            </summary>
            <param name="ga">GoalAnalyzer to track the read/write states of argument</param>
            <returns></returns>
        </member>
        <member name="M:TED.Interpreter.TableGoal`8.If(TED.Interpreter.Goal[])">
            <summary>
            Add a rule for inferring this predicate from other predicates
            You cannot add rules to a table you add rows to using AddRow.
            </summary>
        </member>
        <member name="T:TED.Interpreter.UpdateMode">
            <summary>
            The different types of tables that get updated in different ways
            </summary>
        </member>
        <member name="F:TED.Interpreter.UpdateMode.BaseTable">
            <summary>
            This table is extensional and either not updated, or updated via .Accumulates, .Add, .Set, etc.
            </summary>
        </member>
        <member name="F:TED.Interpreter.UpdateMode.Rules">
            <summary>
            This is an intensional table defined by rules
            </summary>
        </member>
        <member name="F:TED.Interpreter.UpdateMode.Operator">
            <summary>
            This is an intensional table that is the output of an operator.
            </summary>
        </member>
        <member name="T:TED.Interpreter.ValueCell">
            <summary>
            Run-time representation of a variable or a constant
            A typed object whose only purpose is to hold a value.  For constants, the values is
            pre-stored in the cell. For variables, it's stored during write-mode matching.
            </summary>
        </member>
        <member name="F:TED.Interpreter.ValueCell.ConstantName">
            <summary>
            Name to use for cells representing constants
            </summary>
        </member>
        <member name="F:TED.Interpreter.ValueCell.Variable">
            <summary>
            The variable this cell corresponds to
            </summary>
        </member>
        <member name="P:TED.Interpreter.ValueCell.Name">
            <summary>
            Name, for debugging purposes
            </summary>
        </member>
        <member name="P:TED.Interpreter.ValueCell.Type">
            <summary>
            Returns the type of data stored in the cell
            </summary>
        </member>
        <member name="M:TED.Interpreter.ValueCell.#ctor(TED.Interpreter.IVariable)">
            <summary>
            Make a cell with the specified v (v used only for debugging)
            </summary>
        </member>
        <member name="P:TED.Interpreter.ValueCell.IsVariable">
            <summary>
            Is this the value cell for a variable or for a constant?
            </summary>
        </member>
        <member name="P:TED.Interpreter.ValueCell.BoxedValue">
            <summary>
            Value stored in the cell, typed as object
            </summary>
        </member>
        <member name="P:TED.Interpreter.ValueCell.ReadExpression">
            <summary>
            Expression to use when reading from this in compiled code.  This will either be a variable name or, for a constant, a C# literal.
            </summary>
        </member>
        <member name="T:TED.Interpreter.ValueCell`1">
            <summary>
            A container for a run-time value manipulated by Calls in a Rule
            These are used to hold:
            - The run-time values of variables (Vars) within a Rule.
            - Constants
            These get read and written through MatchInstructions, which get run when a Pattern is Matched
            or written to a row in a table using its Write method.
            </summary>
            <typeparam name="T">Type of data to be stored in the cell</typeparam>
        </member>
        <member name="F:TED.Interpreter.ValueCell`1.Value">
            <summary>
            Data stored in the cell.
            </summary>
        </member>
        <member name="P:TED.Interpreter.ValueCell`1.BoxedValue">
            <inheritdoc />
        </member>
        <member name="P:TED.Interpreter.ValueCell`1.Type">
            <inheritdoc />
        </member>
        <member name="F:TED.Interpreter.ValueCell`1.Equal">
            <summary>
            Object used to test equality of two objects of type T
            We need this because C# generics don't allow you to use ==
            </summary>
        </member>
        <member name="F:TED.Interpreter.ValueCell`1.ConstantTable">
            <summary>
            Table of ValueCells used for different constants of type T
            </summary>
        </member>
        <member name="M:TED.Interpreter.ValueCell`1.MakeVariable(TED.Var{`0})">
            <summary>
            Make a ValueCell to hold the run-time value of a variable (a Var[T]).
            </summary>
        </member>
        <member name="M:TED.Interpreter.ValueCell`1.Constant(`0)">
            <summary>
            Return a ValueCell holding the specified constant
            There will only be one such cell per constant.
            </summary>
        </member>
        <member name="M:TED.Interpreter.ValueCell`1.Match(`0@)">
            <summary>
            Test of the cell holds the specified value
            </summary>
        </member>
        <member name="T:TED.InvalidProgramException">
            <summary>
            Exception indicating a TED program is somehow malformed.
            </summary>
        </member>
        <member name="M:TED.InvalidProgramException.#ctor(System.String)">
            <summary>
            Exception indicating a TED program is somehow malformed.
            </summary>
        </member>
        <member name="T:TED.Language">
            <summary>
            Static class containing all the standard primitive predicates, such as Not.
            </summary>
        </member>
        <member name="F:TED.Language.Once">
            <summary>
            True if argument is true, but blocks backtracking.
            </summary>
        </member>
        <member name="F:TED.Language.Not">
            <summary>
            True if its argument is false
            </summary>
        </member>
        <member name="F:TED.Language.And">
            <summary>
            True if all argument goals are also true
            </summary>
        </member>
        <member name="F:TED.Language.Or">
            <summary>
            True if any argument goals are true
            </summary>
        </member>
        <member name="F:TED.Language.FirstOf">
            <summary>
            True if any argument goals are true
            </summary>
        </member>
        <member name="F:TED.Language.False">
            <summary>
            Predicate that always fails
            </summary>
        </member>
        <member name="F:TED.Language.True">
            <summary>
            Predicate that always succeeds
            </summary>
        </member>
        <member name="M:TED.Language.Eval``1(TED.Var{``0},TED.FunctionalExpression{``0})">
            <summary>
            Matches or stores the value of the functional expression to the variable.
            </summary>
        </member>
        <member name="P:TED.Language.Prob">
            <summary>
            Prob(p) succeeds with a probability of p (p in the range [0,1])
            </summary>
        </member>
        <member name="M:TED.Language.BreakPoint``1(TED.Term{``0})">
            <summary>
            Breakpoint execution of a rule
            This drops the caller into the underlying C# debugger
            </summary>
        </member>
        <member name="M:TED.Language.RandomElement``1(TED.TablePredicate{``0},TED.Term{``0})">
            <summary>
            Matches output against a random row of the table.
            </summary>
        </member>
        <member name="M:TED.Language.RandomElement``2(TED.TablePredicate{``0,``1},TED.Term{System.ValueTuple{``0,``1}})">
            <inheritdoc cref="M:TED.Language.RandomElement``1(TED.TablePredicate{``0},TED.Term{``0})"/>
        </member>
        <member name="M:TED.Language.RandomElement``3(TED.TablePredicate{``0,``1,``2},TED.Term{System.ValueTuple{``0,``1,``2}})">
            <inheritdoc cref="M:TED.Language.RandomElement``1(TED.TablePredicate{``0},TED.Term{``0})"/>
        </member>
        <member name="M:TED.Language.RandomElement``4(TED.TablePredicate{``0,``1,``2,``3},TED.Term{System.ValueTuple{``0,``1,``2,``3}})">
            <inheritdoc cref="M:TED.Language.RandomElement``1(TED.TablePredicate{``0},TED.Term{``0})"/>
        </member>
        <member name="M:TED.Language.RandomElement``5(TED.TablePredicate{``0,``1,``2,``3,``4},TED.Term{System.ValueTuple{``0,``1,``2,``3,``4}})">
            <inheritdoc cref="M:TED.Language.RandomElement``1(TED.TablePredicate{``0},TED.Term{``0})"/>
        </member>
        <member name="M:TED.Language.RandomElement``6(TED.TablePredicate{``0,``1,``2,``3,``4,``5},TED.Term{System.ValueTuple{``0,``1,``2,``3,``4,``5}})">
            <inheritdoc cref="M:TED.Language.RandomElement``1(TED.TablePredicate{``0},TED.Term{``0})"/>
        </member>
        <member name="M:TED.Language.RandomElement``7(TED.TablePredicate{``0,``1,``2,``3,``4,``5,``6},TED.Term{System.ValueTuple{``0,``1,``2,``3,``4,``5,``6}})">
            <inheritdoc cref="M:TED.Language.RandomElement``1(TED.TablePredicate{``0},TED.Term{``0})"/>
        </member>
        <member name="M:TED.Language.RandomElement``8(TED.TablePredicate{``0,``1,``2,``3,``4,``5,``6,``7},TED.Term{System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7}}})">
            <inheritdoc cref="M:TED.Language.RandomElement``1(TED.TablePredicate{``0},TED.Term{``0})"/>
        </member>
        <member name="M:TED.Language.In``1(TED.Term{``0},TED.Term{System.Collections.Generic.ICollection{``0}})">
            <summary>
            True when element is an element of the collection
            </summary>
            <typeparam name="T">element/collection type</typeparam>
            <param name="element">Candidate element of the collection</param>
            <param name="collection">Collection to check</param>
        </member>
        <member name="M:TED.Language.PickRandomly``1(TED.Term{``0},``0[])">
            <summary>
            Matches output against a randomly chosen element of choices using a uniform distribution.
            </summary>
        </member>
        <member name="M:TED.Language.Count(TED.Interpreter.Goal)">
            <summary>
            The number of solutions to goal.
            </summary>
        </member>
        <member name="M:TED.Language.Aggregate``1(TED.Var{``0},TED.Interpreter.Goal,``0,System.Func{``0,``0,``0},System.Func{System.String,System.String,System.String})">
            <summary>
            Aggregates value of variable from all the solutions to goal.
            </summary>
            <param name="v">Variable that appears int he goal</param>
            <param name="g">Goal to find the solutions of</param>
            <param name="initialValue">Value to return if g has no solutions</param>
            <param name="aggregator">Function mapping the current total and a new value of the variable to a new total</param>
            <param name="compiler">Generates c# text for a new value of the accumulator from the text for the accumulator and the most recent result from the goal</param>
            <returns>The aggregate value</returns>
        </member>
        <member name="M:TED.Language.SumInt(TED.Var{System.Int32},TED.Interpreter.Goal)">
            <summary>
            Return the sum of the specified variable from every solution to the goal
            </summary>
        </member>
        <member name="M:TED.Language.SumFloat(TED.Var{System.Single},TED.Interpreter.Goal)">
            <summary>
            Return the sum of the specified variable from every solution to the goal
            </summary>
        </member>
        <member name="M:TED.Language.Maximal``2(TED.Var{``0},TED.Var{``1},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with maximal value of objective
            </summary>
            <typeparam name="TArg">Type of the arg variable</typeparam>
            <typeparam name="TUtility">Type of the utility variable</typeparam>
            <param name="arg">Variable from goal to report the value of for the maximal solution</param>
            <param name="objective">Variable to maximize across solutions to goal</param>
            <param name="goal">Goal to find the maximal solution of</param>
        </member>
        <member name="M:TED.Language.Maximal``1(TED.Var{``0},TED.Var{System.Single},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with maximal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Maximal``1(TED.Var{``0},TED.Var{System.Int64},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with maximal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Maximal``1(TED.Var{``0},TED.Var{System.UInt32},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with maximal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Maximal``1(TED.Var{``0},TED.Var{System.Int32},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with maximal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Maximal``1(TED.Var{``0},TED.Var{System.UInt16},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with maximal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Maximal``1(TED.Var{``0},TED.Var{System.Int16},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with maximal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Maximal``1(TED.Var{``0},TED.Var{System.Byte},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with maximal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Maximal``1(TED.Var{``0},TED.Var{System.SByte},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with maximal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Minimal``2(TED.Var{``0},TED.Var{``1},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with minimal value of objective
            </summary>
            <typeparam name="TArg">Type of the arg variable</typeparam>
            <typeparam name="TUtility">Type of the utility variable</typeparam>
            <param name="arg">Variable from goal to report the value of for the minimal solution</param>
            <param name="objective">Variable to minimize across solutions to goal</param>
            <param name="goal">Goal to find the minimal solution of</param>
        </member>
        <member name="M:TED.Language.Minimal``1(TED.Var{``0},TED.Var{System.Single},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with minimal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Minimal``1(TED.Var{``0},TED.Var{System.Int64},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with minimal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Minimal``1(TED.Var{``0},TED.Var{System.UInt32},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with minimal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Minimal``1(TED.Var{``0},TED.Var{System.Int32},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with minimal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Minimal``1(TED.Var{``0},TED.Var{System.UInt16},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with minimal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Minimal``1(TED.Var{``0},TED.Var{System.Int16},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with minimal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Minimal``1(TED.Var{``0},TED.Var{System.Byte},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with minimal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Minimal``1(TED.Var{``0},TED.Var{System.SByte},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with minimal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Maximal``3(System.ValueTuple{TED.Var{``0},TED.Var{``1}},TED.Var{``2},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with maximal value of objective
            </summary>
            <typeparam name="TArg1">Type of the first variable to report back</typeparam>
            <typeparam name="TArg2">Type of the second variable to report back</typeparam>
            <typeparam name="TUtility">Type of the utility variable</typeparam>
            <param name="args">Variables from Goal to report the values of for the maximal solution</param>
            <param name="objective">Variable to maximize across solutions to goal</param>
            <param name="goal">Goal to find the maximal solution of</param>
        </member>
        <member name="M:TED.Language.Maximal``2(System.ValueTuple{TED.Var{``0},TED.Var{``1}},TED.Var{System.Single},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with maximal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Maximal``2(System.ValueTuple{TED.Var{``0},TED.Var{``1}},TED.Var{System.Int64},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with maximal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Maximal``2(System.ValueTuple{TED.Var{``0},TED.Var{``1}},TED.Var{System.UInt32},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with maximal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Maximal``2(System.ValueTuple{TED.Var{``0},TED.Var{``1}},TED.Var{System.Int32},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with maximal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Maximal``2(System.ValueTuple{TED.Var{``0},TED.Var{``1}},TED.Var{System.UInt16},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with maximal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Maximal``2(System.ValueTuple{TED.Var{``0},TED.Var{``1}},TED.Var{System.Int16},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with maximal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Maximal``2(System.ValueTuple{TED.Var{``0},TED.Var{``1}},TED.Var{System.Byte},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with maximal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Maximal``2(System.ValueTuple{TED.Var{``0},TED.Var{``1}},TED.Var{System.SByte},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with maximal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Minimal``3(System.ValueTuple{TED.Var{``0},TED.Var{``1}},TED.Var{``2},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with minimal value of objective
            </summary>
            <typeparam name="TArg1">Type of the first variable to report back</typeparam>
            <typeparam name="TArg2">Type of the second variable to report back</typeparam>
            <typeparam name="TUtility">Type of the utility variable</typeparam>
            <param name="args">Variables from Goal to report the values of for the minimal solution</param>
            <param name="objective">Variable to minimize across solutions to goal</param>
            <param name="goal">Goal to find the minimal solution of</param>
        </member>
        <member name="M:TED.Language.Minimal``2(System.ValueTuple{TED.Var{``0},TED.Var{``1}},TED.Var{System.Single},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with minimal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Minimal``2(System.ValueTuple{TED.Var{``0},TED.Var{``1}},TED.Var{System.Int64},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with minimal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Minimal``2(System.ValueTuple{TED.Var{``0},TED.Var{``1}},TED.Var{System.UInt32},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with minimal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Minimal``2(System.ValueTuple{TED.Var{``0},TED.Var{``1}},TED.Var{System.Int32},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with minimal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Minimal``2(System.ValueTuple{TED.Var{``0},TED.Var{``1}},TED.Var{System.UInt16},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with minimal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Minimal``2(System.ValueTuple{TED.Var{``0},TED.Var{``1}},TED.Var{System.Int16},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with minimal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Minimal``2(System.ValueTuple{TED.Var{``0},TED.Var{``1}},TED.Var{System.Byte},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with minimal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Minimal``2(System.ValueTuple{TED.Var{``0},TED.Var{``1}},TED.Var{System.SByte},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with minimal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Maximal``4(System.ValueTuple{TED.Var{``0},TED.Var{``1},TED.Var{``2}},TED.Var{``3},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with maximal value of objective
            </summary>
            <typeparam name="TArg1">Type of the first variable to report back</typeparam>
            <typeparam name="TArg2">Type of the second variable to report back</typeparam>
            <typeparam name="TArg3">Type of the third variable to report back</typeparam>
            <typeparam name="TUtility">Type of the utility variable</typeparam>
            <param name="args">Variables from Goal to report the values of for the minimal solution</param>
            <param name="objective">Variable to maximize across solutions to goal</param>
            <param name="goal">Goal to find the maximal solution of</param>
        </member>
        <member name="M:TED.Language.Maximal``3(System.ValueTuple{TED.Var{``0},TED.Var{``1},TED.Var{``2}},TED.Var{System.Single},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with maximal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Maximal``3(System.ValueTuple{TED.Var{``0},TED.Var{``1},TED.Var{``2}},TED.Var{System.Int64},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with maximal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Maximal``3(System.ValueTuple{TED.Var{``0},TED.Var{``1},TED.Var{``2}},TED.Var{System.UInt32},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with maximal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Maximal``3(System.ValueTuple{TED.Var{``0},TED.Var{``1},TED.Var{``2}},TED.Var{System.Int32},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with maximal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Maximal``3(System.ValueTuple{TED.Var{``0},TED.Var{``1},TED.Var{``2}},TED.Var{System.UInt16},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with maximal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Maximal``3(System.ValueTuple{TED.Var{``0},TED.Var{``1},TED.Var{``2}},TED.Var{System.Int16},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with maximal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Maximal``3(System.ValueTuple{TED.Var{``0},TED.Var{``1},TED.Var{``2}},TED.Var{System.Byte},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with maximal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Maximal``3(System.ValueTuple{TED.Var{``0},TED.Var{``1},TED.Var{``2}},TED.Var{System.SByte},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with maximal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Minimal``4(System.ValueTuple{TED.Var{``0},TED.Var{``1},TED.Var{``2}},TED.Var{``3},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with minimal value of objective
            </summary>
            <typeparam name="TArg1">Type of the first variable to report back</typeparam>
            <typeparam name="TArg2">Type of the second variable to report back</typeparam>
            <typeparam name="TArg3">Type of the third variable to report back</typeparam>
            <typeparam name="TUtility">Type of the utility variable</typeparam>
            <param name="args">Variables from Goal to report the values of for the minimal solution</param>
            <param name="objective">Variable to minimize across solutions to goal</param>
            <param name="goal">Goal to find the minimal solution of</param>
        </member>
        <member name="M:TED.Language.Minimal``3(System.ValueTuple{TED.Var{``0},TED.Var{``1},TED.Var{``2}},TED.Var{System.Single},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with minimal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Minimal``3(System.ValueTuple{TED.Var{``0},TED.Var{``1},TED.Var{``2}},TED.Var{System.Int64},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with minimal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Minimal``3(System.ValueTuple{TED.Var{``0},TED.Var{``1},TED.Var{``2}},TED.Var{System.UInt32},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with minimal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Minimal``3(System.ValueTuple{TED.Var{``0},TED.Var{``1},TED.Var{``2}},TED.Var{System.Int32},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with minimal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Minimal``3(System.ValueTuple{TED.Var{``0},TED.Var{``1},TED.Var{``2}},TED.Var{System.UInt16},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with minimal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Minimal``3(System.ValueTuple{TED.Var{``0},TED.Var{``1},TED.Var{``2}},TED.Var{System.Int16},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with minimal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Minimal``3(System.ValueTuple{TED.Var{``0},TED.Var{``1},TED.Var{``2}},TED.Var{System.Byte},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with minimal value of objective
            </summary>
        </member>
        <member name="M:TED.Language.Minimal``3(System.ValueTuple{TED.Var{``0},TED.Var{``1},TED.Var{``2}},TED.Var{System.SByte},TED.Interpreter.Goal)">
            <summary>
            Find the solution to goal with minimal value of objective
            </summary>
        </member>
        <member name="F:TED.Language.MaxInt">
            <summary>
            The largest of two arguments
            </summary>
        </member>
        <member name="F:TED.Language.MaxFloat">
            <summary>
            The largest of two arguments
            </summary>
        </member>
        <member name="F:TED.Language.MinInt">
            <summary>
            The smaller of two arguments
            </summary>
        </member>
        <member name="F:TED.Language.MinFloat">
            <summary>
            The smaller of two arguments
            </summary>
        </member>
        <member name="F:TED.Language.AbsInt">
            <summary>
            The absolute value of a number
            </summary>
        </member>
        <member name="F:TED.Language.AbsFloat">
            <summary>
            The absolute value of a number
            </summary>
        </member>
        <member name="F:TED.Language.SignInt">
            <summary>
            Sign number (1, 0, or -1) of x
            </summary>
        </member>
        <member name="F:TED.Language.SignFloat">
            <summary>
            Sign number (1, 0, or -1) of x
            </summary>
        </member>
        <member name="F:TED.Language.Sqrt">
            <summary>
            The square root of a float
            </summary>
        </member>
        <member name="F:TED.Language.Log">
            <summary>
            The natural log of a float
            </summary>
        </member>
        <member name="F:TED.Language.Exp">
            <summary>
            e^x
            </summary>
        </member>
        <member name="F:TED.Language.Pow">
            <summary>
            x^y
            </summary>
        </member>
        <member name="F:TED.Language.Sin">
            <summary>
            Sin x
            </summary>
        </member>
        <member name="F:TED.Language.Cos">
            <summary>
            Cos x
            </summary>
        </member>
        <member name="F:TED.Language.Tan">
            <summary>
            Tan x
            </summary>
        </member>
        <member name="F:TED.Language.Asin">
            <summary>
            Arc Sin x
            </summary>
        </member>
        <member name="F:TED.Language.ACos">
            <summary>
            Arc Cos x
            </summary>
        </member>
        <member name="F:TED.Language.Atan">
            <summary>
            Arc Tan x
            </summary>
        </member>
        <member name="F:TED.Language.Atan2">
            <summary>
            Arc Tan x/y
            </summary>
        </member>
        <member name="F:TED.Language.Int">
            <summary>
            Returns (int)x
            </summary>
        </member>
        <member name="F:TED.Language.Float">
            <summary>
            Returns (float)x
            </summary>
        </member>
        <member name="F:TED.Language.Ceiling">
            <summary>
            Smallest integer larger than x
            </summary>
        </member>
        <member name="F:TED.Language.Floor">
            <summary>
            Largest integer less than x
            </summary>
        </member>
        <member name="F:TED.Language.Round">
            <summary>
            The nearest integer to x
            </summary>
        </member>
        <member name="M:TED.Language.AssertIn``1(TED.Term{``0},System.String)">
            <summary>
            Assert that term is an "in" parameter, i.e. it's value is known by the time we get to the AssertIn call.
            If it is, this does nothing.  If not, this throws a preprocessing-time exception.
            </summary>
            <param name="term">Term to check the binding state of</param>
            <param name="message">Message to print if the terms has the wrong bindings state</param>
            <typeparam name="T">type of term</typeparam>
        </member>
        <member name="M:TED.Language.AssertOut``1(TED.Term{``0},System.String)">
            <summary>
            Assert that term is an "out" parameter, i.e. it's value is not known by the time we get to the AssertIn call.
            If it is, this does nothing.  If not, this throws a preprocessing-time exception.
            </summary>
            <param name="term">Term to check the binding state of</param>
            <param name="message">Message to print if the terms has the wrong bindings state</param>
            <typeparam name="T">type of term</typeparam>
        </member>
        <member name="M:TED.Language.AssertConstant``1(TED.Term{``0},System.String)">
            <summary>
            Assert that term is a literal constant.
            If it is, this does nothing.  If not, this throws a preprocessing-time exception.
            </summary>
            <param name="term">Term to check the binding state of</param>
            <param name="message">Message to print if the terms has the wrong bindings state</param>
            <typeparam name="T">type of term</typeparam>
        </member>
        <member name="P:TED.Language.__">
            <summary>
            No name variable placeholder
            </summary>
        </member>
        <member name="M:TED.Language.Constant``1(``0)">
            <summary>
            Coerces a C# constant to a Constant Term for times when C#'s type inference isn'term smart enough to figure it out.
            </summary>
        </member>
        <member name="M:TED.Language.Length(System.String,TED.TablePredicate)">
            <summary>
            Make a function that returns predicate.Length
            </summary>
            <param name="name">Name of the Function, for debugging purposes</param>
            <param name="predicate">Table to get the Length of</param>
            <returns></returns>
        </member>
        <member name="M:TED.Language.IntLength(System.String,TED.TablePredicate)">
            <summary>
            Make a function that returns predicate.Length as an int
            </summary>
            <param name="name">Name of the Function, for debugging purposes</param>
            <param name="predicate">Table to get the Length of</param>
            <returns></returns>
        </member>
        <member name="M:TED.Language.Predicate``1(System.String,TED.Interpreter.IColumnSpec{``0})">
            <summary>
            Make a new table predicate
            </summary>
            <typeparam name="T1">Type of the first argument to the predicate</typeparam>
            <param name="name">Name for the predicate, for debugging purposes</param>
            <param name="arg">Variable to be used as the default first argument.</param>
        </member>
        <member name="M:TED.Language.Predicate``2(System.String,TED.Interpreter.IColumnSpec{``0},TED.Interpreter.IColumnSpec{``1})">
            <summary>
            Make a new table predicate
            </summary>
            <typeparam name="T1">Type of the first argument to the predicate</typeparam>
            <typeparam name="T2">Type of the second argument to the predicate</typeparam>
            <param name="name">Name for the predicate, for debugging purposes</param>
            <param name="arg1">Variable to be used as the default first argument.</param>
            <param name="arg2">Variable to be used as the default second argument.</param>
        </member>
        <member name="M:TED.Language.Predicate``3(System.String,TED.Interpreter.IColumnSpec{``0},TED.Interpreter.IColumnSpec{``1},TED.Interpreter.IColumnSpec{``2})">
            <summary>
            Make a new table predicate
            </summary>
            <typeparam name="T1">Type of the first argument to the predicate</typeparam>
            <typeparam name="T2">Type of the second argument to the predicate</typeparam>
            <typeparam name="T3">Type of the third argument to the predicate</typeparam>
            <param name="name">Name for the predicate, for debugging purposes</param>
            <param name="arg1">Variable to be used as the default first argument.</param>
            <param name="arg2">Variable to be used as the default second argument.</param>
            <param name="arg3">Variable to be used as the default third argument.</param>
        </member>
        <member name="M:TED.Language.Predicate``4(System.String,TED.Interpreter.IColumnSpec{``0},TED.Interpreter.IColumnSpec{``1},TED.Interpreter.IColumnSpec{``2},TED.Interpreter.IColumnSpec{``3})">
            <summary>
            Make a new table predicate
            </summary>
            <typeparam name="T1">Type of the first argument to the predicate</typeparam>
            <typeparam name="T2">Type of the second argument to the predicate</typeparam>
            <typeparam name="T3">Type of the third argument to the predicate</typeparam>
            <typeparam name="T4">Type of the fourth argument to the predicate</typeparam>
            <param name="name">Name for the predicate, for debugging purposes</param>
            <param name="arg1">Variable to be used as the default first argument.</param>
            <param name="arg2">Variable to be used as the default second argument.</param>
            <param name="arg3">Variable to be used as the default third argument.</param>
            <param name="arg4">Variable to be used as the default fourth argument.</param>
        </member>
        <member name="M:TED.Language.Predicate``5(System.String,TED.Interpreter.IColumnSpec{``0},TED.Interpreter.IColumnSpec{``1},TED.Interpreter.IColumnSpec{``2},TED.Interpreter.IColumnSpec{``3},TED.Interpreter.IColumnSpec{``4})">
            <summary>
            Make a new table predicate
            </summary>
            <typeparam name="T1">Type of the first argument to the predicate</typeparam>
            <typeparam name="T2">Type of the second argument to the predicate</typeparam>
            <typeparam name="T3">Type of the third argument to the predicate</typeparam>
            <typeparam name="T4">Type of the fourth argument to the predicate</typeparam>
            <typeparam name="T5">Type of the fifth argument to the predicate</typeparam>
            <param name="name">Name for the predicate, for debugging purposes</param>
            <param name="arg1">Variable to be used as the default first argument.</param>
            <param name="arg2">Variable to be used as the default second argument.</param>
            <param name="arg3">Variable to be used as the default third argument.</param>
            <param name="arg4">Variable to be used as the default fourth argument.</param>
            <param name="arg5">Variable to be used as the default fifth argument.</param>
        </member>
        <member name="M:TED.Language.Predicate``6(System.String,TED.Interpreter.IColumnSpec{``0},TED.Interpreter.IColumnSpec{``1},TED.Interpreter.IColumnSpec{``2},TED.Interpreter.IColumnSpec{``3},TED.Interpreter.IColumnSpec{``4},TED.Interpreter.IColumnSpec{``5})">
            <summary>
            Make a new table predicate
            </summary>
            <typeparam name="T1">Type of the first argument to the predicate</typeparam>
            <typeparam name="T2">Type of the second argument to the predicate</typeparam>
            <typeparam name="T3">Type of the third argument to the predicate</typeparam>
            <typeparam name="T4">Type of the fourth argument to the predicate</typeparam>
            <typeparam name="T5">Type of the fifth argument to the predicate</typeparam>
            <typeparam name="T6">Type of the sixth argument to the predicate</typeparam>
            <param name="name">Name for the predicate, for debugging purposes</param>
            <param name="arg1">Variable to be used as the default first argument.</param>
            <param name="arg2">Variable to be used as the default second argument.</param>
            <param name="arg3">Variable to be used as the default third argument.</param>
            <param name="arg4">Variable to be used as the default fourth argument.</param>
            <param name="arg5">Variable to be used as the default fifth argument.</param>
            <param name="arg6">Variable to be used as the default sixth argument.</param>
        </member>
        <member name="M:TED.Language.Predicate``7(System.String,TED.Interpreter.IColumnSpec{``0},TED.Interpreter.IColumnSpec{``1},TED.Interpreter.IColumnSpec{``2},TED.Interpreter.IColumnSpec{``3},TED.Interpreter.IColumnSpec{``4},TED.Interpreter.IColumnSpec{``5},TED.Interpreter.IColumnSpec{``6})">
            <summary>
            Make a new table predicate
            </summary>
            <typeparam name="T1">Type of the first argument to the predicate</typeparam>
            <typeparam name="T2">Type of the second argument to the predicate</typeparam>
            <typeparam name="T3">Type of the third argument to the predicate</typeparam>
            <typeparam name="T4">Type of the fourth argument to the predicate</typeparam>
            <typeparam name="T5">Type of the fifth argument to the predicate</typeparam>
            <typeparam name="T6">Type of the sixth argument to the predicate</typeparam>
            <typeparam name="T7">Type of the seventh argument to the predicate</typeparam>
            <param name="name">Name for the predicate, for debugging purposes</param>
            <param name="arg1">Variable to be used as the default first argument.</param>
            <param name="arg2">Variable to be used as the default second argument.</param>
            <param name="arg3">Variable to be used as the default third argument.</param>
            <param name="arg4">Variable to be used as the default fourth argument.</param>
            <param name="arg5">Variable to be used as the default fifth argument.</param>
            <param name="arg6">Variable to be used as the default sixth argument.</param>
            <param name="arg7">Variable to be used as the default seventh argument.</param>
        </member>
        <member name="M:TED.Language.Predicate``8(System.String,TED.Interpreter.IColumnSpec{``0},TED.Interpreter.IColumnSpec{``1},TED.Interpreter.IColumnSpec{``2},TED.Interpreter.IColumnSpec{``3},TED.Interpreter.IColumnSpec{``4},TED.Interpreter.IColumnSpec{``5},TED.Interpreter.IColumnSpec{``6},TED.Interpreter.IColumnSpec{``7})">
            <summary>
            Make a new table predicate
            </summary>
            <typeparam name="T1">Type of the first argument to the predicate</typeparam>
            <typeparam name="T2">Type of the second argument to the predicate</typeparam>
            <typeparam name="T3">Type of the third argument to the predicate</typeparam>
            <typeparam name="T4">Type of the fourth argument to the predicate</typeparam>
            <typeparam name="T5">Type of the fifth argument to the predicate</typeparam>
            <typeparam name="T6">Type of the sixth argument to the predicate</typeparam>
            <typeparam name="T7">Type of the seventh argument to the predicate</typeparam>
            <typeparam name="T8">Type of the seventh argument to the predicate</typeparam>
            <param name="name">Name for the predicate, for debugging purposes</param>
            <param name="arg1">Variable to be used as the default first argument.</param>
            <param name="arg2">Variable to be used as the default second argument.</param>
            <param name="arg3">Variable to be used as the default third argument.</param>
            <param name="arg4">Variable to be used as the default fourth argument.</param>
            <param name="arg5">Variable to be used as the default fifth argument.</param>
            <param name="arg6">Variable to be used as the default sixth argument.</param>
            <param name="arg7">Variable to be used as the default seventh argument.</param>
            <param name="arg8">Variable to be used as the default seventh argument.</param>
        </member>
        <member name="M:TED.Language.Predicate``1(System.String,System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Make a new TablePredicate from a row generator, and pre-populate it with rows from the generator.
            </summary>
        </member>
        <member name="M:TED.Language.Predicate``2(System.String,System.Collections.Generic.IEnumerable{System.ValueTuple{``0,``1}},System.String,System.String)">
            <summary>
            Make a new TablePredicate from a row generator, and pre-populate it with rows from the generator.
            </summary>
        </member>
        <member name="M:TED.Language.Predicate``3(System.String,System.Collections.Generic.IEnumerable{System.ValueTuple{``0,``1,``2}},System.String,System.String,System.String)">
            <summary>
            Make a new TablePredicate from a row generator, and pre-populate it with rows from the generator.
            </summary>
        </member>
        <member name="M:TED.Language.Predicate``4(System.String,System.Collections.Generic.IEnumerable{System.ValueTuple{``0,``1,``2,``3}},System.String,System.String,System.String,System.String)">
            <summary>
            Make a new TablePredicate from a row generator, and pre-populate it with rows from the generator.
            </summary>
        </member>
        <member name="M:TED.Language.Predicate``5(System.String,System.Collections.Generic.IEnumerable{System.ValueTuple{``0,``1,``2,``3,``4}},System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Make a new TablePredicate from a row generator, and pre-populate it with rows from the generator.
            </summary>
        </member>
        <member name="M:TED.Language.Predicate``6(System.String,System.Collections.Generic.IEnumerable{System.ValueTuple{``0,``1,``2,``3,``4,``5}},System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Make a new TablePredicate from a row generator, and pre-populate it with rows from the generator.
            </summary>
        </member>
        <member name="M:TED.Language.Predicate``7(System.String,System.Collections.Generic.IEnumerable{System.ValueTuple{``0,``1,``2,``3,``4,``5,``6}},System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Make a new TablePredicate from a row generator, and pre-populate it with rows from the generator.
            </summary>
        </member>
        <member name="M:TED.Language.Predicate``8(System.String,System.Collections.Generic.IEnumerable{System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7}}},System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            Make a new TablePredicate from a row generator, and pre-populate it with rows from the generator.
            </summary>
        </member>
        <member name="M:TED.Language.Predicate``1(System.String,System.Collections.Generic.IEnumerable{``0},TED.Interpreter.IColumnSpec{``0})">
            <summary>
            Make a new TablePredicate from a row generator, and pre-populate it with rows from the generator.
            </summary>
        </member>
        <member name="M:TED.Language.Predicate``2(System.String,System.Collections.Generic.IEnumerable{System.ValueTuple{``0,``1}},TED.Interpreter.IColumnSpec{``0},TED.Interpreter.IColumnSpec{``1})">
            <summary>
            Make a new TablePredicate from a row generator, and pre-populate it with rows from the generator.
            </summary>
        </member>
        <member name="M:TED.Language.Predicate``3(System.String,System.Collections.Generic.IEnumerable{System.ValueTuple{``0,``1,``2}},TED.Interpreter.IColumnSpec{``0},TED.Interpreter.IColumnSpec{``1},TED.Interpreter.IColumnSpec{``2})">
            <summary>
            Make a new TablePredicate from a row generator, and pre-populate it with rows from the generator.
            </summary>
        </member>
        <member name="M:TED.Language.Predicate``4(System.String,System.Collections.Generic.IEnumerable{System.ValueTuple{``0,``1,``2,``3}},TED.Interpreter.IColumnSpec{``0},TED.Interpreter.IColumnSpec{``1},TED.Interpreter.IColumnSpec{``2},TED.Interpreter.IColumnSpec{``3})">
            <summary>
            Make a new TablePredicate from a row generator, and pre-populate it with rows from the generator.
            </summary>
        </member>
        <member name="M:TED.Language.Predicate``5(System.String,System.Collections.Generic.IEnumerable{System.ValueTuple{``0,``1,``2,``3,``4}},TED.Interpreter.IColumnSpec{``0},TED.Interpreter.IColumnSpec{``1},TED.Interpreter.IColumnSpec{``2},TED.Interpreter.IColumnSpec{``3},TED.Interpreter.IColumnSpec{``4})">
            <summary>
            Make a new TablePredicate from a row generator, and pre-populate it with rows from the generator.
            </summary>
        </member>
        <member name="M:TED.Language.Predicate``6(System.String,System.Collections.Generic.IEnumerable{System.ValueTuple{``0,``1,``2,``3,``4,``5}},TED.Interpreter.IColumnSpec{``0},TED.Interpreter.IColumnSpec{``1},TED.Interpreter.IColumnSpec{``2},TED.Interpreter.IColumnSpec{``3},TED.Interpreter.IColumnSpec{``4},TED.Interpreter.IColumnSpec{``5})">
            <summary>
            Make a new TablePredicate from a row generator, and pre-populate it with rows from the generator.
            </summary>
        </member>
        <member name="M:TED.Language.Predicate``7(System.String,System.Collections.Generic.IEnumerable{System.ValueTuple{``0,``1,``2,``3,``4,``5,``6}},TED.Interpreter.IColumnSpec{``0},TED.Interpreter.IColumnSpec{``1},TED.Interpreter.IColumnSpec{``2},TED.Interpreter.IColumnSpec{``3},TED.Interpreter.IColumnSpec{``4},TED.Interpreter.IColumnSpec{``5},TED.Interpreter.IColumnSpec{``6})">
            <summary>
            Make a new TablePredicate from a row generator, and pre-populate it with rows from the generator.
            </summary>
        </member>
        <member name="M:TED.Language.Predicate``8(System.String,System.Collections.Generic.IEnumerable{System.ValueTuple{``0,``1,``2,``3,``4,``5,``6,System.ValueTuple{``7}}},TED.Interpreter.IColumnSpec{``0},TED.Interpreter.IColumnSpec{``1},TED.Interpreter.IColumnSpec{``2},TED.Interpreter.IColumnSpec{``3},TED.Interpreter.IColumnSpec{``4},TED.Interpreter.IColumnSpec{``5},TED.Interpreter.IColumnSpec{``6},TED.Interpreter.IColumnSpec{``7})">
            <summary>
            Make a new TablePredicate from a row generator, and pre-populate it with rows from the generator.
            </summary>
        </member>
        <member name="M:TED.Language.FromCsv``1(System.String,System.String,TED.Interpreter.IColumnSpec{``0})">
            <summary>
            Make a new table predicate, loading in rows from the specified csv
            </summary>
            <typeparam name="T1">Type of the first argument to the predicate</typeparam>
            <param name="name">Name for the predicate, for debugging purposes</param>
            <param name="path">Path to the CSV file</param>
            <param name="arg1">Variable to be used as the default first argument.</param>
        </member>
        <member name="M:TED.Language.FromCsv``2(System.String,System.String,TED.Interpreter.IColumnSpec{``0},TED.Interpreter.IColumnSpec{``1})">
            <summary>
            Make a new table predicate, loading in rows from the specified csv
            </summary>
            <typeparam name="T1">Type of the first argument to the predicate</typeparam>
            <typeparam name="T2">Type of the second argument to the predicate</typeparam>
            <param name="name">Name for the predicate, for debugging purposes</param>
            <param name="path">Path to the CSV file</param>
            <param name="arg1">Variable to be used as the default first argument.</param>
            <param name="arg2">Variable to be used as the default second argument.</param>
        </member>
        <member name="M:TED.Language.FromCsv``3(System.String,System.String,TED.Interpreter.IColumnSpec{``0},TED.Interpreter.IColumnSpec{``1},TED.Interpreter.IColumnSpec{``2})">
            <summary>
            Make a new table predicate, loading in rows from the specified csv
            </summary>
            <typeparam name="T1">Type of the first argument to the predicate</typeparam>
            <typeparam name="T2">Type of the second argument to the predicate</typeparam>
            <typeparam name="T3">Type of the third argument to the predicate</typeparam>
            <param name="name">Name for the predicate, for debugging purposes</param>
            <param name="path">Path to the CSV file</param>
            <param name="arg1">Variable to be used as the default first argument.</param>
            <param name="arg2">Variable to be used as the default second argument.</param>
            <param name="arg3">Variable to be used as the default third argument.</param>
        </member>
        <member name="M:TED.Language.FromCsv``4(System.String,System.String,TED.Interpreter.IColumnSpec{``0},TED.Interpreter.IColumnSpec{``1},TED.Interpreter.IColumnSpec{``2},TED.Interpreter.IColumnSpec{``3})">
            <summary>
            Make a new table predicate, loading in rows from the specified csv
            </summary>
            <typeparam name="T1">Type of the first argument to the predicate</typeparam>
            <typeparam name="T2">Type of the second argument to the predicate</typeparam>
            <typeparam name="T3">Type of the third argument to the predicate</typeparam>
            <typeparam name="T4">Type of the fourth argument to the predicate</typeparam>
            <param name="name">Name for the predicate, for debugging purposes</param>
            <param name="path">Path to the CSV file</param>
            <param name="arg1">Variable to be used as the default first argument.</param>
            <param name="arg2">Variable to be used as the default second argument.</param>
            <param name="arg3">Variable to be used as the default third argument.</param>
            <param name="arg4">Variable to be used as the default fourth argument.</param>
        </member>
        <member name="M:TED.Language.FromCsv``5(System.String,System.String,TED.Interpreter.IColumnSpec{``0},TED.Interpreter.IColumnSpec{``1},TED.Interpreter.IColumnSpec{``2},TED.Interpreter.IColumnSpec{``3},TED.Interpreter.IColumnSpec{``4})">
            <summary>
            Make a new table predicate, loading in rows from the specified csv
            </summary>
            <typeparam name="T1">Type of the first argument to the predicate</typeparam>
            <typeparam name="T2">Type of the second argument to the predicate</typeparam>
            <typeparam name="T3">Type of the third argument to the predicate</typeparam>
            <typeparam name="T4">Type of the fourth argument to the predicate</typeparam>
            <typeparam name="T5">Type of the fifth argument to the predicate</typeparam>
            <param name="name">Name for the predicate, for debugging purposes</param>
            <param name="path">Path to the CSV file</param>
            <param name="arg1">Variable to be used as the default first argument.</param>
            <param name="arg2">Variable to be used as the default second argument.</param>
            <param name="arg3">Variable to be used as the default third argument.</param>
            <param name="arg4">Variable to be used as the default fourth argument.</param>
            <param name="arg5">Variable to be used as the default fifth argument.</param>
        </member>
        <member name="M:TED.Language.FromCsv``6(System.String,System.String,TED.Interpreter.IColumnSpec{``0},TED.Interpreter.IColumnSpec{``1},TED.Interpreter.IColumnSpec{``2},TED.Interpreter.IColumnSpec{``3},TED.Interpreter.IColumnSpec{``4},TED.Interpreter.IColumnSpec{``5})">
            <summary>
            Make a new table predicate, loading in rows from the specified csv
            </summary>
            <typeparam name="T1">Type of the first argument to the predicate</typeparam>
            <typeparam name="T2">Type of the second argument to the predicate</typeparam>
            <typeparam name="T3">Type of the third argument to the predicate</typeparam>
            <typeparam name="T4">Type of the fourth argument to the predicate</typeparam>
            <typeparam name="T5">Type of the fifth argument to the predicate</typeparam>
            <typeparam name="T6">Type of the sixth argument to the predicate</typeparam>
            <param name="name">Name for the predicate, for debugging purposes</param>
            <param name="path">Path to the CSV file</param>
            <param name="arg1">Variable to be used as the default first argument.</param>
            <param name="arg2">Variable to be used as the default second argument.</param>
            <param name="arg3">Variable to be used as the default third argument.</param>
            <param name="arg4">Variable to be used as the default fourth argument.</param>
            <param name="arg5">Variable to be used as the default fifth argument.</param>
            <param name="arg6">Variable to be used as the default sixth argument.</param>
        </member>
        <member name="M:TED.Language.FromCsv``7(System.String,System.String,TED.Interpreter.IColumnSpec{``0},TED.Interpreter.IColumnSpec{``1},TED.Interpreter.IColumnSpec{``2},TED.Interpreter.IColumnSpec{``3},TED.Interpreter.IColumnSpec{``4},TED.Interpreter.IColumnSpec{``5},TED.Interpreter.IColumnSpec{``6})">
            <summary>
            Make a new table predicate, loading in rows from the specified csv
            </summary>
            <typeparam name="T1">Type of the first argument to the predicate</typeparam>
            <typeparam name="T2">Type of the second argument to the predicate</typeparam>
            <typeparam name="T3">Type of the third argument to the predicate</typeparam>
            <typeparam name="T4">Type of the fourth argument to the predicate</typeparam>
            <typeparam name="T5">Type of the fifth argument to the predicate</typeparam>
            <typeparam name="T6">Type of the sixth argument to the predicate</typeparam>
            <typeparam name="T7">Type of the seventh argument to the predicate</typeparam>
            <param name="name">Name for the predicate, for debugging purposes</param>
            <param name="path">Path to the CSV file</param>
            <param name="arg1">Variable to be used as the default first argument.</param>
            <param name="arg2">Variable to be used as the default second argument.</param>
            <param name="arg3">Variable to be used as the default third argument.</param>
            <param name="arg4">Variable to be used as the default fourth argument.</param>
            <param name="arg5">Variable to be used as the default fifth argument.</param>
            <param name="arg6">Variable to be used as the default sixth argument.</param>
            <param name="arg7">Variable to be used as the default seventh argument.</param>
        </member>
        <member name="M:TED.Language.FromCsv``8(System.String,System.String,TED.Interpreter.IColumnSpec{``0},TED.Interpreter.IColumnSpec{``1},TED.Interpreter.IColumnSpec{``2},TED.Interpreter.IColumnSpec{``3},TED.Interpreter.IColumnSpec{``4},TED.Interpreter.IColumnSpec{``5},TED.Interpreter.IColumnSpec{``6},TED.Interpreter.IColumnSpec{``7})">
            <summary>
            Make a new table predicate, loading in rows from the specified csv
            </summary>
            <typeparam name="T1">Type of the first argument to the predicate</typeparam>
            <typeparam name="T2">Type of the second argument to the predicate</typeparam>
            <typeparam name="T3">Type of the third argument to the predicate</typeparam>
            <typeparam name="T4">Type of the fourth argument to the predicate</typeparam>
            <typeparam name="T5">Type of the fifth argument to the predicate</typeparam>
            <typeparam name="T6">Type of the sixth argument to the predicate</typeparam>
            <typeparam name="T7">Type of the seventh argument to the predicate</typeparam>
            <typeparam name="T8">Type of the eighth argument to the predicate</typeparam>
            <param name="name">Name for the predicate, for debugging purposes</param>
            <param name="path">Path to the CSV file</param>
            <param name="arg1">Variable to be used as the default first argument.</param>
            <param name="arg2">Variable to be used as the default second argument.</param>
            <param name="arg3">Variable to be used as the default third argument.</param>
            <param name="arg4">Variable to be used as the default fourth argument.</param>
            <param name="arg5">Variable to be used as the default fifth argument.</param>
            <param name="arg6">Variable to be used as the default sixth argument.</param>
            <param name="arg7">Variable to be used as the default seventh argument.</param>
            <param name="arg8">Variable to be used as the default eighth argument.</param>
        </member>
        <member name="M:TED.Language.FromCsv``1(System.String,TED.Interpreter.IColumnSpec{``0})">
            <summary>
            Make a new table predicate, loading in rows from the specified csv
            </summary>
            <typeparam name="T1">Type of the first argument to the predicate</typeparam>
            <param name="path">Path to the CSV file</param>
            <param name="arg1">Variable to be used as the default first argument.</param>
        </member>
        <member name="M:TED.Language.FromCsv``2(System.String,TED.Interpreter.IColumnSpec{``0},TED.Interpreter.IColumnSpec{``1})">
            <summary>
            Make a new table predicate, loading in rows from the specified csv
            </summary>
            <typeparam name="T1">Type of the first argument to the predicate</typeparam>
            <typeparam name="T2">Type of the second argument to the predicate</typeparam>
            <param name="path">Path to the CSV file</param>
            <param name="arg1">Variable to be used as the default first argument.</param>
            <param name="arg2">Variable to be used as the default second argument.</param>
        </member>
        <member name="M:TED.Language.FromCsv``3(System.String,TED.Interpreter.IColumnSpec{``0},TED.Interpreter.IColumnSpec{``1},TED.Interpreter.IColumnSpec{``2})">
            <summary>
            Make a new table predicate, loading in rows from the specified csv
            </summary>
            <typeparam name="T1">Type of the first argument to the predicate</typeparam>
            <typeparam name="T2">Type of the second argument to the predicate</typeparam>
            <typeparam name="T3">Type of the third argument to the predicate</typeparam>
            <param name="path">Path to the CSV file</param>
            <param name="arg1">Variable to be used as the default first argument.</param>
            <param name="arg2">Variable to be used as the default second argument.</param>
            <param name="arg3">Variable to be used as the default third argument.</param>
        </member>
        <member name="M:TED.Language.FromCsv``4(System.String,TED.Interpreter.IColumnSpec{``0},TED.Interpreter.IColumnSpec{``1},TED.Interpreter.IColumnSpec{``2},TED.Interpreter.IColumnSpec{``3})">
            <summary>
            Make a new table predicate, loading in rows from the specified csv
            </summary>
            <typeparam name="T1">Type of the first argument to the predicate</typeparam>
            <typeparam name="T2">Type of the second argument to the predicate</typeparam>
            <typeparam name="T3">Type of the third argument to the predicate</typeparam>
            <typeparam name="T4">Type of the fourth argument to the predicate</typeparam>
            <param name="path">Path to the CSV file</param>
            <param name="arg1">Variable to be used as the default first argument.</param>
            <param name="arg2">Variable to be used as the default second argument.</param>
            <param name="arg3">Variable to be used as the default third argument.</param>
            <param name="arg4">Variable to be used as the default fourth argument.</param>
        </member>
        <member name="M:TED.Language.FromCsv``5(System.String,TED.Interpreter.IColumnSpec{``0},TED.Interpreter.IColumnSpec{``1},TED.Interpreter.IColumnSpec{``2},TED.Interpreter.IColumnSpec{``3},TED.Interpreter.IColumnSpec{``4})">
            <summary>
            Make a new table predicate, loading in rows from the specified csv
            </summary>
            <typeparam name="T1">Type of the first argument to the predicate</typeparam>
            <typeparam name="T2">Type of the second argument to the predicate</typeparam>
            <typeparam name="T3">Type of the third argument to the predicate</typeparam>
            <typeparam name="T4">Type of the fourth argument to the predicate</typeparam>
            <typeparam name="T5">Type of the fifth argument to the predicate</typeparam>
            <param name="path">Path to the CSV file</param>
            <param name="arg1">Variable to be used as the default first argument.</param>
            <param name="arg2">Variable to be used as the default second argument.</param>
            <param name="arg3">Variable to be used as the default third argument.</param>
            <param name="arg4">Variable to be used as the default fourth argument.</param>
            <param name="arg5">Variable to be used as the default fifth argument.</param>
        </member>
        <member name="M:TED.Language.FromCsv``6(System.String,TED.Interpreter.IColumnSpec{``0},TED.Interpreter.IColumnSpec{``1},TED.Interpreter.IColumnSpec{``2},TED.Interpreter.IColumnSpec{``3},TED.Interpreter.IColumnSpec{``4},TED.Interpreter.IColumnSpec{``5})">
            <summary>
            Make a new table predicate, loading in rows from the specified csv
            </summary>
            <typeparam name="T1">Type of the first argument to the predicate</typeparam>
            <typeparam name="T2">Type of the second argument to the predicate</typeparam>
            <typeparam name="T3">Type of the third argument to the predicate</typeparam>
            <typeparam name="T4">Type of the fourth argument to the predicate</typeparam>
            <typeparam name="T5">Type of the fifth argument to the predicate</typeparam>
            <typeparam name="T6">Type of the sixth argument to the predicate</typeparam>
            <param name="path">Path to the CSV file</param>
            <param name="arg1">Variable to be used as the default first argument.</param>
            <param name="arg2">Variable to be used as the default second argument.</param>
            <param name="arg3">Variable to be used as the default third argument.</param>
            <param name="arg4">Variable to be used as the default fourth argument.</param>
            <param name="arg5">Variable to be used as the default fifth argument.</param>
            <param name="arg6">Variable to be used as the default sixth argument.</param>
        </member>
        <member name="M:TED.Language.FromCsv``7(System.String,TED.Interpreter.IColumnSpec{``0},TED.Interpreter.IColumnSpec{``1},TED.Interpreter.IColumnSpec{``2},TED.Interpreter.IColumnSpec{``3},TED.Interpreter.IColumnSpec{``4},TED.Interpreter.IColumnSpec{``5},TED.Interpreter.IColumnSpec{``6})">
            <summary>
            Make a new table predicate, loading in rows from the specified csv
            </summary>
            <typeparam name="T1">Type of the first argument to the predicate</typeparam>
            <typeparam name="T2">Type of the second argument to the predicate</typeparam>
            <typeparam name="T3">Type of the third argument to the predicate</typeparam>
            <typeparam name="T4">Type of the fourth argument to the predicate</typeparam>
            <typeparam name="T5">Type of the fifth argument to the predicate</typeparam>
            <typeparam name="T6">Type of the sixth argument to the predicate</typeparam>
            <typeparam name="T7">Type of the seventh argument to the predicate</typeparam>
            <param name="path">Path to the CSV file</param>
            <param name="arg1">Variable to be used as the default first argument.</param>
            <param name="arg2">Variable to be used as the default second argument.</param>
            <param name="arg3">Variable to be used as the default third argument.</param>
            <param name="arg4">Variable to be used as the default fourth argument.</param>
            <param name="arg5">Variable to be used as the default fifth argument.</param>
            <param name="arg6">Variable to be used as the default sixth argument.</param>
            <param name="arg7">Variable to be used as the default seventh argument.</param>
        </member>
        <member name="M:TED.Language.FromCsv``8(System.String,TED.Interpreter.IColumnSpec{``0},TED.Interpreter.IColumnSpec{``1},TED.Interpreter.IColumnSpec{``2},TED.Interpreter.IColumnSpec{``3},TED.Interpreter.IColumnSpec{``4},TED.Interpreter.IColumnSpec{``5},TED.Interpreter.IColumnSpec{``6},TED.Interpreter.IColumnSpec{``7})">
            <summary>
            Make a new table predicate, loading in rows from the specified csv
            </summary>
            <typeparam name="T1">Type of the first argument to the predicate</typeparam>
            <typeparam name="T2">Type of the second argument to the predicate</typeparam>
            <typeparam name="T3">Type of the third argument to the predicate</typeparam>
            <typeparam name="T4">Type of the fourth argument to the predicate</typeparam>
            <typeparam name="T5">Type of the fifth argument to the predicate</typeparam>
            <typeparam name="T6">Type of the sixth argument to the predicate</typeparam>
            <typeparam name="T7">Type of the seventh argument to the predicate</typeparam>
            <typeparam name="T8">Type of the eighth argument to the predicate</typeparam>
            <param name="path">Path to the CSV file</param>
            <param name="arg1">Variable to be used as the default first argument.</param>
            <param name="arg2">Variable to be used as the default second argument.</param>
            <param name="arg3">Variable to be used as the default third argument.</param>
            <param name="arg4">Variable to be used as the default fourth argument.</param>
            <param name="arg5">Variable to be used as the default fifth argument.</param>
            <param name="arg6">Variable to be used as the default sixth argument.</param>
            <param name="arg7">Variable to be used as the default seventh argument.</param>
            <param name="arg8">Variable to be used as the default eighth argument.</param>
        </member>
        <member name="M:TED.Language.Definition``1(System.String,TED.Var{``0})">
            <summary>
            Creates a predicate that is true whenever the goals of the IfAndOnlyIf clause are true.
            Definitions are not computed as tables; they're replaced with the bodies of their IfAndOnlyIf clauses whenever they're called.
            </summary>
            <param name="name">Name of the predicate, for debugging purposes</param>
            <param name="arg1">Argument to the predicate</param>
        </member>
        <member name="M:TED.Language.Definition``2(System.String,TED.Var{``0},TED.Var{``1})">
            <summary>
            Creates a predicate that is true whenever the goals of the IfAndOnlyIf clause are true.
            Definitions are not computed as tables; they're replaced with the bodies of their IfAndOnlyIf clauses whenever they're called.
            </summary>
            <param name="name">Name of the predicate, for debugging purposes</param>
            <param name="arg1">First argument to the predicate</param>
            <param name="arg2">Second argument to the predicate</param>
        </member>
        <member name="M:TED.Language.Definition``3(System.String,TED.Var{``0},TED.Var{``1},TED.Var{``2})">
            <summary>
            Creates a predicate that is true whenever the goals of the IfAndOnlyIf clause are true.
            Definitions are not computed as tables; they're replaced with the bodies of their IfAndOnlyIf clauses whenever they're called.
            </summary>
            <param name="name">Name of the predicate, for debugging purposes</param>
            <param name="arg1">First argument to the predicate</param>
            <param name="arg2">Second argument to the predicate</param>
            <param name="arg3">Third argument to the predicate</param>
        </member>
        <member name="M:TED.Language.Definition``4(System.String,TED.Var{``0},TED.Var{``1},TED.Var{``2},TED.Var{``3})">
            <summary>
            Creates a predicate that is true whenever the goals of the IfAndOnlyIf clause are true.
            Definitions are not computed as tables; they're replaced with the bodies of their IfAndOnlyIf clauses whenever they're called.
            </summary>
            <param name="name">Name of the predicate, for debugging purposes</param>
            <param name="arg1">First argument to the predicate</param>
            <param name="arg2">Second argument to the predicate</param>
            <param name="arg3">Third argument to the predicate</param>
            <param name="arg4">Fourth argument to the predicate</param>
        </member>
        <member name="M:TED.Language.Definition``5(System.String,TED.Var{``0},TED.Var{``1},TED.Var{``2},TED.Var{``3},TED.Var{``4})">
            <summary>
            Creates a predicate that is true whenever the goals of the IfAndOnlyIf clause are true.
            Definitions are not computed as tables; they're replaced with the bodies of their IfAndOnlyIf clauses whenever they're called.
            </summary>
            <param name="name">Name of the predicate, for debugging purposes</param>
            <param name="arg1">First argument to the predicate</param>
            <param name="arg2">Second argument to the predicate</param>
            <param name="arg3">Third argument to the predicate</param>
            <param name="arg4">Fourth argument to the predicate</param>
            <param name="arg5">Fifth argument to the predicate</param>
        </member>
        <member name="M:TED.Language.Definition``6(System.String,TED.Var{``0},TED.Var{``1},TED.Var{``2},TED.Var{``3},TED.Var{``4},TED.Var{``5})">
            <summary>
            Creates a predicate that is true whenever the goals of the IfAndOnlyIf clause are true.
            Definitions are not computed as tables; they're replaced with the bodies of their IfAndOnlyIf clauses whenever they're called.
            </summary>
            <param name="name">Name of the predicate, for debugging purposes</param>
            <param name="arg1">First argument to the predicate</param>
            <param name="arg2">Second argument to the predicate</param>
            <param name="arg3">Third argument to the predicate</param>
            <param name="arg4">Fourth argument to the predicate</param>
            <param name="arg5">Fifth argument to the predicate</param>
            <param name="arg6">Sixth argument to the predicate</param>
        </member>
        <member name="M:TED.Language.TestMember(System.Object,System.String,System.Boolean)">
            <summary>
            Makes a PrimitiveTest where the bool Func is built from a property on the given type
            </summary>
        </member>
        <member name="M:TED.Language.TestMethod(System.Func{System.Boolean},System.Boolean)">
            <summary>
            Makes a PrimitiveTest with the same name as the Func being passed in
            </summary>
        </member>
        <member name="M:TED.Language.Test(System.String,System.Func{System.Boolean},System.Boolean)">
            <summary>
            Makes a PrimitiveTest with the given name
            </summary>
        </member>
        <member name="M:TED.Language.TestMethod``1(System.Func{``0,System.Boolean},System.Boolean)">
            <summary>
            Makes a PrimitiveTest with the same name as the System.Predicate being passed in
            </summary>
        </member>
        <member name="M:TED.Language.Test``1(System.String,System.Func{``0,System.Boolean},System.Boolean)">
            <summary>
            Makes a PrimitiveTest with the given name
            </summary>
        </member>
        <member name="M:TED.Language.TestMethod``2(System.Func{``0,``1,System.Boolean},System.Boolean)">
            <summary>
            Makes a PrimitiveTest with the same name as the Func being passed in
            </summary>
        </member>
        <member name="M:TED.Language.Test``2(System.String,System.Func{``0,``1,System.Boolean},System.Boolean)">
            <summary>
            Makes a PrimitiveTest with the given name
            </summary>
        </member>
        <member name="M:TED.Language.TestMethod``3(System.Func{``0,``1,``2,System.Boolean},System.Boolean)">
            <summary>
            Makes a PrimitiveTest with the same name as the Func being passed in
            </summary>
        </member>
        <member name="M:TED.Language.Test``3(System.String,System.Func{``0,``1,``2,System.Boolean},System.Boolean)">
            <summary>
            Makes a PrimitiveTest with the given name
            </summary>
        </member>
        <member name="M:TED.Language.TestMethod``4(System.Func{``0,``1,``2,``3,System.Boolean},System.Boolean)">
            <summary>
            Makes a PrimitiveTest with the same name as the Func being passed in
            </summary>
        </member>
        <member name="M:TED.Language.Test``4(System.String,System.Func{``0,``1,``2,``3,System.Boolean},System.Boolean)">
            <summary>
            Makes a PrimitiveTest with the given name
            </summary>
        </member>
        <member name="M:TED.Language.TestMethod``5(System.Func{``0,``1,``2,``3,``4,System.Boolean},System.Boolean)">
            <summary>
            Makes a PrimitiveTest with the same name as the Func being passed in
            </summary>
        </member>
        <member name="M:TED.Language.Test``5(System.String,System.Func{``0,``1,``2,``3,``4,System.Boolean},System.Boolean)">
            <summary>
            Makes a PrimitiveTest with the given name
            </summary>
        </member>
        <member name="M:TED.Language.TestMethod``6(System.Func{``0,``1,``2,``3,``4,``5,System.Boolean},System.Boolean)">
            <summary>
            Makes a PrimitiveTest with the same name as the Func being passed in
            </summary>
        </member>
        <member name="M:TED.Language.Test``6(System.String,System.Func{``0,``1,``2,``3,``4,``5,System.Boolean},System.Boolean)">
            <summary>
            Makes a PrimitiveTest with the given name
            </summary>
        </member>
        <member name="M:TED.Language.TestMethod``7(System.Func{``0,``1,``2,``3,``4,``5,``6,System.Boolean},System.Boolean)">
            <summary>
            Makes a PrimitiveTest with the same name as the Func being passed in
            </summary>
        </member>
        <member name="M:TED.Language.Test``7(System.String,System.Func{``0,``1,``2,``3,``4,``5,``6,System.Boolean},System.Boolean)">
            <summary>
            Makes a PrimitiveTest with the given name
            </summary>
        </member>
        <member name="M:TED.Language.TestMethod``8(System.Func{``0,``1,``2,``3,``4,``5,``6,``7,System.Boolean},System.Boolean)">
            <summary>
            Makes a PrimitiveTest with the same name as the Func being passed in
            </summary>
        </member>
        <member name="M:TED.Language.Test``8(System.String,System.Func{``0,``1,``2,``3,``4,``5,``6,``7,System.Boolean},System.Boolean)">
            <summary>
            Makes a PrimitiveTest with the given name
            </summary>
        </member>
        <member name="M:TED.Language.Member``1(System.Object,System.String,System.Boolean)">
            <summary>
            Makes a Function where the Func T is built from a property on the given type
            </summary>
        </member>
        <member name="M:TED.Language.Member``1(System.Object,System.String,System.String,System.Boolean)">
            <summary>
            Makes a Function where the Func T is built from a property on the given type and the name
            of the function is of the form: prependProperty
            </summary>
        </member>
        <member name="M:TED.Language.Function``1(System.String,System.Func{``0},System.Boolean)">
            <summary>
            Makes a function that can be placed in functional expressions
            </summary>
            <param name="name">Name, for debugging purposes</param>
            <param name="fn">C# code implementing the function</param>
            <param name="isPure">True (default) if this function has no state or side effects</param>
        </member>
        <member name="M:TED.Language.Method``1(System.Func{``0},System.Boolean)">
            <summary>
            Makes a Function with the same name as the Func being passed in
            </summary>
        </member>
        <member name="M:TED.Language.Function``2(System.String,System.Func{``0,``1},System.Boolean)">
            <summary>
            Makes a function that can be placed in functional expressions
            </summary>
            <param name="name">Name, for debugging purposes</param>
            <param name="fn">C# code implementing the function</param>
            <param name="isPure">True (default) if this function has no state or side effects</param>
        </member>
        <member name="M:TED.Language.Method``2(System.Func{``0,``1},System.Boolean)">
            <summary>
            Makes a Function with the same name as the Func being passed in
            </summary>
        </member>
        <member name="M:TED.Language.Function``3(System.String,System.Func{``0,``1,``2},System.Boolean)">
            <summary>
            Makes a function that can be placed in functional expressions
            </summary>
            <param name="name">Name, for debugging purposes</param>
            <param name="fn">C# code implementing the function</param>
            <param name="isPure">True (default) if this function has no state or side effects</param>
        </member>
        <member name="M:TED.Language.Method``3(System.Func{``0,``1,``2},System.Boolean)">
            <summary>
            Makes a Function with the same name as the Func being passed in
            </summary>
        </member>
        <member name="M:TED.Language.Function``4(System.String,System.Func{``0,``1,``2,``3},System.Boolean)">
            <summary>
            Makes a function that can be placed in functional expressions
            </summary>
            <param name="name">Name, for debugging purposes</param>
            <param name="fn">C# code implementing the function</param>
            <param name="isPure">True (default) if this function has no state or side effects</param>
        </member>
        <member name="M:TED.Language.Method``4(System.Func{``0,``1,``2,``3},System.Boolean)">
            <summary>
            Makes a Function with the same name as the Func being passed in
            </summary>
        </member>
        <member name="M:TED.Language.Function``5(System.String,System.Func{``0,``1,``2,``3,``4},System.Boolean)">
            <summary>
            Makes a function that can be placed in functional expressions
            </summary>
            <param name="name">Name, for debugging purposes</param>
            <param name="fn">C# code implementing the function</param>
            <param name="isPure">True (default) if this function has no state or side effects</param>
        </member>
        <member name="M:TED.Language.Method``5(System.Func{``0,``1,``2,``3,``4},System.Boolean)">
            <summary>
            Makes a Function with the same name as the Func being passed in
            </summary>
        </member>
        <member name="M:TED.Language.Function``6(System.String,System.Func{``0,``1,``2,``3,``4,``5},System.Boolean)">
            <summary>
            Makes a function that can be placed in functional expressions
            </summary>
            <param name="name">Name, for debugging purposes</param>
            <param name="fn">C# code implementing the function</param>
            <param name="isPure">True (default) if this function has no state or side effects</param>
        </member>
        <member name="M:TED.Language.Method``6(System.Func{``0,``1,``2,``3,``4,``5},System.Boolean)">
            <summary>
            Makes a Function with the same name as the Func being passed in
            </summary>
        </member>
        <member name="M:TED.Language.Function``7(System.String,System.Func{``0,``1,``2,``3,``4,``5,``6},System.Boolean)">
            <summary>
            Makes a function that can be placed in functional expressions
            </summary>
            <param name="name">Name, for debugging purposes</param>
            <param name="fn">C# code implementing the function</param>
            <param name="isPure">True (default) if this function has no state or side effects</param>
        </member>
        <member name="M:TED.Language.Method``7(System.Func{``0,``1,``2,``3,``4,``5,``6},System.Boolean)">
            <summary>
            Makes a Function with the same name as the Func being passed in
            </summary>
        </member>
        <member name="M:TED.Language.Function``8(System.String,System.Func{``0,``1,``2,``3,``4,``5,``6,``7},System.Boolean)">
            <summary>
            Makes a function that can be placed in functional expressions
            </summary>
            <param name="name">Name, for debugging purposes</param>
            <param name="fn">C# code implementing the function</param>
            <param name="isPure">True (default) if this function has no state or side effects</param>
        </member>
        <member name="M:TED.Language.Method``8(System.Func{``0,``1,``2,``3,``4,``5,``6,``7},System.Boolean)">
            <summary>
            Makes a Function with the same name as the Func being passed in
            </summary>
        </member>
        <member name="M:TED.Language.AssignToVar``2(TED.Var{``1},TED.Function{``0,``1},TED.Term{``0})">
            <summary>
            Assigns the input variable to the result of calling func with input
            </summary>
        </member>
        <member name="M:TED.Language.AssignToVar``2(TED.Var{``1},TED.Function{``0,``1},TED.Var{``0},System.String)">
            <summary>
            Create a definition that assigns the variable var to the output of func with input as input
            </summary>
        </member>
        <member name="M:TED.Language.RowVariable``2(TED.TablePredicate{``0,``1},System.String)">
            <summary>
            Create a Var of type ValueTuple with the same types as those in the TablePredicate, using name
            or predicate.Name + Row of name is left null
            </summary>
        </member>
        <member name="M:TED.Language.RowVariable``3(TED.TablePredicate{``0,``1,``2},System.String)">
            <inheritdoc cref="M:TED.Language.RowVariable``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.RowVariable``4(TED.TablePredicate{``0,``1,``2,``3},System.String)">
            <inheritdoc cref="M:TED.Language.RowVariable``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.RowVariable``5(TED.TablePredicate{``0,``1,``2,``3,``4},System.String)">
            <inheritdoc cref="M:TED.Language.RowVariable``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.RowVariable``6(TED.TablePredicate{``0,``1,``2,``3,``4,``5},System.String)">
            <inheritdoc cref="M:TED.Language.RowVariable``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.RowVariable``7(TED.TablePredicate{``0,``1,``2,``3,``4,``5,``6},System.String)">
            <inheritdoc cref="M:TED.Language.RowVariable``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.RowVariable``8(TED.TablePredicate{``0,``1,``2,``3,``4,``5,``6,``7},System.String)">
            <inheritdoc cref="M:TED.Language.RowVariable``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.Item1``2(TED.TablePredicate{``0,``1},System.String)">
            <summary>
            Makes a function that gets `.Item#` from the passed in ValueTuple (where the tuple is the same
            type as a row in predicate). Can be given better name than Item#
            </summary>
        </member>
        <member name="M:TED.Language.Item1``2(TED.Var{``0},TED.TablePredicate{``0,``1})">
            <summary>
            Makes a Definition that assigns the value of the .Item# Function called on a row from the predicate to
            the variable var. Uses default names for the Function, Row Variable, and Definition.
            </summary>
        </member>
        <member name="M:TED.Language.Item1``3(TED.TablePredicate{``0,``1,``2},System.String)">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.Item1``3(TED.Var{``0},TED.TablePredicate{``0,``1,``2})">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.Var{``0},TED.TablePredicate{``0,``1})"/>
        </member>
        <member name="M:TED.Language.Item1``4(TED.TablePredicate{``0,``1,``2,``3},System.String)">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.Item1``4(TED.Var{``0},TED.TablePredicate{``0,``1,``2,``3})">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.Var{``0},TED.TablePredicate{``0,``1})"/>
        </member>
        <member name="M:TED.Language.Item1``5(TED.TablePredicate{``0,``1,``2,``3,``4},System.String)">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.Item1``5(TED.Var{``0},TED.TablePredicate{``0,``1,``2,``3,``4})">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.Var{``0},TED.TablePredicate{``0,``1})"/>
        </member>
        <member name="M:TED.Language.Item1``6(TED.TablePredicate{``0,``1,``2,``3,``4,``5},System.String)">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.Item1``6(TED.Var{``0},TED.TablePredicate{``0,``1,``2,``3,``4,``5})">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.Var{``0},TED.TablePredicate{``0,``1})"/>
        </member>
        <member name="M:TED.Language.Item1``7(TED.TablePredicate{``0,``1,``2,``3,``4,``5,``6},System.String)">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.Item1``7(TED.Var{``0},TED.TablePredicate{``0,``1,``2,``3,``4,``5,``6})">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.Var{``0},TED.TablePredicate{``0,``1})"/>
        </member>
        <member name="M:TED.Language.Item1``8(TED.TablePredicate{``0,``1,``2,``3,``4,``5,``6,``7},System.String)">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.Item1``8(TED.Var{``0},TED.TablePredicate{``0,``1,``2,``3,``4,``5,``6,``7})">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.Var{``0},TED.TablePredicate{``0,``1})"/>
        </member>
        <member name="M:TED.Language.Item2``2(TED.TablePredicate{``0,``1},System.String)">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.Item2``2(TED.Var{``1},TED.TablePredicate{``0,``1})">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.Var{``0},TED.TablePredicate{``0,``1})"/>
        </member>
        <member name="M:TED.Language.Item2``3(TED.TablePredicate{``0,``1,``2},System.String)">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.Item2``3(TED.Var{``1},TED.TablePredicate{``0,``1,``2})">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.Var{``0},TED.TablePredicate{``0,``1})"/>
        </member>
        <member name="M:TED.Language.Item2``4(TED.TablePredicate{``0,``1,``2,``3},System.String)">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.Item2``4(TED.Var{``1},TED.TablePredicate{``0,``1,``2,``3})">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.Var{``0},TED.TablePredicate{``0,``1})"/>
        </member>
        <member name="M:TED.Language.Item2``5(TED.TablePredicate{``0,``1,``2,``3,``4},System.String)">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.Item2``5(TED.Var{``1},TED.TablePredicate{``0,``1,``2,``3,``4})">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.Var{``0},TED.TablePredicate{``0,``1})"/>
        </member>
        <member name="M:TED.Language.Item2``6(TED.TablePredicate{``0,``1,``2,``3,``4,``5},System.String)">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.Item2``6(TED.Var{``1},TED.TablePredicate{``0,``1,``2,``3,``4,``5})">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.Var{``0},TED.TablePredicate{``0,``1})"/>
        </member>
        <member name="M:TED.Language.Item2``7(TED.TablePredicate{``0,``1,``2,``3,``4,``5,``6},System.String)">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.Item2``7(TED.Var{``1},TED.TablePredicate{``0,``1,``2,``3,``4,``5,``6})">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.Var{``0},TED.TablePredicate{``0,``1})"/>
        </member>
        <member name="M:TED.Language.Item2``8(TED.TablePredicate{``0,``1,``2,``3,``4,``5,``6,``7},System.String)">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.Item2``8(TED.Var{``1},TED.TablePredicate{``0,``1,``2,``3,``4,``5,``6,``7})">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.Var{``0},TED.TablePredicate{``0,``1})"/>
        </member>
        <member name="M:TED.Language.Item3``3(TED.TablePredicate{``0,``1,``2},System.String)">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.Item3``3(TED.Var{``2},TED.TablePredicate{``0,``1,``2})">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.Var{``0},TED.TablePredicate{``0,``1})"/>
        </member>
        <member name="M:TED.Language.Item3``4(TED.TablePredicate{``0,``1,``2,``3},System.String)">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.Item3``4(TED.Var{``2},TED.TablePredicate{``0,``1,``2,``3})">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.Var{``0},TED.TablePredicate{``0,``1})"/>
        </member>
        <member name="M:TED.Language.Item3``5(TED.TablePredicate{``0,``1,``2,``3,``4},System.String)">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.Item3``5(TED.Var{``2},TED.TablePredicate{``0,``1,``2,``3,``4})">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.Var{``0},TED.TablePredicate{``0,``1})"/>
        </member>
        <member name="M:TED.Language.Item3``6(TED.TablePredicate{``0,``1,``2,``3,``4,``5},System.String)">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.Item3``6(TED.Var{``2},TED.TablePredicate{``0,``1,``2,``3,``4,``5})">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.Var{``0},TED.TablePredicate{``0,``1})"/>
        </member>
        <member name="M:TED.Language.Item3``7(TED.TablePredicate{``0,``1,``2,``3,``4,``5,``6},System.String)">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.Item3``7(TED.Var{``2},TED.TablePredicate{``0,``1,``2,``3,``4,``5,``6})">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.Var{``0},TED.TablePredicate{``0,``1})"/>
        </member>
        <member name="M:TED.Language.Item3``8(TED.TablePredicate{``0,``1,``2,``3,``4,``5,``6,``7},System.String)">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.Item3``8(TED.Var{``2},TED.TablePredicate{``0,``1,``2,``3,``4,``5,``6,``7})">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.Var{``0},TED.TablePredicate{``0,``1})"/>
        </member>
        <member name="M:TED.Language.Item4``4(TED.TablePredicate{``0,``1,``2,``3},System.String)">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.Item4``4(TED.Var{``3},TED.TablePredicate{``0,``1,``2,``3})">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.Var{``0},TED.TablePredicate{``0,``1})"/>
        </member>
        <member name="M:TED.Language.Item4``5(TED.TablePredicate{``0,``1,``2,``3,``4},System.String)">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.Item4``5(TED.Var{``3},TED.TablePredicate{``0,``1,``2,``3,``4})">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.Var{``0},TED.TablePredicate{``0,``1})"/>
        </member>
        <member name="M:TED.Language.Item4``6(TED.TablePredicate{``0,``1,``2,``3,``4,``5},System.String)">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.Item4``6(TED.Var{``3},TED.TablePredicate{``0,``1,``2,``3,``4,``5})">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.Var{``0},TED.TablePredicate{``0,``1})"/>
        </member>
        <member name="M:TED.Language.Item4``7(TED.TablePredicate{``0,``1,``2,``3,``4,``5,``6},System.String)">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.Item4``7(TED.Var{``3},TED.TablePredicate{``0,``1,``2,``3,``4,``5,``6})">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.Var{``0},TED.TablePredicate{``0,``1})"/>
        </member>
        <member name="M:TED.Language.Item4``8(TED.TablePredicate{``0,``1,``2,``3,``4,``5,``6,``7},System.String)">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.Item4``8(TED.Var{``3},TED.TablePredicate{``0,``1,``2,``3,``4,``5,``6,``7})">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.Var{``0},TED.TablePredicate{``0,``1})"/>
        </member>
        <member name="M:TED.Language.Item5``5(TED.TablePredicate{``0,``1,``2,``3,``4},System.String)">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.Item5``5(TED.Var{``4},TED.TablePredicate{``0,``1,``2,``3,``4})">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.Var{``0},TED.TablePredicate{``0,``1})"/>
        </member>
        <member name="M:TED.Language.Item5``6(TED.TablePredicate{``0,``1,``2,``3,``4,``5},System.String)">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.Item5``6(TED.Var{``4},TED.TablePredicate{``0,``1,``2,``3,``4,``5})">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.Var{``0},TED.TablePredicate{``0,``1})"/>
        </member>
        <member name="M:TED.Language.Item5``7(TED.TablePredicate{``0,``1,``2,``3,``4,``5,``6},System.String)">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.Item5``7(TED.Var{``4},TED.TablePredicate{``0,``1,``2,``3,``4,``5,``6})">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.Var{``0},TED.TablePredicate{``0,``1})"/>
        </member>
        <member name="M:TED.Language.Item5``8(TED.TablePredicate{``0,``1,``2,``3,``4,``5,``6,``7},System.String)">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.Item5``8(TED.Var{``4},TED.TablePredicate{``0,``1,``2,``3,``4,``5,``6,``7})">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.Var{``0},TED.TablePredicate{``0,``1})"/>
        </member>
        <member name="M:TED.Language.Item6``6(TED.TablePredicate{``0,``1,``2,``3,``4,``5},System.String)">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.Item6``6(TED.Var{``5},TED.TablePredicate{``0,``1,``2,``3,``4,``5})">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.Var{``0},TED.TablePredicate{``0,``1})"/>
        </member>
        <member name="M:TED.Language.Item6``7(TED.TablePredicate{``0,``1,``2,``3,``4,``5,``6},System.String)">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.Item6``7(TED.Var{``5},TED.TablePredicate{``0,``1,``2,``3,``4,``5,``6})">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.Var{``0},TED.TablePredicate{``0,``1})"/>
        </member>
        <member name="M:TED.Language.Item6``8(TED.TablePredicate{``0,``1,``2,``3,``4,``5,``6,``7},System.String)">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.Item6``8(TED.Var{``5},TED.TablePredicate{``0,``1,``2,``3,``4,``5,``6,``7})">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.Var{``0},TED.TablePredicate{``0,``1})"/>
        </member>
        <member name="M:TED.Language.Item7``7(TED.TablePredicate{``0,``1,``2,``3,``4,``5,``6},System.String)">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.Item7``7(TED.Var{``6},TED.TablePredicate{``0,``1,``2,``3,``4,``5,``6})">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.Var{``0},TED.TablePredicate{``0,``1})"/>
        </member>
        <member name="M:TED.Language.Item7``8(TED.TablePredicate{``0,``1,``2,``3,``4,``5,``6,``7},System.String)">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.Item7``8(TED.Var{``6},TED.TablePredicate{``0,``1,``2,``3,``4,``5,``6,``7})">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.Var{``0},TED.TablePredicate{``0,``1})"/>
        </member>
        <member name="M:TED.Language.Item8``8(TED.TablePredicate{``0,``1,``2,``3,``4,``5,``6,``7},System.String)">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.TablePredicate{``0,``1},System.String)"/>
        </member>
        <member name="M:TED.Language.Item8``8(TED.Var{``7},TED.TablePredicate{``0,``1,``2,``3,``4,``5,``6,``7})">
            <inheritdoc cref="M:TED.Language.Item1``2(TED.Var{``0},TED.TablePredicate{``0,``1})"/>
        </member>
        <member name="M:TED.Language.CountsBy``1(System.String,TED.TablePredicate,TED.Var{``0},TED.Var{System.Int32})">
            <summary>Make a pivot table containing the number of rows for each value of column.</summary>
            <param name="name">Name to give to the table.</param>
            <param name="t">TablePredicate to construct the pivot table for.</param>
            <param name="column">Column to find counts of. Must be indexed.</param>
            <param name="count">Name to give to the count column in the output.</param>
            <typeparam name="TColumn"></typeparam>
            <returns></returns>
            <exception cref="T:System.InvalidOperationException"></exception>
        </member>
        <member name="M:TED.Language.AssignRandomly``2(System.String,TED.TablePredicate{``0,``1})">
            <summary>
            Generate a random subset of the candidate pairs such that each item from the first column
            appears exactly once. Does not guarantee that the same item from the second column won't
            be assigned to two different items from the first column.
            </summary>
            <param name="name">Name for the table of assignments.</param>
            <param name="candidates">Table of candidate pairs. Must be indexed on the first column.</param>
            <typeparam name="T1">Type of the first column of the table</typeparam>
            <typeparam name="T2">Type of the second column of the table</typeparam>
            <returns>Table of random assignments</returns>
            <exception cref="T:System.InvalidOperationException">If candidates table is not indexed.</exception>
        </member>
        <member name="M:TED.Language.AssignGreedily``2(System.String,TED.TablePredicate{``0,``1,System.Single})">
            <summary>
            Generate a subset of the candidate pairs that maximizes utility without using any T1 or T2 twice.
            Does not guarantee that all T1s or T2s get paired up or that it's a best assignment.
            </summary>
            <param name="name">Name for the table of assignments.</param>
            <param name="candidates">Table of candidate pairs and their utility.</param>
            <typeparam name="T1">Type of the first column of the table</typeparam>
            <typeparam name="T2">Type of the second column of the table</typeparam>
            <returns>Table of assignments</returns>
        </member>
        <member name="M:TED.Language.AssignGreedily``2(System.String,TED.TablePredicate{``0,``1,System.Int32})">
            <summary>
            Generate a subset of the candidate pairs that maximizes utility without using any T1 or T2 twice.
            Does not guarantee that all T1s or T2s get paired up or that it's a best assignment.
            </summary>
            <param name="name">Name for the table of assignments.</param>
            <param name="candidates">Table of candidate pairs and their utility.</param>
            <typeparam name="T1">Type of the first column of the table</typeparam>
            <typeparam name="T2">Type of the second column of the table</typeparam>
            <returns>Table of assignments</returns>
        </member>
        <member name="M:TED.Language.AssignGreedily``2(System.String,TED.TablePredicate{``0,``1,System.Single},TED.TablePredicate{``1,System.Int32})">
            <summary>
            Generate a subset of the candidate pairs that maximizes utility without assigning T1s to a given T2 more than
            the capacity for that T2. Does not guarantee that all T1s or T2s get paired up or that it's a best assignment.
            </summary>
            <param name="name">Name for the table of assignments.</param>
            <param name="candidates">Table of candidate pairs and their utility.</param>
            <param name="capacities">Table of T2s and the number of T1s that can be assigned to each.</param>
            <typeparam name="T1">Type of the first column of the table</typeparam>
            <typeparam name="T2">Type of the second column of the table</typeparam>
            <returns>Table of assignments</returns>
        </member>
        <member name="M:TED.Language.AssignGreedily``2(System.String,TED.TablePredicate{``0,``1,System.Int32},TED.TablePredicate{``1,System.Int32})">
            <summary>
            Generate a subset of the candidate pairs that maximizes utility without assigning T1s to a given T2 more than
            the capacity for that T2. Does not guarantee that all T1s or T2s get paired up or that it's a best assignment.
            </summary>
            <param name="name">Name for the table of assignments.</param>
            <param name="candidates">Table of candidate pairs and their utility.</param>
            <param name="capacities">Table of T2s and the number of T1s that can be assigned to each.</param>
            <typeparam name="T1">Type of the first column of the table</typeparam>
            <typeparam name="T2">Type of the second column of the table</typeparam>
            <returns>Table of assignments</returns>
        </member>
        <member name="M:TED.Language.MatchGreedily``1(System.String,TED.TablePredicate{``0,``0,System.Single})">
            <summary>
            Generate a subset of the candidate pairs that maximizes utility without using any T1 twice.
            </summary>
            <param name="name">Name for the table of assignments.</param>
            <param name="candidates">Table of candidate pairs.</param>
            <typeparam name="T">Type of the first and second column of the table</typeparam>
            <returns>Table of assignments</returns>
        </member>
        <member name="M:TED.Language.MatchGreedily``1(System.String,TED.TablePredicate{``0,``0,System.Int32})">
            <summary>
            Generate a subset of the candidate pairs that maximizes utility without using any T1 twice.
            </summary>
            <param name="name">Name for the table of assignments.</param>
            <param name="candidates">Table of candidate pairs.</param>
            <typeparam name="T">Type of the first and second column of the table</typeparam>
            <returns>Table of assignments</returns>
        </member>
        <member name="M:TED.Language.MatchGreedilyAsymmetric``1(System.String,TED.TablePredicate{``0,``0,System.Single})">
            <summary>
            Generate a subset of the candidate pairs that maximizes utility without using any T1 twice in the first column.
            </summary>
            <param name="name">Name for the table of assignments.</param>
            <param name="candidates">Table of candidate pairs.</param>
            <typeparam name="T">Type of the first and second column of the table</typeparam>
            <returns>Table of assignments</returns>
        </member>
        <member name="M:TED.Language.MatchGreedilyAsymmetric``1(System.String,TED.TablePredicate{``0,``0,System.Int32})">
            <summary>
            Generate a subset of the candidate pairs that maximizes utility without using any T1 twice in the first column.
            </summary>
            <param name="name">Name for the table of assignments.</param>
            <param name="candidates">Table of candidate pairs.</param>
            <typeparam name="T">Type of the first and second column of the table</typeparam>
            <returns>Table of assignments</returns>
        </member>
        <member name="M:TED.Language.Closure``1(System.String,TED.TablePredicate{``0,``0},System.Boolean)">
            <summary>
            Returns the a new table predicate holding the transitive closure of the input.
            This is equivalent to reachability in a graph.  Note that this is not the symmetric transitive
            closure; the output is directional.
            WARNING: the size of the output is O(n^2).
            </summary>
            <param name="name">Name to give to the output table</param>
            <param name="predicate">Relation to take the closure of</param>
            <param name="reflexive">Whether the closure should be reflexive, i.e. whether closure(term,term) should be true when term is in the original predicate</param>
            <typeparam name="T">Type of the arguments to the predicate</typeparam>
            <returns>New predicate that is the closure</returns>
            <exception cref="T:System.InvalidOperationException">If input predicate is not indexed on the first argument</exception>
        </member>
        <member name="T:TED.Predicate">
            <summary>
            Untyped base class for all predicates
            Predicates are either TablePredicates or PrimitivePredicates
            TablePredicates are backed by an explicit table containing the extension of the predicate
            - These can either be "extensional predicates", where you manually specify the data for the table
            - or "intensional predicates", where you specify rules for the computing the extension from
            - the extensions of other predicates
            </summary>
        </member>
        <member name="F:TED.Predicate.Name">
            <summary>
            Human-readable name for this predicate
            </summary>
        </member>
        <member name="M:TED.Predicate.#ctor(System.String)">
            <summary>
            Make a new predicate
            </summary>
        </member>
        <member name="P:TED.Predicate.IsPure">
            <summary>
            True if the predicate is a table predicate or is a primitive that acts as a pure function,
            i.e. it always has the same result for the same inputs and has no side-effects.
            </summary>
        </member>
        <member name="T:TED.Preprocessing.GoalAnalyzer">
            <summary>
            Keeps the state involved in scanning the body of a rule:
            - What TablePredicates does this rule depend on (reference)
            - What variables appear in the rule?
            - What ValueCells do they correspond to?
            - Have they been bound by some previous goal yet?
            </summary>
        </member>
        <member name="M:TED.Preprocessing.GoalAnalyzer.MakeChild">
            <summary>
            Makes a goal analyzer identical to this one, except that any subsequent value cells won't be added to this analyzer
            Dependencies will be added, however.
            </summary>
        </member>
        <member name="F:TED.Preprocessing.GoalAnalyzer.variableValueCells">
            <summary>
            Maps Var objects, which are the abstract syntax tree representation for a TED variable,
            to ValueCell objects, which are the containers used to hold the variable's value at run-time.
            The key type of the dictionary is AnyTerm just because Var is a generic type, it's parent, Term
            is also a generic type, and so AnyTerm is the most immediate ancestor that's a parent to all Vars.
            </summary>
        </member>
        <member name="F:TED.Preprocessing.GoalAnalyzer.BoundVariables">
            <summary>
            Variables that are currently bound to values
            </summary>
        </member>
        <member name="M:TED.Preprocessing.GoalAnalyzer.AddDependency(TED.TablePredicate)">
            <summary>
            Note that the rule being processed depends on (reads from) the specified table predicate
            and so must run after that table predicate has been updated.
            </summary>
        </member>
        <member name="P:TED.Preprocessing.GoalAnalyzer.Dependencies">
            <summary>
            All the TablePredicates that the rule calls.
            The update system needs to know this so it can insure those tables are updated before this rule is called.
            </summary>
        </member>
        <member name="M:TED.Preprocessing.GoalAnalyzer.Emit``1(TED.Term{``0})">
            <summary>
            Generate a MatchOperation for the specified term, updating variableValueCells as needed.
            </summary>
            <typeparam name="T">Type of the term</typeparam>
            <param name="term">The term</param>
            <returns>A MatchOperation with the right opcode (read, write, or constant) and ValueCell to match this argument to this call.</returns>
            <exception cref="T:System.InvalidOperationException">If this is a term that can't be used as an argument</exception>
        </member>
        <member name="M:TED.Preprocessing.GoalAnalyzer.MakeWrite``1(TED.Var{``0})">
            <summary>
            Forcibly make a MatchOperation that will write v, even when v is already instantiated.
            Used for iteration constructs like Maximize.
            </summary>
        </member>
        <member name="M:TED.Preprocessing.GoalAnalyzer.VariableValueCells">
            <summary>
            ValueCells for all the variables in the rule
            </summary>
        </member>
        <member name="M:TED.Preprocessing.GoalAnalyzer.IsInstantiated(TED.Term)">
            <summary>
            True if subsequent uses of this variable will be match to the value in the cell rather than store into it.
            </summary>
        </member>
        <member name="T:TED.Preprocessing.Preprocessor">
             <summary>
             Implements mapping of sequences of Goals (abstract syntax trees) to sequences of Calls (the internal
             representation/implementation of the calls).
            
             This process involves
             - Expanding calls to definitions
             - Hoisting functional expressions from calls: P(x+1) is transformed to Eval(temp, x+1), P(temp)
             - Analyzing which uses of variables are first uses (which bind) or subsequent uses (which match)
             </summary>
        </member>
        <member name="M:TED.Preprocessing.Preprocessor.CanonicalizeGoals(System.Collections.Generic.IEnumerable{TED.Interpreter.Goal},System.Boolean)">
            <summary>
            Reduce a series of goals to a different series in canonical form.
            Canonical form contains no calls to Definitions, no calls to True or False,
            and has FunctionalExpressions only as arguments to Eval.
            </summary>
        </member>
        <member name="M:TED.Preprocessing.Preprocessor.GenerateCalls(TED.Preprocessing.GoalAnalyzer,TED.Interpreter.Goal[])">
            <summary>
            Generate a series of Call objects for a body.
            </summary>
        </member>
        <member name="M:TED.Preprocessing.Preprocessor.BodyToCall(TED.Preprocessing.GoalAnalyzer,TED.Interpreter.Goal[])">
            <summary>
            Generate a single Call object that will run the goals in body.  The GoalAnalyzer will retain
            any bindings (first uses of variables) in the body.  And when executed, those variables will
            have whatever values they acquire in the body.
            
            If the canonical form of body has only a single goal, then this will just be the call for the goal,
            otherwise it will be a call to And.
            </summary>
        </member>
        <member name="M:TED.Preprocessing.Preprocessor.BodyToCallWithLocalBindings(TED.Preprocessing.GoalAnalyzer,TED.Interpreter.Goal[])">
            <summary>
            Generate a single Call object that will run the goals in body.  The GoalAnalyzer will not retain any
            bindings generated in the body.  That is, if there are any first uses of variables in the body, that
            will lead those variables to acquire values, those values will be thrown away afterward and the system
            will treat those variables as unbound after the body is executed.
            
            If the canonical form of body has only a single goal, then this will just be the call for the goal,
            otherwise it will be a call to And.
            </summary>
        </member>
        <member name="M:TED.Preprocessing.Preprocessor.ExpandDefinitions(TED.Interpreter.Goal)">
            <summary>
            If the goal is a call to a definition, return its expansion.  Otherwise, return the original goal.
            </summary>
            <param name="g">Goal to expand</param>
        </member>
        <member name="M:TED.Preprocessing.Preprocessor.ExpandDefinitions(System.Collections.Generic.IEnumerable{TED.Interpreter.Goal})">
            <summary>
            Expand any calls to definitions inside the body
            </summary>
            <param name="body">Sequence of Goals, some of which may be to Definitions</param>
            <returns>Expanded form with any calls to Definitions replaced with their expansions.</returns>
        </member>
        <member name="M:TED.Preprocessing.Preprocessor.FunctionalExpressions(TED.Interpreter.Goal)">
            <summary>
            The arguments of the goal that happen to be functional expressions.
            </summary>
        </member>
        <member name="M:TED.Preprocessing.Preprocessor.HoistFunctionalExpressions(TED.Interpreter.Goal)">
            <summary>
            Replace any calls to functional expressions in the Goal with temporary variables and prepend the
            transformed version with calls to Eval to bind the temporary variables with function expressions.
            Thus:
            - P(x,y) is unchanged; it maps to P(x,y)
            - P(x+1,y) is mapped to: Eval(t, x+1), P(t,y)
            </summary>
        </member>
        <member name="T:TED.Preprocessing.Substitution">
            <summary>
            Represents a substitution of terms for other terms.
            Used for expanding the bodies of Definitions (replacing formal vars with actual arguments)
            and hoisting functional expressions (replacing FEs with temp vars)
            </summary>
        </member>
        <member name="F:TED.Preprocessing.Substitution.AlphaConvert">
            <summary>
            If true, all variables not otherwise substituted should be substituted with copies of themselves.
            </summary>
        </member>
        <member name="M:TED.Preprocessing.Substitution.SubstituteVariable``1(TED.Var{``0})">
            <summary>
            Apply substitution to a variable, returning the variable it's mapped to or the original variable.
            </summary>
        </member>
        <member name="T:TED.Primitives.AggregateFunctionCall`1">
            <summary>
            Implements functions that aggregate over all the solutions of a query, such as Sum or Count.
            </summary>
        </member>
        <member name="F:TED.Primitives.AggregateFunctionCall`1.InitialValue">
            <summary>
            Starting value for the accumulator
            </summary>
        </member>
        <member name="F:TED.Primitives.AggregateFunctionCall`1.Aggregator">
            <summary>
            Function used to add a new value to the accumulator
            </summary>
        </member>
        <member name="F:TED.Primitives.AggregateFunctionCall`1.Generator">
            <summary>
            Goal that generates values for the AggregationTerm
            </summary>
        </member>
        <member name="F:TED.Primitives.AggregateFunctionCall`1.AggregationTerm">
            <summary>
            Term to be aggregated (summed, multiplied, etc.) over the solutions to the Generator.
            </summary>
        </member>
        <member name="M:TED.Primitives.AggregateFunctionCall`1.#ctor(TED.Interpreter.Goal,TED.Term{`0},`0,System.Func{`0,`0,`0},System.Func{System.String,System.String,System.String})">
            <summary>
            Make a new function that aggregates over all the solutions to a goal.
            After exit from the function, any variables bound within the goal are left unbound.
            If the goal is P[x] and x is the aggregation term, then it will find all the x's from all
            the solutions to P[x], and return aggregator(aggregator(aggregator(initialValue, x1), x2), x3) ...
            </summary>
            <param name="generator">Goal to find solutions to</param>
            <param name="aggregationTerm">Value to take from each solution; the values from all solutions will be aggregated together</param>
            <param name="initialValue">Initial value to start from when aggregating</param>
            <param name="aggregator">C# function mapping two values to an aggregate value</param>
            <param name="compiler">Generates c# text for a new value of the accumulator from the text for the accumulator and the most recent result from the goal</param>
        </member>
        <member name="M:TED.Primitives.AggregateFunctionCall`1.MakeEvaluator(TED.Preprocessing.GoalAnalyzer)">
            <inheritdoc />
        </member>
        <member name="T:TED.Primitives.AndPrimitive">
            <summary>
            Implements conjunctions as a primitive predicate.  That is, And[g1, g2, ...] is true when all the gi are true.
            Procedurally, this means find solutions to g1, then g2, etc., backtracking in the normal manner.
            </summary>
        </member>
        <member name="F:TED.Primitives.AndPrimitive.Singleton">
            <summary>
            The And primitive itself
            </summary>
        </member>
        <member name="P:TED.Primitives.AndPrimitive.Item(TED.Interpreter.Goal[])">
            <summary>
            True when all the subgoals are true
            </summary>
        </member>
        <member name="T:TED.Primitives.AssertBindingStatePrimitive`1">
            <summary>
            Pseudo-primitive that checks the binding state of its argument and throws if it isn't the expected state.
            Does nothing if it is of the expected state.
            </summary>
        </member>
        <member name="T:TED.Primitives.BinaryArithmeticOperator`1">
            <summary>
            Wrapper for C# binary operators (e.g. +, *, %, etc.) as TEDFunctions.
            </summary>
        </member>
        <member name="T:TED.Primitives.ComparisonPrimitive`1">
            <summary>
            Wrapper for C# comparison operators for some type.
            </summary>
        </member>
        <member name="T:TED.Primitives.IEvalPrimitive">
            <summary>
            Just a type tag so we can test whether something is a EvalPrimitive
            </summary>
        </member>
        <member name="T:TED.Primitives.EvalPrimitive`1">
            <summary>
            Implements evaluation of a functional expression and matching/storing it to a variable
            </summary>
        </member>
        <member name="P:TED.Primitives.EvalPrimitive`1.EvalCall.IsPure">
            <inheritdoc />
        </member>
        <member name="T:TED.Primitives.FirstOfPrimitive">
            <summary>
            Succeeds with the first goal of the 
            </summary>
        </member>
        <member name="F:TED.Primitives.FirstOfPrimitive.Singleton">
            <summary>
            The And primitive itself
            </summary>
        </member>
        <member name="P:TED.Primitives.FirstOfPrimitive.Item(TED.Interpreter.Goal[])">
            <summary>
            True when all the subgoals are true
            </summary>
        </member>
        <member name="T:TED.Primitives.InPrimitive`1">
            <summary>
            Implementation of the typed In(element, collection) primitive 
            </summary>
            <typeparam name="T">Element type of the collection</typeparam>
        </member>
        <member name="T:TED.Primitives.MaximalPrimitive`2">
            <summary>
            Implements Maximal and Minimal Primitives with one argument to check against
            </summary>
        </member>
        <member name="T:TED.Primitives.MaximalPrimitive`3">
            <summary>
            Implements Maximal and Minimal Primitives with two arguments to check against
            </summary>
        </member>
        <member name="T:TED.Primitives.MaximalPrimitive`4">
            <summary>
            Implements Maximal and Minimal Primitives with three arguments to check against
            </summary>
        </member>
        <member name="T:TED.Primitives.NotPrimitive">
            <summary>
            Implements negation of a goal
            </summary>
        </member>
        <member name="F:TED.Primitives.NotPrimitive.Singleton">
            <summary>
            The object implementing Not
            </summary>
        </member>
        <member name="M:TED.Primitives.NotPrimitive.MakeCall(TED.Primitives.PrimitivePredicate{TED.Interpreter.Goal}.Goal,TED.Preprocessing.GoalAnalyzer)">
            <inheritdoc />
        </member>
        <member name="T:TED.Primitives.OncePrimitive">
            <summary>
            Implements negation of a goal
            </summary>
        </member>
        <member name="F:TED.Primitives.OncePrimitive.Singleton">
            <summary>
            The object implementing Not
            </summary>
        </member>
        <member name="M:TED.Primitives.OncePrimitive.MakeCall(TED.Primitives.PrimitivePredicate{TED.Interpreter.Goal}.Goal,TED.Preprocessing.GoalAnalyzer)">
            <inheritdoc />
        </member>
        <member name="T:TED.Primitives.OrPrimitive">
            <summary>
            Implements conjunctions as a primitive predicate.  That is, And[g1, g2, ...] is true when all the gi are true.
            Procedurally, this means find solutions to g1, then g2, etc., backtracking in the normal manner.
            </summary>
        </member>
        <member name="F:TED.Primitives.OrPrimitive.Singleton">
            <summary>
            The And primitive itself
            </summary>
        </member>
        <member name="P:TED.Primitives.OrPrimitive.Item(TED.Interpreter.Goal[])">
            <summary>
            True when all the subgoals are true
            </summary>
        </member>
        <member name="P:TED.Primitives.PickRandomlyPrimitive`1.IsPure">
            <summary>
            Randomization does not behave like a pure predicate
            </summary>
        </member>
        <member name="T:TED.Primitives.PrimitivePredicate">
            <summary>
            A primitive predicate (one computed by code rather than matching to a table) with no arguments
            </summary>
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate.#ctor(System.String)">
            <summary>
            Make a primitive predicate with the specified name
            </summary>
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate.op_Implicit(TED.Primitives.PrimitivePredicate)~TED.Interpreter.Goal">
            <summary>
            Return a goal representing a call to this primitive.
            </summary>
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate.MakeCall(TED.Primitives.PrimitivePredicate.Goal,TED.Preprocessing.GoalAnalyzer)">
            <summary>
            Map a Goal (AST for call) to a Call object (the internal form used by the interpreter)
            </summary>
        </member>
        <member name="T:TED.Primitives.PrimitivePredicate.Goal">
            <summary>
            Custom goal representation for this primitive
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate.Goal.Primitive">
            <summary>
            The primitive being called
            </summary>
        </member>
        <member name="P:TED.Primitives.PrimitivePredicate.Goal.Predicate">
            <inheritdoc />
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate.Goal.#ctor(TED.Primitives.PrimitivePredicate)">
            <summary>
            Make a new goal for this predicate
            </summary>
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate.Goal.MakeCall(TED.Preprocessing.GoalAnalyzer)">
            <summary>
            Generate a custom Call object for a call to this particular predicate
            You'll want to fill this in with a constructor for a Call class specific to your predicate
            </summary>
            <param name="ga">Goal analyzer for the rule this goal appears in.  Used to do mode analysis of the variables in the call.</param>
            <returns>Instance of the custom call class for this particular primitive</returns>
        </member>
        <member name="T:TED.Primitives.PrimitivePredicate`1">
            <summary>
            A primitive predicate (one computed by code rather than matching to a table) with one argument
            </summary>
            <typeparam name="T1">Type of the predicate's argument</typeparam>
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate`1.#ctor(System.String)">
            <inheritdoc />
        </member>
        <member name="P:TED.Primitives.PrimitivePredicate`1.Item(TED.Term{`0})">
            <summary>
            Return a goal representing a call to this primitive.
            This is the abstract syntax tree representing the call, not the internal form used in the interpreter
            </summary>
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate`1.MakeCall(TED.Primitives.PrimitivePredicate{`0}.Goal,TED.Preprocessing.GoalAnalyzer)">
            <summary>
            Map a Goal (AST for call) to a Call object (the internal form used by the interpreter)
            </summary>
        </member>
        <member name="T:TED.Primitives.PrimitivePredicate`1.Goal">
            <summary>
            Custom goal representation for this primitive
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`1.Goal.Primitive">
            <summary>
            The primitive being called
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`1.Goal.Arg1">
            <summary>
            First argument
            </summary>
        </member>
        <member name="P:TED.Primitives.PrimitivePredicate`1.Goal.Predicate">
            <inheritdoc />
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate`1.Goal.#ctor(TED.Primitives.PrimitivePredicate{`0},TED.Term{`0})">
            <inheritdoc />
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate`1.Goal.MakeCall(TED.Preprocessing.GoalAnalyzer)">
            <summary>
            Generate a custom Call object for a call to this particular predicate
            You'll want to fill this in with a constructor for a Call class specific to your predicate
            </summary>
            <param name="ga">Goal analyzer for the rule this goal appears in.  Used to do mode analysis of the variables in the call.</param>
            <returns>Instance of the custom call class for this particular primitive</returns>
        </member>
        <member name="T:TED.Primitives.PrimitivePredicate`2">
            <summary>
            A primitive predicate (one computed by code rather than matching to a table) with one argument
            </summary>
            <typeparam name="T1">Type of the predicate's first argument</typeparam>
            <typeparam name="T2">Type of the predicate's second argument</typeparam>
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate`2.#ctor(System.String)">
            <inheritdoc />
        </member>
        <member name="P:TED.Primitives.PrimitivePredicate`2.Item(TED.Term{`0},TED.Term{`1})">
            <summary>
            Return a goal representing a call to this primitive.
            This is the abstract syntax tree representing the call, not the internal form used in the interpreter
            </summary>
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate`2.MakeCall(TED.Primitives.PrimitivePredicate{`0,`1}.Goal,TED.Preprocessing.GoalAnalyzer)">
            <summary>
            Map a Goal (AST for call) to a Call object (the internal form used by the interpreter)
            </summary>
        </member>
        <member name="T:TED.Primitives.PrimitivePredicate`2.Goal">
            <summary>
            Custom goal class for this particular primitive
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`2.Goal.Primitive">
            <summary>
            The primitive being called
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`2.Goal.Arg1">
            <summary>
            First argument
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`2.Goal.Arg2">
            <summary>
            Second argument
            </summary>
        </member>
        <member name="P:TED.Primitives.PrimitivePredicate`2.Goal.Predicate">
            <inheritdoc />
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate`2.Goal.#ctor(TED.Primitives.PrimitivePredicate{`0,`1},TED.Term{`0},TED.Term{`1})">
            <inheritdoc />
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate`2.Goal.MakeCall(TED.Preprocessing.GoalAnalyzer)">
            <summary>
            Generate a custom Call object for a call to this particular predicate
            You'll want to fill this in with a constructor for a Call class specific to your predicate
            </summary>
            <param name="ga">Goal analyzer for the rule this goal appears in.  Used to do mode analysis of the variables in the call.</param>
            <returns>Instance of the custom call class for this particular primitive</returns>
        </member>
        <member name="T:TED.Primitives.PrimitivePredicate`3">
            <summary>
            A primitive predicate (one computed by code rather than matching to a table) with one argument
            </summary>
            <typeparam name="T1">Type of the predicate's first argument</typeparam>
            <typeparam name="T2">Type of the predicate's second argument</typeparam>
            <typeparam name="T3">Type if the predicate's third argument</typeparam>
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate`3.#ctor(System.String)">
            <inheritdoc />
        </member>
        <member name="P:TED.Primitives.PrimitivePredicate`3.Item(TED.Term{`0},TED.Term{`1},TED.Term{`2})">
            <summary>
            Return a goal representing a call to this primitive.
            This is the abstract syntax tree representing the call, not the internal form used in the interpreter
            </summary>
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate`3.MakeCall(TED.Primitives.PrimitivePredicate{`0,`1,`2}.Goal,TED.Preprocessing.GoalAnalyzer)">
            <summary>
            Map a Goal (AST for call) to a Call object (the internal form used by the interpreter)
            </summary>
        </member>
        <member name="T:TED.Primitives.PrimitivePredicate`3.Goal">
            <summary>
            Custom goal class for this particular primitive
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`3.Goal.Primitive">
            <summary>
            The primitive being called
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`3.Goal.Arg1">
            <summary>
            First argument
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`3.Goal.Arg2">
            <summary>
            Second argument
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`3.Goal.Arg3">
            <summary>
            Third argument
            </summary>
        </member>
        <member name="P:TED.Primitives.PrimitivePredicate`3.Goal.Predicate">
            <inheritdoc />
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate`3.Goal.#ctor(TED.Primitives.PrimitivePredicate{`0,`1,`2},TED.Term{`0},TED.Term{`1},TED.Term{`2})">
            <inheritdoc />
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate`3.Goal.MakeCall(TED.Preprocessing.GoalAnalyzer)">
            <summary>
            Generate a custom Call object for a call to this particular predicate
            You'll want to fill this in with a constructor for a Call class specific to your predicate
            </summary>
            <param name="ga">Goal analyzer for the rule this goal appears in.  Used to do mode analysis of the variables in the call.</param>
            <returns>Instance of the custom call class for this particular primitive</returns>
        </member>
        <member name="T:TED.Primitives.PrimitivePredicate`4">
            <summary>
            A primitive predicate (one computed by code rather than matching to a table) with one argument
            </summary>
            <typeparam name="T1">Type of the predicate's first argument</typeparam>
            <typeparam name="T2">Type of the predicate's second argument</typeparam>
            <typeparam name="T3">Type of the predicate's third argument</typeparam>
            <typeparam name="T4">Type of the predicate's fourth argument</typeparam>
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate`4.#ctor(System.String)">
            <inheritdoc />
        </member>
        <member name="P:TED.Primitives.PrimitivePredicate`4.Item(TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3})">
            <summary>
            Return a goal representing a call to this primitive.
            This is the abstract syntax tree representing the call, not the internal form used in the interpreter
            </summary>
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate`4.MakeCall(TED.Primitives.PrimitivePredicate{`0,`1,`2,`3}.Goal,TED.Preprocessing.GoalAnalyzer)">
            <summary>
            Map a Goal (AST for call) to a Call object (the internal form used by the interpreter)
            </summary>
        </member>
        <member name="T:TED.Primitives.PrimitivePredicate`4.Goal">
            <summary>
            Custom goal class for this particular primitive
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`4.Goal.Primitive">
            <summary>
            The primitive being called
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`4.Goal.Arg1">
            <summary>
            First argument
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`4.Goal.Arg2">
            <summary>
            Second argument
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`4.Goal.Arg3">
            <summary>
            Third argument
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`4.Goal.Arg4">
            <summary>
            Fourth argument
            </summary>
        </member>
        <member name="P:TED.Primitives.PrimitivePredicate`4.Goal.Predicate">
            <inheritdoc />
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate`4.Goal.#ctor(TED.Primitives.PrimitivePredicate{`0,`1,`2,`3},TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3})">
            <inheritdoc />
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate`4.Goal.MakeCall(TED.Preprocessing.GoalAnalyzer)">
            <summary>
            Generate a custom Call object for a call to this particular predicate
            You'll want to fill this in with a constructor for a Call class specific to your predicate
            </summary>
            <param name="ga">Goal analyzer for the rule this goal appears in.  Used to do mode analysis of the variables in the call.</param>
            <returns>Instance of the custom call class for this particular primitive</returns>
        </member>
        <member name="T:TED.Primitives.PrimitivePredicate`5">
            <summary>
            A primitive predicate (one computed by code rather than matching to a table) with one argument
            </summary>
            <typeparam name="T1">Type of the predicate's first argument</typeparam>
            <typeparam name="T2">Type of the predicate's second argument</typeparam>
            <typeparam name="T3">Type of the predicate's third argument</typeparam>
            <typeparam name="T4">Type of the predicate's fourth argument</typeparam>
            <typeparam name="T5">Type of the predicate's fifth argument</typeparam>
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate`5.#ctor(System.String)">
            <inheritdoc />
        </member>
        <member name="P:TED.Primitives.PrimitivePredicate`5.Item(TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3},TED.Term{`4})">
            <summary>
            Return a goal representing a call to this primitive.
            This is the abstract syntax tree representing the call, not the internal form used in the interpreter
            </summary>
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate`5.MakeCall(TED.Primitives.PrimitivePredicate{`0,`1,`2,`3,`4}.Goal,TED.Preprocessing.GoalAnalyzer)">
            <summary>
            Map a Goal (AST for call) to a Call object (the internal form used by the interpreter)
            </summary>
        </member>
        <member name="T:TED.Primitives.PrimitivePredicate`5.Goal">
            <summary>
            Custom goal class for this particular primitive
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`5.Goal.Primitive">
            <summary>
            The primitive being called
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`5.Goal.Arg1">
            <summary>
            First argument
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`5.Goal.Arg2">
            <summary>
            Second argument
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`5.Goal.Arg3">
            <summary>
            Third argument
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`5.Goal.Arg4">
            <summary>
            Fourth argument
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`5.Goal.Arg5">
            <summary>
            Fifth argument
            </summary>
        </member>
        <member name="P:TED.Primitives.PrimitivePredicate`5.Goal.Predicate">
            <inheritdoc />
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate`5.Goal.#ctor(TED.Primitives.PrimitivePredicate{`0,`1,`2,`3,`4},TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3},TED.Term{`4})">
            <inheritdoc />
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate`5.Goal.MakeCall(TED.Preprocessing.GoalAnalyzer)">
            <summary>
            Generate a custom Call object for a call to this particular predicate
            You'll want to fill this in with a constructor for a Call class specific to your predicate
            </summary>
            <param name="ga">Goal analyzer for the rule this goal appears in.  Used to do mode analysis of the variables in the call.</param>
            <returns>Instance of the custom call class for this particular primitive</returns>
        </member>
        <member name="T:TED.Primitives.PrimitivePredicate`6">
            <summary>
            A primitive predicate (one computed by code rather than matching to a table) with one argument
            </summary>
            <typeparam name="T1">Type of the predicate's first argument</typeparam>
            <typeparam name="T2">Type of the predicate's second argument</typeparam>
            <typeparam name="T3">Type of the predicate's third argument</typeparam>
            <typeparam name="T4">Type of the predicate's fourth argument</typeparam>
            <typeparam name="T5">Type of the predicate's fifth argument</typeparam>
            <typeparam name="T6">Type of the predicate's sixth argument</typeparam>
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate`6.#ctor(System.String)">
            <inheritdoc />
        </member>
        <member name="P:TED.Primitives.PrimitivePredicate`6.Item(TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3},TED.Term{`4},TED.Term{`5})">
            <summary>
            Return a goal representing a call to this primitive.
            This is the abstract syntax tree representing the call, not the internal form used in the interpreter
            </summary>
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate`6.MakeCall(TED.Primitives.PrimitivePredicate{`0,`1,`2,`3,`4,`5}.Goal,TED.Preprocessing.GoalAnalyzer)">
            <summary>
            Map a Goal (AST for call) to a Call object (the internal form used by the interpreter)
            </summary>
        </member>
        <member name="T:TED.Primitives.PrimitivePredicate`6.Goal">
            <summary>
            Custom goal class for this particular primitive
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`6.Goal.Primitive">
            <summary>
            The primitive being called
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`6.Goal.Arg1">
            <summary>
            First argument
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`6.Goal.Arg2">
            <summary>
            Second argument
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`6.Goal.Arg3">
            <summary>
            Third argument
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`6.Goal.Arg4">
            <summary>
            Fourth argument
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`6.Goal.Arg5">
            <summary>
            Fifth argument
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`6.Goal.Arg6">
            <summary>
            Sixth argument
            </summary>
        </member>
        <member name="P:TED.Primitives.PrimitivePredicate`6.Goal.Predicate">
            <inheritdoc />
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate`6.Goal.#ctor(TED.Primitives.PrimitivePredicate{`0,`1,`2,`3,`4,`5},TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3},TED.Term{`4},TED.Term{`5})">
            <inheritdoc />
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate`6.Goal.MakeCall(TED.Preprocessing.GoalAnalyzer)">
            <summary>
            Generate a custom Call object for a call to this particular predicate
            You'll want to fill this in with a constructor for a Call class specific to your predicate
            </summary>
            <param name="ga">Goal analyzer for the rule this goal appears in.  Used to do mode analysis of the variables in the call.</param>
            <returns>Instance of the custom call class for this particular primitive</returns>
        </member>
        <member name="T:TED.Primitives.PrimitivePredicate`7">
            <summary>
            A primitive predicate (one computed by code rather than matching to a table) with one argument
            </summary>
            <typeparam name="T1">Type of the predicate's first argument</typeparam>
            <typeparam name="T2">Type of the predicate's second argument</typeparam>
            <typeparam name="T3">Type of the predicate's third argument</typeparam>
            <typeparam name="T4">Type of the predicate's fourth argument</typeparam>
            <typeparam name="T5">Type of the predicate's fifth argument</typeparam>
            <typeparam name="T6">Type of the predicate's sixth argument</typeparam>
            <typeparam name="T7">Type of the predicate's seventh argument</typeparam>
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate`7.#ctor(System.String)">
            <inheritdoc />
        </member>
        <member name="P:TED.Primitives.PrimitivePredicate`7.Item(TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3},TED.Term{`4},TED.Term{`5},TED.Term{`6})">
            <summary>
            Return a goal representing a call to this primitive.
            This is the abstract syntax tree representing the call, not the internal form used in the interpreter
            </summary>
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate`7.MakeCall(TED.Primitives.PrimitivePredicate{`0,`1,`2,`3,`4,`5,`6}.Goal,TED.Preprocessing.GoalAnalyzer)">
            <summary>
            Map a Goal (AST for call) to a Call object (the internal form used by the interpreter)
            </summary>
        </member>
        <member name="T:TED.Primitives.PrimitivePredicate`7.Goal">
            <summary>
            Custom goal class for this particular primitive
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`7.Goal.Primitive">
            <summary>
            The primitive being called
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`7.Goal.Arg1">
            <summary>
            First argument
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`7.Goal.Arg2">
            <summary>
            Second argument
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`7.Goal.Arg3">
            <summary>
            Third argument
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`7.Goal.Arg4">
            <summary>
            Fourth argument
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`7.Goal.Arg5">
            <summary>
            Fifth argument
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`7.Goal.Arg6">
            <summary>
            Sixth argument
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`7.Goal.Arg7">
            <summary>
            Seventh argument
            </summary>
        </member>
        <member name="P:TED.Primitives.PrimitivePredicate`7.Goal.Predicate">
            <inheritdoc />
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate`7.Goal.#ctor(TED.Primitives.PrimitivePredicate{`0,`1,`2,`3,`4,`5,`6},TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3},TED.Term{`4},TED.Term{`5},TED.Term{`6})">
            <inheritdoc />
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate`7.Goal.MakeCall(TED.Preprocessing.GoalAnalyzer)">
            <summary>
            Generate a custom Call object for a call to this particular predicate
            You'll want to fill this in with a constructor for a Call class specific to your predicate
            </summary>
            <param name="ga">Goal analyzer for the rule this goal appears in.  Used to do mode analysis of the variables in the call.</param>
            <returns>Instance of the custom call class for this particular primitive</returns>
        </member>
        <member name="T:TED.Primitives.PrimitivePredicate`8">
            <summary>
            A primitive predicate (one computed by code rather than matching to a table) with one argument
            </summary>
            <typeparam name="T1">Type of the predicate's first argument</typeparam>
            <typeparam name="T2">Type of the predicate's second argument</typeparam>
            <typeparam name="T3">Type of the predicate's third argument</typeparam>
            <typeparam name="T4">Type of the predicate's fourth argument</typeparam>
            <typeparam name="T5">Type of the predicate's fifth argument</typeparam>
            <typeparam name="T6">Type of the predicate's sixth argument</typeparam>
            <typeparam name="T7">Type of the predicate's seventh argument</typeparam>
            <typeparam name="T8">Type of the predicate's eighth argument</typeparam>
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate`8.#ctor(System.String)">
            <inheritdoc />
        </member>
        <member name="P:TED.Primitives.PrimitivePredicate`8.Item(TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3},TED.Term{`4},TED.Term{`5},TED.Term{`6},TED.Term{`7})">
            <summary>
            Return a goal representing a call to this primitive.
            This is the abstract syntax tree representing the call, not the internal form used in the interpreter
            </summary>
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate`8.MakeCall(TED.Primitives.PrimitivePredicate{`0,`1,`2,`3,`4,`5,`6,`7}.Goal,TED.Preprocessing.GoalAnalyzer)">
            <summary>
            Map a Goal (AST for call) to a Call object (the internal form used by the interpreter)
            </summary>
        </member>
        <member name="T:TED.Primitives.PrimitivePredicate`8.Goal">
            <summary>
            Custom goal class for this particular primitive
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`8.Goal.Primitive">
            <summary>
            The primitive being called
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`8.Goal.Arg1">
            <summary>
            First argument
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`8.Goal.Arg2">
            <summary>
            Second argument
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`8.Goal.Arg3">
            <summary>
            Third argument
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`8.Goal.Arg4">
            <summary>
            Fourth argument
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`8.Goal.Arg5">
            <summary>
            Fifth argument
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`8.Goal.Arg6">
            <summary>
            Sixth argument
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`8.Goal.Arg7">
            <summary>
            Seventh argument
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicate`8.Goal.Arg8">
            <summary>
            Eighth argument
            </summary>
        </member>
        <member name="P:TED.Primitives.PrimitivePredicate`8.Goal.Predicate">
            <inheritdoc />
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate`8.Goal.#ctor(TED.Primitives.PrimitivePredicate{`0,`1,`2,`3,`4,`5,`6,`7},TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3},TED.Term{`4},TED.Term{`5},TED.Term{`6},TED.Term{`7})">
            <inheritdoc />
        </member>
        <member name="M:TED.Primitives.PrimitivePredicate`8.Goal.MakeCall(TED.Preprocessing.GoalAnalyzer)">
            <summary>
            Generate a custom Call object for a call to this particular predicate
            You'll want to fill this in with a constructor for a Call class specific to your predicate
            </summary>
            <param name="ga">Goal analyzer for the rule this goal appears in.  Used to do mode analysis of the variables in the call.</param>
            <returns>Instance of the custom call class for this particular primitive</returns>
        </member>
        <member name="T:TED.Primitives.PrimitivePredicateBase">
            <summary>
            Untyped base class for primitive predicates
            </summary>
        </member>
        <member name="M:TED.Primitives.PrimitivePredicateBase.#ctor(System.String)">
            <summary>
            Make a primitive predicate with the specified name
            </summary>
        </member>
        <member name="F:TED.Primitives.PrimitivePredicateBase.CompilationName">
            <summary>
            Name of C# procedure to call to implement this primitive, when compiling.
            </summary>
        </member>
        <member name="T:TED.Primitives.PrimitiveTest">
            <summary>
            A primitive that tests for truth using a C# function.
            </summary>
        </member>
        <member name="P:TED.Primitives.PrimitiveTest.IsPure">
            <inheritdoc />
        </member>
        <member name="M:TED.Primitives.PrimitiveTest.#ctor(System.String,System.Func{System.Boolean},System.Boolean)">
            <summary>
            Make a primitive test, i.e. a predicate that can only be called on instantiated arguments.
            </summary>
            <param name="name">Name, for debugging purposes</param>
            <param name="implementation">C# implementation.
                This will be called with the values of the arguments.
                If it returns true, the call to the test succeeds, otherwise, it fails and the system backtracks</param>
            <param name="isPure">This test is deterministic and has no side effects</param>
        </member>
        <member name="M:TED.Primitives.PrimitiveTest.MakeCall(TED.Primitives.PrimitivePredicate.Goal,TED.Preprocessing.GoalAnalyzer)">
            <inheritdoc />
        </member>
        <member name="T:TED.Primitives.PrimitiveTest`1">
            <summary>
            A primitive that tests instantiated argument. Throws an instantiation exception if its argument is an unbound variable.
            </summary>
            <typeparam name="T1">Type of the argument to the predicate</typeparam>
        </member>
        <member name="P:TED.Primitives.PrimitiveTest`1.IsPure">
            <inheritdoc />
        </member>
        <member name="M:TED.Primitives.PrimitiveTest`1.#ctor(System.String,System.Func{`0,System.Boolean},System.Boolean)">
            <summary>
            Make a primitive test, i.e. a predicate that can only be called on instantiated arguments.
            </summary>
            <param name="name">Name, for debugging purposes</param>
            <param name="implementation">C# implementation.
            This will be called with the values of the arguments.
            If it returns true, the call to the test succeeds, otherwise, it fails and the system backtracks</param>
            <param name="isPure">This predicate has no side-effects and so can be safely constant-folded.</param>
        </member>
        <member name="M:TED.Primitives.PrimitiveTest`1.MakeCall(TED.Primitives.PrimitivePredicate{`0}.Goal,TED.Preprocessing.GoalAnalyzer)">
            <inheritdoc />
        </member>
        <member name="T:TED.Primitives.PrimitiveTest`2">
            <summary>
            A primitive that tests instantiated two arguments. Throws an instantiation exception if either argument is an unbound variable.
            </summary>
            <typeparam name="T1">Type of the first argument to the predicate</typeparam>
            <typeparam name="T2">Type of the second argument to the predicate</typeparam>
        </member>
        <member name="P:TED.Primitives.PrimitiveTest`2.IsPure">
            <inheritdoc />
        </member>
        <member name="M:TED.Primitives.PrimitiveTest`2.#ctor(System.String,System.Func{`0,`1,System.Boolean},System.Boolean)">
            <summary>
            Make a primitive test, i.e. a predicate that can only be called on instantiated arguments.
            </summary>
            <param name="name">Name, for debugging purposes</param>
            <param name="implementation">C# implementation.
            This will be called with the values of the arguments.
            If it returns true, the call to the test succeeds, otherwise, it fails and the system backtracks</param>
            <param name="isPure">This predicate has no side-effects and so can be safely constant-folded</param>
        </member>
        <member name="M:TED.Primitives.PrimitiveTest`2.MakeCall(TED.Primitives.PrimitivePredicate{`0,`1}.Goal,TED.Preprocessing.GoalAnalyzer)">
            <inheritdoc />
        </member>
        <member name="T:TED.Primitives.PrimitiveTest`3">
            <summary>
            A primitive that tests instantiated two arguments. Throws an instantiation exception if either argument is an unbound variable.
            </summary>
            <typeparam name="T1">Type of the first argument to the predicate</typeparam>
            <typeparam name="T2">Type of the second argument to the predicate</typeparam>
            <typeparam name="T3">Type of the third argument to the predicate</typeparam>
        </member>
        <member name="P:TED.Primitives.PrimitiveTest`3.IsPure">
            <inheritdoc />
        </member>
        <member name="M:TED.Primitives.PrimitiveTest`3.#ctor(System.String,System.Func{`0,`1,`2,System.Boolean},System.Boolean)">
            <summary>
            Make a primitive test, i.e. a predicate that can only be called on instantiated arguments.
            </summary>
            <param name="name">Name, for debugging purposes</param>
            <param name="implementation">C# implementation.
            This will be called with the values of the arguments.
            If it returns true, the call to the test succeeds, otherwise, it fails and the system backtracks</param>
            <param name="isPure">This predicate has no side-effects and so can be safely constant-folded</param>
        </member>
        <member name="M:TED.Primitives.PrimitiveTest`3.MakeCall(TED.Primitives.PrimitivePredicate{`0,`1,`2}.Goal,TED.Preprocessing.GoalAnalyzer)">
            <inheritdoc />
        </member>
        <member name="T:TED.Primitives.PrimitiveTest`4">
            <summary>
            A primitive that tests instantiated two arguments. Throws an instantiation exception if either argument is an unbound variable.
            </summary>
            <typeparam name="T1">Type of the first argument to the predicate</typeparam>
            <typeparam name="T2">Type of the second argument to the predicate</typeparam>
            <typeparam name="T3">Type of the third argument to the predicate</typeparam>
            <typeparam name="T4">Type of the fourth argument to the predicate</typeparam>
        </member>
        <member name="P:TED.Primitives.PrimitiveTest`4.IsPure">
            <inheritdoc />
        </member>
        <member name="M:TED.Primitives.PrimitiveTest`4.#ctor(System.String,System.Func{`0,`1,`2,`3,System.Boolean},System.Boolean)">
            <summary>
            Make a primitive test, i.e. a predicate that can only be called on instantiated arguments.
            </summary>
            <param name="name">Name, for debugging purposes</param>
            <param name="implementation">C# implementation.
            This will be called with the values of the arguments.
            If it returns true, the call to the test succeeds, otherwise, it fails and the system backtracks</param>
            <param name="isPure">This predicate has no side-effects and so can be safely constant-folded</param>
        </member>
        <member name="M:TED.Primitives.PrimitiveTest`4.MakeCall(TED.Primitives.PrimitivePredicate{`0,`1,`2,`3}.Goal,TED.Preprocessing.GoalAnalyzer)">
            <inheritdoc />
        </member>
        <member name="T:TED.Primitives.PrimitiveTest`5">
            <summary>
            A primitive that tests instantiated two arguments. Throws an instantiation exception if either argument is an unbound variable.
            </summary>
            <typeparam name="T1">Type of the first argument to the predicate</typeparam>
            <typeparam name="T2">Type of the second argument to the predicate</typeparam>
            <typeparam name="T3">Type of the third argument to the predicate</typeparam>
            <typeparam name="T4">Type of the fourth argument to the predicate</typeparam>
            <typeparam name="T5">Type of the fifth argument to the predicate</typeparam>
        </member>
        <member name="P:TED.Primitives.PrimitiveTest`5.IsPure">
            <inheritdoc />
        </member>
        <member name="M:TED.Primitives.PrimitiveTest`5.#ctor(System.String,System.Func{`0,`1,`2,`3,`4,System.Boolean},System.Boolean)">
            <summary>
            Make a primitive test, i.e. a predicate that can only be called on instantiated arguments.
            </summary>
            <param name="name">Name, for debugging purposes</param>
            <param name="implementation">C# implementation.
            This will be called with the values of the arguments.
            If it returns true, the call to the test succeeds, otherwise, it fails and the system backtracks</param>
            <param name="isPure">This predicate has no side-effects and so can be safely constant-folded</param>
        </member>
        <member name="M:TED.Primitives.PrimitiveTest`5.MakeCall(TED.Primitives.PrimitivePredicate{`0,`1,`2,`3,`4}.Goal,TED.Preprocessing.GoalAnalyzer)">
            <inheritdoc />
        </member>
        <member name="T:TED.Primitives.PrimitiveTest`6">
            <summary>
            A primitive that tests instantiated two arguments. Throws an instantiation exception if either argument is an unbound variable.
            </summary>
            <typeparam name="T1">Type of the first argument to the predicate</typeparam>
            <typeparam name="T2">Type of the second argument to the predicate</typeparam>
            <typeparam name="T3">Type of the third argument to the predicate</typeparam>
            <typeparam name="T4">Type of the fourth argument to the predicate</typeparam>
            <typeparam name="T5">Type of the fifth argument to the predicate</typeparam>
            <typeparam name="T6">Type of the sixth argument to the predicate</typeparam>
        </member>
        <member name="P:TED.Primitives.PrimitiveTest`6.IsPure">
            <inheritdoc />
        </member>
        <member name="M:TED.Primitives.PrimitiveTest`6.#ctor(System.String,System.Func{`0,`1,`2,`3,`4,`5,System.Boolean},System.Boolean)">
            <summary>
            Make a primitive test, i.e. a predicate that can only be called on instantiated arguments.
            </summary>
            <param name="name">Name, for debugging purposes</param>
            <param name="implementation">C# implementation.
            This will be called with the values of the arguments.
            If it returns true, the call to the test succeeds, otherwise, it fails and the system backtracks</param>
            <param name="isPure">This predicate has no side-effects and so can be safely constant-folded</param>
        </member>
        <member name="M:TED.Primitives.PrimitiveTest`6.MakeCall(TED.Primitives.PrimitivePredicate{`0,`1,`2,`3,`4,`5}.Goal,TED.Preprocessing.GoalAnalyzer)">
            <inheritdoc />
        </member>
        <member name="T:TED.Primitives.PrimitiveTest`7">
            <summary>
            A primitive that tests instantiated two arguments. Throws an instantiation exception if either argument is an unbound variable.
            </summary>
            <typeparam name="T1">Type of the first argument to the predicate</typeparam>
            <typeparam name="T2">Type of the second argument to the predicate</typeparam>
            <typeparam name="T3">Type of the third argument to the predicate</typeparam>
            <typeparam name="T4">Type of the fourth argument to the predicate</typeparam>
            <typeparam name="T5">Type of the fifth argument to the predicate</typeparam>
            <typeparam name="T6">Type of the sixth argument to the predicate</typeparam>
            <typeparam name="T7">Type of the seventh argument to the predicate</typeparam>
        </member>
        <member name="P:TED.Primitives.PrimitiveTest`7.IsPure">
            <inheritdoc />
        </member>
        <member name="M:TED.Primitives.PrimitiveTest`7.#ctor(System.String,System.Func{`0,`1,`2,`3,`4,`5,`6,System.Boolean},System.Boolean)">
            <summary>
            Make a primitive test, i.e. a predicate that can only be called on instantiated arguments.
            </summary>
            <param name="name">Name, for debugging purposes</param>
            <param name="implementation">C# implementation.
            This will be called with the values of the arguments.
            If it returns true, the call to the test succeeds, otherwise, it fails and the system backtracks</param>
            <param name="isPure">This predicate has no side-effects and so can be safely constant-folded</param>
        </member>
        <member name="M:TED.Primitives.PrimitiveTest`7.MakeCall(TED.Primitives.PrimitivePredicate{`0,`1,`2,`3,`4,`5,`6}.Goal,TED.Preprocessing.GoalAnalyzer)">
            <inheritdoc />
        </member>
        <member name="T:TED.Primitives.PrimitiveTest`8">
            <summary>
            A primitive that tests instantiated two arguments. Throws an instantiation exception if either argument is an unbound variable.
            </summary>
            <typeparam name="T1">Type of the first argument to the predicate</typeparam>
            <typeparam name="T2">Type of the second argument to the predicate</typeparam>
            <typeparam name="T3">Type of the third argument to the predicate</typeparam>
            <typeparam name="T4">Type of the fourth argument to the predicate</typeparam>
            <typeparam name="T5">Type of the fifth argument to the predicate</typeparam>
            <typeparam name="T6">Type of the sixth argument to the predicate</typeparam>
            <typeparam name="T7">Type of the seventh argument to the predicate</typeparam>
            <typeparam name="T8">Type of the eighth argument to the predicate</typeparam>
        </member>
        <member name="P:TED.Primitives.PrimitiveTest`8.IsPure">
            <inheritdoc />
        </member>
        <member name="M:TED.Primitives.PrimitiveTest`8.#ctor(System.String,System.Func{`0,`1,`2,`3,`4,`5,`6,`7,System.Boolean},System.Boolean)">
            <summary>
            Make a primitive test, i.e. a predicate that can only be called on instantiated arguments.
            </summary>
            <param name="name">Name, for debugging purposes</param>
            <param name="implementation">C# implementation.
            This will be called with the values of the arguments.
            If it returns true, the call to the test succeeds, otherwise, it fails and the system backtracks</param>
            <param name="isPure">This predicate has no side-effects and so can be safely constant-folded</param>
        </member>
        <member name="M:TED.Primitives.PrimitiveTest`8.MakeCall(TED.Primitives.PrimitivePredicate{`0,`1,`2,`3,`4,`5,`6,`7}.Goal,TED.Preprocessing.GoalAnalyzer)">
            <inheritdoc />
        </member>
        <member name="T:TED.Primitives.RandomElementPrimitive`1">
            <summary>
            Implementation of the RandomElement primitive
            </summary>
            <typeparam name="T">Type of list element we're selecting from</typeparam>
        </member>
        <member name="P:TED.Primitives.RandomElementPrimitive`1.IsPure">
            <summary>
            Randomization does not behave like a pure predicate
            </summary>
        </member>
        <member name="T:TED.Primitives.RandomElementPrimitive`2">
            <summary>
            Implementation of the RandomElement primitive
            </summary>
            <typeparam name="T1">Type of the first column from the table we're selecting from</typeparam>
            <typeparam name="T2">Type of the second column from the table we're selecting from</typeparam>
        </member>
        <member name="T:TED.Primitives.RandomElementPrimitive`3">
            <summary>
            Implementation of the RandomElement primitive
            </summary>
            <typeparam name="T1">Type of the first column from the table we're selecting from</typeparam>
            <typeparam name="T2">Type of the second column from the table we're selecting from</typeparam>
            <typeparam name="T3">Type of the third column from the table we're selecting from</typeparam>
        </member>
        <member name="T:TED.Primitives.RandomElementPrimitive`4">
            <summary>
            Implementation of the RandomElement primitive
            </summary>
            <typeparam name="T1">Type of the first column from the table we're selecting from</typeparam>
            <typeparam name="T2">Type of the second column from the table we're selecting from</typeparam>
            <typeparam name="T3">Type of the third column from the table we're selecting from</typeparam>
            <typeparam name="T4">Type of the fourth column from the table we're selecting from</typeparam>
        </member>
        <member name="T:TED.Primitives.RandomElementPrimitive`5">
            <summary>
            Implementation of the RandomElement primitive
            </summary>
            <typeparam name="T1">Type of the first column from the table we're selecting from</typeparam>
            <typeparam name="T2">Type of the second column from the table we're selecting from</typeparam>
            <typeparam name="T3">Type of the third column from the table we're selecting from</typeparam>
            <typeparam name="T4">Type of the fourth column from the table we're selecting from</typeparam>
            <typeparam name="T5">Type of the fifth column from the table we're selecting from</typeparam>
        </member>
        <member name="T:TED.Primitives.RandomElementPrimitive`6">
            <summary>
            Implementation of the RandomElement primitive
            </summary>
            <typeparam name="T1">Type of the first column from the table we're selecting from</typeparam>
            <typeparam name="T2">Type of the second column from the table we're selecting from</typeparam>
            <typeparam name="T3">Type of the third column from the table we're selecting from</typeparam>
            <typeparam name="T4">Type of the fourth column from the table we're selecting from</typeparam>
            <typeparam name="T5">Type of the fifth column from the table we're selecting from</typeparam>
            <typeparam name="T6">Type of the sixth column from the table we're selecting from</typeparam>
        </member>
        <member name="T:TED.Primitives.RandomElementPrimitive`7">
            <summary>
            Implementation of the RandomElement primitive
            </summary>
            <typeparam name="T1">Type of the first column from the table we're selecting from</typeparam>
            <typeparam name="T2">Type of the second column from the table we're selecting from</typeparam>
            <typeparam name="T3">Type of the third column from the table we're selecting from</typeparam>
            <typeparam name="T4">Type of the fourth column from the table we're selecting from</typeparam>
            <typeparam name="T5">Type of the fifth column from the table we're selecting from</typeparam>
            <typeparam name="T6">Type of the sixth column from the table we're selecting from</typeparam>
            <typeparam name="T7">Type of the seventh column from the table we're selecting from</typeparam>
        </member>
        <member name="T:TED.Primitives.RandomElementPrimitive`8">
            <summary>
            Implementation of the RandomElement primitive
            </summary>
            <typeparam name="T1">Type of the first column from the table we're selecting from</typeparam>
            <typeparam name="T2">Type of the second column from the table we're selecting from</typeparam>
            <typeparam name="T3">Type of the third column from the table we're selecting from</typeparam>
            <typeparam name="T4">Type of the fourth column from the table we're selecting from</typeparam>
            <typeparam name="T5">Type of the fifth column from the table we're selecting from</typeparam>
            <typeparam name="T6">Type of the sixth column from the table we're selecting from</typeparam>
            <typeparam name="T7">Type of the seventh column from the table we're selecting from</typeparam>
            <typeparam name="T8">Type of the seventh column from the table we're selecting from</typeparam>
        </member>
        <member name="T:TED.Primitives.UnaryArithmeticOperator`1">
            <summary>
            Wrapper for one of the unary "op_" methods that operator expressions in C# compile to.
            </summary>
        </member>
        <member name="T:TED.Program">
            <summary>
            A container for a set of predicates
            This is basically a namespace for predicates.
            It's presently only used by the REPL.  So if you aren't using that, you don't need a Program.
            </summary>
        </member>
        <member name="F:TED.Program.LoadingPrograms">
            <summary>
            The top of the stack is the program to which new predicates should be added.
            It's a stack out of paranoia that something bad will happen if multiple programs are loaded and they get mixed.
            </summary>
        </member>
        <member name="F:TED.Program.tables">
            <summary>
            Predicates and their names
            </summary>
        </member>
        <member name="P:TED.Program.Tables">
            <summary>
            All Predicates defined in this Program
            </summary>
        </member>
        <member name="P:TED.Program.BaseTables">
            <summary>
            Base tables in the program
            </summary>
        </member>
        <member name="F:TED.Program.Name">
            <summary>
            Name of the program, for debugging
            </summary>
        </member>
        <member name="P:TED.Program.Repl">
            <summary>
            Return a REPL associated with this program, creating it if necessary.
            </summary>
        </member>
        <member name="M:TED.Program.#ctor(System.String)">
            <summary>
            Make a new Program.  A Program is a container for predicates that are to be used with a Repl.
            To use: make a Program. call Program.Begin(), make a bunch of predicates, then call Program.End().
            Then you can access those predicates from the Repl
            </summary>
            <param name="name">Name of the program, for debugging purposes</param>
        </member>
        <member name="M:TED.Program.BeginPredicates">
            <summary>
            Start defining predicates for the program.  All predicates created between calling and calling End() will be added
            to the program.
            </summary>
        </member>
        <member name="M:TED.Program.EndPredicates">
            <summary>
            Stop adding new predicates to this Program.
            </summary>
        </member>
        <member name="P:TED.Program.Item(System.String)">
            <summary>
            The predicate with the specified name
            </summary>
        </member>
        <member name="M:TED.Program.PredicateNamed(System.String)">
            <summary>
            The predicate with the specified name, or null if none is defined.
            </summary>
        </member>
        <member name="M:TED.Program.Add(TED.TablePredicate)">
            <summary>
            Add a new predicate to the program/simulation
            </summary>
            <param name="predicate">Predicate to add</param>
            <exception cref="T:System.InvalidOperationException">IF there is already a predicate by that name in the program/simulation</exception>
        </member>
        <member name="M:TED.Program.Remove(TED.TablePredicate)">
            <summary>
            Remove a table from the program
            </summary>
            <param name="table">Table to remove</param>
        </member>
        <member name="M:TED.Program.FindDependents">
            <summary>
            Build dependent lists for all tables in the program.
            </summary>
        </member>
        <member name="M:TED.Repl.Parser.GetVariable(TED.Repl.ParserState,System.String)">
            <summary>
            Get a variable with this name.
            If we already have a variable by this name, return that.
            If not, return a placeholder but don't add it to the symbol table
            because we don't yet know its type.  When it gets used in a goal, MakeGoal will
            make a new variable with this name and the correct type and add it to the symbol table.
            </summary>
            <param name="s">Parser state (for the symbol table)</param>
            <param name="name">Name of the variable</param>
        </member>
        <member name="M:TED.Repl.Parser.SymbolTable.GetVariable(System.String,TED.Term)">
            <summary>
            Get the variable with this name, if one has already been made.  Otherwise, make one of the same type as defaultArg.
            </summary>
            <param name="name"></param>
            <param name="defaultArg"></param>
            <returns></returns>
        </member>
        <member name="M:TED.Repl.ParserState.Bracketed``1(System.String,TED.Repl.ParserState.Parser{``0},System.String,TED.Repl.ParserState.Continuation{``0})">
            <summary>
            Matches payload surrounded by specified bracket characters
            </summary>
            <typeparam name="T">Type of payload output</typeparam>
            <param name="openOptions">Characters allowed as open bracket</param>
            <param name="payload"></param>
            <param name="closeOptions">Characters allowed as close bracket</param>
            <param name="k">Continuation called with parser state after close bracket and output of payload</param>
            <returns>True if successfully matched and continuation returns true.</returns>
        </member>
        <member name="T:TED.Repl.Repl">
            <summary>
            Support for Read/Evaluate/Print/Loops (REPLs), i.e. command line interpreters
            This converts strings containing code to executable queries and runs them, returning the results
            </summary>
        </member>
        <member name="F:TED.Repl.Repl.Program">
            <summary>
            The collection of predicates to allow the user to call
            </summary>
        </member>
        <member name="F:TED.Repl.Repl.Parser">
            <summary>
            Parser object to use to parse queries
            </summary>
        </member>
        <member name="F:TED.Repl.Repl.ResolveConstant">
            <summary>
            Called when the user types a term of the form $string or $"string".  Maps string to a Term.
            Fill this in to handle whatever application-specific term syntax you need.
            </summary>
        </member>
        <member name="M:TED.Repl.Repl.NullConstantResolver(System.String)">
            <summary>
            Default constant resolver to use
            </summary>
        </member>
        <member name="M:TED.Repl.Repl.#ctor(TED.Program,System.Func{System.String,TED.Term})">
            <summary>
            Make a new Repl.
            </summary>
            <param name="program">Collection of predicates to be callable form the repl</param>
            <param name="resolveConstant">Constant resolver to use for $string terms, or null if $string shouldn't be supported</param>
        </member>
        <member name="M:TED.Repl.Repl.Query(System.String,System.String)">
            <summary>
            Transform the query string into a TablePredicate with a single rule, whose columns/arguments
            are the variables of the query.
            </summary>
            <param name="name">Name to give to the TablePredicate that computes this query</param>
            <param name="goalString">String containing the query</param>
            <returns>TablePredicate that computes the results of the query</returns>
        </member>
        <member name="T:TED.RuleExecutionException">
            <summary>
            An exception that wraps an exception that occurred during the execution of a rule.
            This makes it possible to report back the TED-level code that triggered the exception.
            </summary>
        </member>
        <member name="F:TED.RuleExecutionException.Rule">
            <summary>
            Rule in which the exception occurred
            </summary>
        </member>
        <member name="F:TED.RuleExecutionException.Call">
            <summary>
            The call from the rule that triggered the exception
            </summary>
        </member>
        <member name="P:TED.RuleExecutionException.LocalVariables">
            <summary>
            Names and current values of the local variables from the rule.
            </summary>
        </member>
        <member name="P:TED.RuleExecutionException.Predicate">
            <summary>
            Predicate for which the rule is defined
            </summary>
        </member>
        <member name="T:TED.Simulation">
            <summary>
            A simulation written in TED.
            </summary>
        </member>
        <member name="M:TED.Simulation.#ctor(System.String)">
            <summary>
            Make a simulation with the specified name
            </summary>
        </member>
        <member name="F:TED.Simulation.CheckForProblems">
            <summary>
            If true, run all the Problem rules specified by the programmer.
            </summary>
        </member>
        <member name="M:TED.Simulation.EndPredicates">
            <inheritdoc />
        </member>
        <member name="F:TED.Simulation.DynamicTables">
            <summary>
            The tables in the simulation that vary from tick to tick
            </summary>
        </member>
        <member name="P:TED.Simulation.RuleExecutionTime">
            <summary>
            Average combined execution time for all the rules in the simulation
            </summary>
        </member>
        <member name="M:TED.Simulation.ToString">
            <inheritdoc />
        </member>
        <member name="M:TED.Simulation.Update">
            <summary>
            Update all tables in the simulation
            </summary>
        </member>
        <member name="M:TED.Simulation.RecomputeAll">
            <summary>
            Forcibly recompute all the predicates
            </summary>
        </member>
        <member name="M:TED.Simulation.UpdateDynamicBaseTables">
            <summary>
            Run any column updates defined using the Set() method.
            </summary>
        </member>
        <member name="M:TED.Simulation.AppendAllInputs">
            <summary>
            Append all the inputs to tables that accumulate other tables
            </summary>
        </member>
        <member name="T:TED.TablePredicate">
            <summary>
            Untyped base class for TablePredicates
            These are predicates that store an explicit list (table) of their extensions (all their ground instances, aka rows)
            </summary>
        </member>
        <member name="M:TED.TablePredicate.Create(System.String,TED.Interpreter.IVariable[])">
            <summary>
            Create a new table predicate without knowing its column types in advance.
            Note that this will not work on platforms that do not allow dynamic code generation,
            such as iOS, because of the way that generics are implemented in the CLR.
            </summary>
            <param name="name">Name to give to the new predicate</param>
            <param name="columns">Default variables for the columns</param>
            <returns>The table predicate</returns>
            <exception cref="T:System.ArgumentException">If columns is empty or longer than 8 elements.</exception>
        </member>
        <member name="M:TED.TablePredicate.#ctor(System.String,System.Action{TED.Tables.Table},TED.Interpreter.IColumnSpec[])">
            <summary>
            Make a new predicate
            </summary>
        </member>
        <member name="F:TED.TablePredicate.Program">
            <summary>
            The Program or Simulation to which this predicate belongs
            </summary>
        </member>
        <member name="P:TED.TablePredicate.IsDynamic">
            <summary>
            True if this is a table in a simulation that needs to be updated dynamically
            </summary>
        </member>
        <member name="P:TED.TablePredicate.IsStatic">
            <summary>
            True if this table doesn't change during a simulation.
            </summary>
        </member>
        <member name="F:TED.TablePredicate.InitializationOnly">
            <summary>
            True if this table is only used for initialization of some other table
            </summary>
        </member>
        <member name="P:TED.TablePredicate.Unique">
            <summary>
            If true, the underlying table enforces uniqueness of row/tuples by indexing them with a hashtable.
            </summary>
        </member>
        <member name="F:TED.TablePredicate.ColumnHeadings">
            <summary>
            Human-readable descriptions of columns
            </summary>
        </member>
        <member name="F:TED.TablePredicate.DefaultVariables">
            <summary>
            Default variables for use in TrueWhen()
            </summary>
        </member>
        <member name="P:TED.TablePredicate.Arity">
            <summary>
            Number of arguments to the predicate
            </summary>
        </member>
        <member name="P:TED.TablePredicate.Item(TED.Term[])">
            <summary>
            Returns a goal of the predicate applied to the specified arguments
            </summary>
            <param name="args">Arguments to the predicate</param>
        </member>
        <member name="M:TED.TablePredicate.AppendArgs(TED.Interpreter.TableGoal,TED.Term[])">
            <summary>
            Return a call to this predicate using the arguments from goal, followed by additionalArguments.
            Note that goal will generally be a call to some other predicate
            </summary>
        </member>
        <member name="M:TED.TablePredicate.GetGoal(TED.Term[])">
            <summary>
            Returns a goal of the predicate applied to the specified arguments
            </summary>
            <param name="args">Arguments to the predicate</param>
        </member>
        <member name="P:TED.TablePredicate.DefaultGoal">
            <summary>
            A call to this predicate using it's "default" arguments
            </summary>
        </member>
        <member name="M:TED.TablePredicate.IndexByKey(System.Int32)">
            <summary>
            Add a key index
            </summary>
        </member>
        <member name="M:TED.TablePredicate.IndexByKey(TED.Interpreter.IVariable)">
            <summary>
            Add a key index
            </summary>
        </member>
        <member name="M:TED.TablePredicate.IndexBy(System.Int32)">
            <summary>
            Add an index; the column isn't a key, i.e. rows aren't assumed to have unique values for this column
            </summary>
        </member>
        <member name="M:TED.TablePredicate.IndexBy(TED.Interpreter.IVariable)">
            <summary>
            Add an index; the column isn't a key, i.e. rows aren't assumed to have unique values for this column
            </summary>
        </member>
        <member name="M:TED.TablePredicate.IndexByKey``2(TED.Var{``0},TED.Var{``1})">
            <summary>
            Add a key index in which the two columns jointly specify the key.
            </summary>
        </member>
        <member name="M:TED.TablePredicate.IndexBy``2(TED.Var{``0},TED.Var{``1})">
            <summary>
            Add an index based on the specified two columns
            </summary>
        </member>
        <member name="M:TED.TablePredicate.AddIndex``3(TED.Var{``1},TED.Var{``2},System.Boolean)">
            <summary>
            Adds an index that indexes the table by the joint values of two columns
            </summary>
            <param name="c1">First column</param>
            <param name="c2">Second column</param>
            <param name="keyIndex">If true, the two columns form a key</param>
            <typeparam name="TRow">Data type of the rows of the table</typeparam>
            <typeparam name="TColumn1">Data type of the first column</typeparam>
            <typeparam name="TColumn2">Data type of the second column</typeparam>
            <returns>The index</returns>
        </member>
        <member name="M:TED.TablePredicate.AddIndex``2(TED.Var{``0},TED.Var{``1},System.Boolean)">
            <summary>
            Adds an index that indexes the table by the joint values of two columns
            </summary>
            <param name="c1">First column</param>
            <param name="c2">Second column</param>
            <param name="keyIndex">If true, the two columns form a key</param>
            <typeparam name="TColumn1">Data type of the first column</typeparam>
            <typeparam name="TColumn2">Data type of the second column</typeparam>
            <returns>The index</returns>
        </member>
        <member name="M:TED.TablePredicate.ColumnPositionOfDefaultVariable(TED.Interpreter.IVariable)">
            <summary>
            Find the column/argument position of an argument, given the variable used to declare it.
            </summary>
        </member>
        <member name="M:TED.TablePredicate.AddIndex(System.Int32,System.Boolean)">
            <summary>
            Add an index to the predicate's table
            </summary>
        </member>
        <member name="M:TED.TablePredicate.AddIndex(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Add a joint index to the predicate's table
            </summary>
        </member>
        <member name="M:TED.TablePredicate.IndexFor(System.Int32[],System.Boolean)">
            <summary>
            Return the index of the specified type for the specified column
            WARNING: THIS SORTS columnIndices.
            </summary>
            <param name="columnIndices">Column to find the index for</param>
            <param name="key">Whether to look for a key or non-key</param>
            <returns>The index or null if there is not index of that type for that column</returns>
        </member>
        <member name="M:TED.TablePredicate.IndexFor(TED.Interpreter.IVariable,System.Boolean)">
            <summary>
            Return the index of the specified type for the specified column
            </summary>
            <param name="column">Column to find the index for</param>
            <param name="key">Whether to look for a key or non-key</param>
            <returns>The index or null if there is not index of that type for that column</returns>
        </member>
        <member name="P:TED.TablePredicate.Indices">
            <summary>
            All indices for the table
            </summary>
        </member>
        <member name="P:TED.TablePredicate.UpdateMode">
            <summary>
            How this table should be updated, if at all
            </summary>
        </member>
        <member name="F:TED.TablePredicate.Rules">
            <summary>
            Rules that can be used to prove goals involving this predicate
            </summary>
        </member>
        <member name="F:TED.TablePredicate.operatorUpdateProc">
            <summary>
            Updater procedure for results of table operators
            </summary>
        </member>
        <member name="F:TED.TablePredicate.CompiledRules">
            <summary>
            Compiled version of rules, if any
            </summary>
        </member>
        <member name="F:TED.TablePredicate.OperatorDependencies">
            <summary>
            For tables that are the results of operators.  The tables the operator takes as inputs.
            </summary>
        </member>
        <member name="P:TED.TablePredicate.UpdatePrerequisites">
            <summary>
            Set of tables that need to already be updated before this can be updated.
            </summary>
        </member>
        <member name="P:TED.TablePredicate.RuleExecutionTime">
            <summary>
            Combined average execution time of all the rules for this predicate.
            </summary>
        </member>
        <member name="P:TED.TablePredicate.IsIntensional">
            <summary>
            A TablePredicate is "intensional" if it's defined by rules.  Otherwise it's "extensional"
            </summary>
        </member>
        <member name="P:TED.TablePredicate.IsExtensional">
            <summary>
            A predicate is "extensional" if it is defined by directly specifying its extension (the set of it instances/rows)
            using AddRow.  If it's defined by rules, it's "intensional".
            </summary>
        </member>
        <member name="P:TED.TablePredicate.IsPure">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate.Clear">
            <summary>
            Remove all data from the predicate's table
            </summary>
        </member>
        <member name="F:TED.TablePredicate.MustRecompute">
            <summary>
            True if we need to recompute the predicate's table
            </summary>
        </member>
        <member name="M:TED.TablePredicate.EnsureUpToDate">
            <summary>
            Compute the predicate's table if it hasn't already or if it's out of date
            </summary>
        </member>
        <member name="M:TED.TablePredicate.ForceRecompute">
            <summary>
            Force the re-computation of an intensional table
            </summary>
        </member>
        <member name="M:TED.TablePredicate.AddRule(TED.Interpreter.Rule)">
            <summary>
            Add a rule to an intensional predicate
            </summary>
        </member>
        <member name="M:TED.TablePredicate.AddRule(TED.Interpreter.Goal[])">
            <summary>
            Add a rule that concludes the default arguments of this predicate
            </summary>
        </member>
        <member name="P:TED.TablePredicate.RuleDependencies">
            <summary>
            All TablePredicates that are used in rules for this TablePredicate, if any.
            </summary>
        </member>
        <member name="P:TED.TablePredicate.ImperativeDependencies">
            <summary>
            The tables that are used to update base tables, through .Accumulates(), .Add, or .Set()
            </summary>
        </member>
        <member name="F:TED.TablePredicate.Dependents">
            <summary>
            Tables that use this table as input
            This is computed by Program.FindDependents().
            </summary>
        </member>
        <member name="M:TED.TablePredicate.Stringify``1(``0@)">
            <summary>
            Null-tolerant version of ToString.
            </summary>
        </member>
        <member name="M:TED.TablePredicate.GetUntypedRowData(System.UInt32,System.Object[])">
            <summary>
            Write the columns of the specified row into the specified array
            </summary>
            <param name="rowNumber">Row number within the table</param>
            <param name="buffer">Buffer in which to write the row data</param>
        </member>
        <member name="M:TED.TablePredicate.UntypedRows(System.Boolean)">
            <summary>
            Enumerate all rows of the table as object?[] arrays.
            Note that this will box any value types in columns, so it is potentially expensive.
            </summary>
            <param name="reuseBuffer">If true, the save object?[] array will be reused for each returned result.  Otherwise, new buffers will be allocated for each row.</param>
        </member>
        <member name="M:TED.TablePredicate.RowToStrings(System.UInt32,System.String[])">
            <summary>
            Write the columns of the specified tuple in to the specified array of strings
            </summary>
            <param name="rowNumber">Row number within the table</param>
            <param name="buffer">Buffer in which to write the string forms</param>
        </member>
        <member name="M:TED.TablePredicate.RowToCsv(System.UInt32,System.String[])">
            <summary>
            Write the columns of the specified tuple in to the specified array of strings
            </summary>
            <param name="rowNumber">Row number within the table</param>
            <param name="buffer">Buffer in which to write the string forms</param>
        </member>
        <member name="P:TED.TablePredicate.Length">
            <summary>
            Number of tuples (rows) in the predicates extension
            </summary>
        </member>
        <member name="M:TED.TablePredicate.RowRangeToStrings(System.UInt32,System.String[][])">
            <summary>
            Get the RowToStrings output for the specified rows in the table starting at startRow and ending
            when the outer array in the buffer is full or when the end of the table is reached. Returns the
            number of rows that were added to the buffer.
            </summary>
            <param name="startRow">Row number within the table to start range from</param>
            <param name="buffer">Buffer in which to write the string forms</param>
        </member>
        <member name="M:TED.TablePredicate.ToCsv(System.String)">
            <summary> Writes the entire table out to the specified path </summary>
            <param name="path">Path to where the csv file should be written</param>
        </member>
        <member name="M:TED.TablePredicate.LoadCsv(System.String,System.String)">
            <summary>Load CSV contents into the table that calls this load</summary>
            <param name="name">Name of the csv file (if different from the name of the table)</param>
            <param name="path">Path to the folder where the CSV file is (with trailing slash)</param>
        </member>
        <member name="M:TED.TablePredicate.LoadCsv(System.String)">
            <summary>Load CSV contents into the table that calls this load</summary>
            <param name="path">Path to the folder where the CSV file containing this tables data is (with trailing slash)</param>
        </member>
        <member name="T:TED.TablePredicate.Update`1">
            <summary>
            Call the specified function on each row of the table, allowing it to overwrite them
            </summary>
            <param name="updateFn"></param>
        </member>
        <member name="P:TED.TablePredicate.Overwrite">
            <summary>
            If adding a row with the same key as an existing row, overwrite the original row rather
            than throwing an exception.
            This requires that there be exactly one key index.
            </summary>
        </member>
        <member name="M:TED.TablePredicate.AppendInputs">
            <summary>
            Append all the rows of the tables in Inputs to this table
            </summary>
        </member>
        <member name="P:TED.TablePredicate.Inputs">
            <summary>
            Table predicates that this table predicate accumulates, if any.
            </summary>
        </member>
        <member name="P:TED.TablePredicate.AddUntyped">
            <summary>
            Untyped interface to the .Add table.
            </summary>
        </member>
        <member name="P:TED.TablePredicate.InitialValueTable">
            <summary>
            The table that provides initial values to this table, if any.
            This is untyped, so you probably want to be using Initially instead.
            </summary>
        </member>
        <member name="M:TED.TablePredicate.op_Implicit(TED.TablePredicate)~TED.Interpreter.Goal">
            <summary>
            If you put a predicate in a rule body without arguments, it defaults to the rule's "default" arguments.
            </summary>
        </member>
        <member name="M:TED.TablePredicate.VerifyCsvColumnNames(System.String,System.String[],TED.Interpreter.IColumnSpec[])">
            <summary>
            Verify that the header row of a CSV file matches the declared variable names
            </summary>
        </member>
        <member name="M:TED.TablePredicate.CastArg``1(TED.Term,System.Int32)">
            <summary>
            Attempt to cast an untyped Term to a typed Term.  Throw an exception if it's not of the right type
            </summary>
            <param name="arg">Argument term</param>
            <param name="position">Which argument it is to the calling primitive</param>
            <typeparam name="T">Expected type</typeparam>
            <returns>Cast term</returns>
            <exception cref="T:System.ArgumentException">If it's the wrong type</exception>
        </member>
        <member name="M:TED.TablePredicate.Projection(System.Int32)">
            <summary>
            Return a function that returns the value of the specified column given a row.
            </summary>
        </member>
        <member name="M:TED.TablePredicate.Mutator(System.Int32)">
            <summary>
            Return a function that modifies the value of the specified column given a row.
            </summary>
        </member>
        <member name="M:TED.TablePredicate.Accessor``2(TED.Var{``1},TED.Var{``0})">
            <summary>
            Obtain an object that makes the column of the table behave like a dictionary
            Given the key for a row, you can get or set the value of the column
            </summary>
            <param name="key">Column to use as the key</param>
            <param name="column">Column to access</param>
            <typeparam name="TColumn">Data type of the column</typeparam>
            <typeparam name="TKey">Data type of the key</typeparam>
            <returns>The accessor that lets you read and write column data</returns>
        </member>
        <member name="M:TED.TablePredicate.Accessor``3(TED.Var{``1},TED.Var{``2},TED.Var{``0})">
            <summary>
            Obtain an object that makes the column of the table behave like a dictionary
            Given the key for a row, you can get or set the value of the column
            </summary>
            <param name="key1">Column to use as the first half of the key</param>
            <param name="key2">Column to use as the second half of the key</param>
            <param name="column">Column to access</param>
            <typeparam name="TColumn">Data type of the column</typeparam>
            <typeparam name="TKey1">Data type of the first key column</typeparam>
            <typeparam name="TKey2">Data type of the second key column</typeparam>
            <returns>The accessor that lets you read and write column data</returns>
        </member>
        <member name="M:TED.TablePredicate.ColumnValueFromRowNumber``1(TED.Var{``0})">
            <summary>
            Returns a procedure that given a row number within the table returns the value of the specified column for that row.
            </summary>
            <param name="column">Column to get the value of</param>
            <typeparam name="TColumn">Data type of the column</typeparam>
            <returns>Procedure mapping row numbers to the value of the row's column.</returns>
        </member>
        <member name="M:TED.TablePredicate.RowComparison``2(TED.Tables.Table{``0},System.Int32)">
            <summary>
            Returns a comparison that given the indices of two rows in the table, compares the specified column for the two rows.
            </summary>
        </member>
        <member name="M:TED.TablePredicate.RowComparison(System.Int32)">
            <summary>
            Given a column number, returns a comparison (greater/less than test) that compares the values
            of the column given two row numbers.
            </summary>
        </member>
        <member name="E:TED.TablePredicate.OnUpdateColumns">
            <summary>
            List of procedures to call when the table is updated.
            </summary>
        </member>
        <member name="P:TED.TablePredicate.ColumnUpdateTables">
            <summary>
            Tables that drive updates of columns of this table
            </summary>
        </member>
        <member name="M:TED.TablePredicate.Set``2(TED.Var{``0},TED.Var{``1})">
            <summary>
            Return a table predicate to which rules can be added to update the specified column of this table predicate
            given a key for the row to update.
            </summary>
        </member>
        <member name="M:TED.TablePredicate.Set``3(System.ValueTuple{TED.Var{``0},TED.Var{``1}},TED.Var{``2})">
            <summary>
            Return a table predicate to which rules can be added to update the specified column of this table predicate
            given a key for the row to update.
            </summary>
        </member>
        <member name="M:TED.TablePredicate.Set``2(TED.Var{``0},TED.Var{``1},TED.Term{``1})">
            <summary>
            Sets the conditions for resetting the specified column to the specified value
            </summary>
        </member>
        <member name="M:TED.TablePredicate.Set``3(System.ValueTuple{TED.Var{``0},TED.Var{``1}},TED.Var{``2},TED.Term{``2})">
            <summary>
            Sets the conditions for resetting the specified column to the specified value
            </summary>
        </member>
        <member name="M:TED.TablePredicate.UpdateColumns">
            <summary>
            Run any column updates for this table
            </summary>
        </member>
        <member name="M:TED.TablePredicate.ToString">
            <inheritdoc />
        </member>
        <member name="F:TED.TablePredicate.Property">
            <summary>
            Property list for meta-data.
            For Boolean data, Feature[] is preferred.
            </summary>
        </member>
        <member name="F:TED.TablePredicate.Feature">
            <summary>
            Boolean meta-data about the table.
            For non-Boolean data, use Property[]
            </summary>
        </member>
        <member name="F:TED.TablePredicate.UpdaterFor">
            <summary>
            Name of the metadata property indicating that this table predicate is an internal table
            make for updating another table using Input or Set().
            </summary>
        </member>
        <member name="F:TED.TablePredicate.VisualizerName">
            <summary>
            Name of the metadata property specifying a preferred name to include in a dataflow visualization
            </summary>
        </member>
        <member name="P:TED.TablePredicate.UpdateTask">
            <summary>
            Task object for updating this table, if running in parallel mode.
            </summary>
        </member>
        <member name="P:TED.TablePredicate.TotalExecutionTime">
            <summary>
            Total number of milliseconds spent updating this table predicate since the start of the program.
            </summary>
        </member>
        <member name="M:TED.TablePredicate.Problem(System.String)">
            <summary>
            Used to add assertions to the Problems table for the current program.
            Usage: predicate.Problem(message).If(conditions...)
            </summary>
        </member>
        <member name="M:TED.TablePredicate.ColumnTest(System.Int32,System.Object)">
            <summary>
            Returns a delegate that will test a RowTest delegate for this table that tests whether the specified column has the specified value.
            </summary>
        </member>
        <member name="M:TED.TablePredicate.ReclaimRowsWithColumnValue``1(TED.Var{``0},``0,System.Single)">
            <summary>
            Set the table to reclaim rows whose specified column have the specified value, when the table runs out of space.
            Reclamation is triggered when the table runs out of space in its current backing array, or when Reclaim() is called
            </summary>
            <param name="column">Column whose value should be tested</param>
            <param name="value">If column has this value, it can be reclaimed.</param>
            <param name="targetLoad">If reclamation is triggered because the table is out of space, and the fraction of space used after reclamation is more than this, the table's array will be expanded.</param>
        </member>
        <member name="M:TED.TablePredicate.Reclaim">
            <summary>
            Force deletion of rows indicated by a previous call to ReclaimRowsWithColumnValue.
            This will not expand the underlying array for the table.
            </summary>
        </member>
        <member name="T:TED.TablePredicate`1">
            <summary>
            A 1-argument TablePredicate
            </summary>
            <typeparam name="T1">Type of the predicate's argument</typeparam>
        </member>
        <member name="P:TED.TablePredicate`1.Item(TED.Term{`0})">
            <summary>
            Make a Goal from this predicate with the specified argument value.
            </summary>
        </member>
        <member name="M:TED.TablePredicate`1.GetGoal(TED.Term[])">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`1.AddIndex(System.Int32,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`1.AddIndex``2(TED.Var{``0},TED.Var{``1},System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`1.AddIndex(System.Int32,System.Int32,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`1.If(TED.Interpreter.Goal[])">
            <summary>
            Add a rule to the predicate, using its default arguments as the head
            </summary>
            <param name="body">Antecedents for the rule</param>
            <returns>The original predicate (so these can be chained)</returns>
        </member>
        <member name="M:TED.TablePredicate`1.Where(TED.Interpreter.Goal[])">
            <summary>
            Add a rule to the predicate, using its default arguments as the head
            </summary>
            <param name="body">Antecedents for the rule</param>
            <returns>The original predicate (so these can be chained)</returns>
        </member>
        <member name="M:TED.TablePredicate`1.#ctor(System.String,TED.Interpreter.IColumnSpec{`0})">
            <summary>
            Make a new table predicate with the specified name
            </summary>
            <param name="name">Name of the predicate</param>
            <param name="arg1">Default variable for the first argument</param>
        </member>
        <member name="M:TED.TablePredicate`1.#ctor(System.String,System.Action{TED.Tables.Table},TED.Interpreter.IColumnSpec{`0})">
            <summary>
            Make a new table predicate with the specified name
            </summary>
            <param name="name">Name of the predicate</param>
            <param name="updateProc">Procedure to call to update the contents of the table.  This should only be used for tables that are the results of operators</param>
            <param name="arg1">Default variable for the first argument</param>
        </member>
        <member name="M:TED.TablePredicate`1.FromCsv(System.String,System.String,TED.Interpreter.IColumnSpec{`0})">
            <summary>
            Read an extensional predicate from a CSV file
            </summary>
            <param name="name">Predicate name</param>
            <param name="path">Path to the CSV file</param>
            <param name="arg1">Default argument to the predicate</param>
            <returns>The TablePredicate</returns>
        </member>
        <member name="M:TED.TablePredicate`1.FromCsv(System.String,TED.Interpreter.IColumnSpec{`0})">
            <summary>
            Read an extensional predicate from a CSV file
            </summary>
            <param name="path">Path to the CSV file</param>
            <param name="arg1">Argument to the predicate</param>
            <returns>The TablePredicate</returns>
        </member>
        <member name="M:TED.TablePredicate`1.LoadCsv(System.String,System.String)">
            <inheritdoc />
        </member>
        <member name="P:TED.TablePredicate`1.Length">
            <summary>
            Number of rows/items in the table/extension of the predicate
            </summary>
        </member>
        <member name="M:TED.TablePredicate`1.AddRow(`0@)">
            <summary>
            Manually add a row (ground instance) to the extension of the predicate
            This cannot be mixed with rules using If.  If you want to have rules for the predicate
            use Fact() instead of AddRow.
            </summary>
        </member>
        <member name="M:TED.TablePredicate`1.AddRows(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add a set of rows from a generator
            </summary>
        </member>
        <member name="M:TED.TablePredicate`1.GetUntypedRowData(System.UInt32,System.Object[])">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`1.RowToStrings(System.UInt32,System.String[])">
            <summary>
            Convert the columns of the specified row to strings and write them to buffer
            </summary>
        </member>
        <member name="M:TED.TablePredicate`1.RowToCsv(System.UInt32,System.String[])">
            <summary>
            Convert the columns of the specified row to strings and write them to buffer
            </summary>
        </member>
        <member name="M:TED.TablePredicate`1.UpdateRows(TED.TablePredicate.Update{`0})">
            <summary>
            Call method on every row of the table, passing it a reference so it can rewrite it as it likes
            </summary>
            <param name="u"></param>
        </member>
        <member name="M:TED.TablePredicate`1.Append(TED.TablePredicate{`0})">
            <summary>
            Add rows of t to rows of this predicate
            </summary>
        </member>
        <member name="P:TED.TablePredicate`1.Inputs">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`1.Accumulates(TED.TablePredicate{`0})">
            <summary>
            Declare that on each simulation tick, the contents of the specified tables should be appended to this table.
            </summary>
            <param name="input">Predicate to append to this predicate on each tick</param>
            <returns>This predicate</returns>
        </member>
        <member name="P:TED.TablePredicate`1.Add">
            <summary>
            A predicate that is automatically appended to this predicate on every update.
            </summary>
        </member>
        <member name="P:TED.TablePredicate`1.AddUntyped">
            <inheritdoc />
        </member>
        <member name="P:TED.TablePredicate`1.Initially">
            <summary>
            A predicate that is automatically appended to this predicate on every update.
            </summary>
        </member>
        <member name="P:TED.TablePredicate`1.InitialValueTable">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`1.Projection(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`1.Mutator(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`1.RowComparison(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`1.ColumnValueFromRowNumber``1(TED.Var{``0})">
            <inheritdoc />
        </member>
        <member name="T:TED.TablePredicate`2">
            <summary>
            A 2-argument TablePredicate
            </summary>
            <typeparam name="T1">Type of the predicate's 1st argument</typeparam>
            <typeparam name="T2">Type of the predicate's 2nd argument</typeparam>
        </member>
        <member name="P:TED.TablePredicate`2.Item(TED.Term{`0},TED.Term{`1})">
            <summary>
            Make a Goal from this predicate with the specified argument value.
            </summary>
        </member>
        <member name="M:TED.TablePredicate`2.GetGoal(TED.Term[])">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`2.AddIndex(System.Int32,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`2.AddIndex``2(TED.Var{``0},TED.Var{``1},System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`2.AddIndex(System.Int32,System.Int32,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`2.#ctor(System.String,TED.Interpreter.IColumnSpec{`0},TED.Interpreter.IColumnSpec{`1})">
            <summary>
            Make a new table predicate with the specified name
            </summary>
            <param name="name">Name of the predicate</param>
            <param name="arg1">Default variable for the first argument</param>
            <param name="arg2">Default variable for the second argument</param>
        </member>
        <member name="M:TED.TablePredicate`2.#ctor(System.String,System.Action{TED.Tables.Table},TED.Interpreter.IColumnSpec{`0},TED.Interpreter.IColumnSpec{`1})">
            <summary>
            Make a new table predicate with the specified name
            </summary>
            <param name="name">Name of the predicate</param>
            <param name="updateProc">Procedure to call to update the contents of the table.  This should only be used for tables that are the results of operators</param>
            <param name="arg1">Default variable for the first argument</param>
            <param name="arg2">Default variable for the second argument</param>
        </member>
        <member name="P:TED.TablePredicate`2.Length">
            <summary>
            The number of rows in the table (i.e. the number of tuples in the extension of the predicate)
            </summary>
        </member>
        <member name="M:TED.TablePredicate`2.AddRow(`0@,`1@)">
            <summary>
            Manually add a row (ground instance) to the extension of the predicate
            This cannot be mixed with rules using If.  If you want to have rules for the predicate
            use Fact() instead of AddRow.
            </summary>
        </member>
        <member name="M:TED.TablePredicate`2.AddRows(System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1}})">
            <summary>
            Add a set of rows from a generator
            </summary>
        </member>
        <member name="M:TED.TablePredicate`2.FromCsv(System.String,System.String,TED.Interpreter.IColumnSpec{`0},TED.Interpreter.IColumnSpec{`1})">
            <summary>
            Read an extensional predicate from a CSV file
            </summary>
            <param name="name">Predicate name</param>
            <param name="path">Path to the CSV file</param>
            <param name="arg1">First argument</param>
            <param name="arg2">Second argument</param>
            <returns>The TablePredicate</returns>
        </member>
        <member name="M:TED.TablePredicate`2.FromCsv(System.String,TED.Interpreter.IColumnSpec{`0},TED.Interpreter.IColumnSpec{`1})">
            <summary>
            Read an extensional predicate from a CSV file
            </summary>
            <param name="path">Path to the CSV file</param>
            <param name="arg1">First argument</param>
            <param name="arg2">Second argument</param>
            <returns>The TablePredicate</returns>
        </member>
        <member name="M:TED.TablePredicate`2.GetUntypedRowData(System.UInt32,System.Object[])">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`2.RowToStrings(System.UInt32,System.String[])">
            <summary>
            Convert the columns of the specified row to strings and write them to buffer
            </summary>
        </member>
        <member name="M:TED.TablePredicate`2.RowToCsv(System.UInt32,System.String[])">
            <summary>
            Convert the columns of the specified row to strings and write them to buffer
            </summary>
        </member>
        <member name="M:TED.TablePredicate`2.UpdateRows(TED.TablePredicate.Update{System.ValueTuple{`0,`1}})">
            <summary>
            Call method on every row of the table, passing it a reference so it can rewrite it as it likes
            </summary>
            <param name="u"></param>
        </member>
        <member name="M:TED.TablePredicate`2.Append(TED.TablePredicate{`0,`1})">
            <summary>
            Add rows of t to rows of this predicate
            </summary>
        </member>
        <member name="M:TED.TablePredicate`2.If(TED.Interpreter.Goal[])">
            <summary>
            Add a rule using the default arguments as the head.
            </summary>
            <param name="body">subgoals</param>
            <returns>the original predicate</returns>
        </member>
        <member name="M:TED.TablePredicate`2.Where(TED.Interpreter.Goal[])">
            <summary>
            Add a rule to the predicate, using its default arguments as the head
            </summary>
            <param name="body">Antecedents for the rule</param>
            <returns>The original predicate (so these can be chained)</returns>
        </member>
        <member name="P:TED.TablePredicate`2.Inputs">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`2.Accumulates(TED.TablePredicate{`0,`1})">
            <summary>
            Declare that on each simulation tick, the contents of the specified tables should be appended to this table.
            </summary>
            <param name="input">Predicate to append to this predicate on each tick</param>
            <returns>This predicate</returns>
        </member>
        <member name="P:TED.TablePredicate`2.Add">
            <summary>
            A predicate that is automatically appended to this predicate on every update.
            </summary>
        </member>
        <member name="P:TED.TablePredicate`2.AddUntyped">
            <inheritdoc />
        </member>
        <member name="P:TED.TablePredicate`2.Initially">
            <summary>
            A predicate that is automatically appended to this predicate on every update.
            </summary>
        </member>
        <member name="P:TED.TablePredicate`2.InitialValueTable">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`2.KeyIndex``1(TED.Var{``0})">
            <summary>
            Get the index for the specified key
            </summary>
            <typeparam name="T">Type of the indexed column</typeparam>
            <param name="column">Default variable representing the column</param>
            <returns>The index</returns>
            <exception cref="T:System.InvalidOperationException">If there is no index or it's not a key index</exception>
        </member>
        <member name="M:TED.TablePredicate`2.KeyIndex``1(System.Int32)">
            <summary>
            Get the index for the specified key
            </summary>
            <typeparam name="T">Type of the indexed column</typeparam>
            <param name="column">Position of the column</param>
            <returns>The index</returns>
            <exception cref="T:System.InvalidOperationException">If there is no index or it's not a key index</exception>
        </member>
        <member name="M:TED.TablePredicate`2.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`2.Projection(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`2.Mutator(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`2.Accessor``2(TED.Var{``1},TED.Var{``0})">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`2.RowComparison(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`2.ColumnValueFromRowNumber``1(TED.Var{``0})">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`2.ColumnTest(System.Int32,System.Object)">
            <inheritdoc />
        </member>
        <member name="T:TED.TablePredicate`3">
            <summary>
            A 3-argument TablePredicate
            </summary>
            <typeparam name="T1">Type of the predicate's 1st argument</typeparam>
            <typeparam name="T2">Type of the predicate's 2nd argument</typeparam>
            <typeparam name="T3">Type of the predicate's 3rd argument</typeparam>
        </member>
        <member name="P:TED.TablePredicate`3.Item(TED.Term{`0},TED.Term{`1},TED.Term{`2})">
            <summary>
            Make a Goal from this predicate with the specified argument value.
            </summary>
        </member>
        <member name="M:TED.TablePredicate`3.GetGoal(TED.Term[])">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`3.AddIndex(System.Int32,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`3.AddIndex``2(TED.Var{``0},TED.Var{``1},System.Boolean)">
            <summary>
            Add an index on a pair of columns
            </summary>
            <param name="c1">First column</param>
            <param name="c2">Second column</param>
            <param name="keyIndex">True if the two columns function as a key, i.e. now two rows will have the same values for the two at the same time</param>
            <typeparam name="TColumn1">Type of the first column</typeparam>
            <typeparam name="TColumn2">Type of the second column</typeparam>
        </member>
        <member name="M:TED.TablePredicate`3.AddIndex(System.Int32,System.Int32,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`3.JointKey``2(TED.Var{``0},TED.Var{``1})">
            <summary>
            Add a key index with the two specified columns jointly forming the key
            </summary>
        </member>
        <member name="M:TED.TablePredicate`3.JointIndex``2(TED.Var{``0},TED.Var{``1},System.Nullable{System.Int32})">
            <summary>
            Add an index on the two specified columns 
            </summary>
        </member>
        <member name="M:TED.TablePredicate`3.KeyIndex``1(TED.Var{``0})">
            <summary>
            Get the index for the specified key
            </summary>
            <typeparam name="T">Type of the indexed column</typeparam>
            <param name="column">Default variable representing the column</param>
            <returns>The index</returns>
            <exception cref="T:System.InvalidOperationException">If there is no index or it's not a key index</exception>
        </member>
        <member name="M:TED.TablePredicate`3.KeyIndex``1(System.Int32)">
            <summary>
            Get the index for the specified key
            </summary>
            <typeparam name="T">Type of the indexed column</typeparam>
            <param name="column">Position of column</param>
            <returns>The index</returns>
            <exception cref="T:System.InvalidOperationException">If there is no index or it's not a key index</exception>
        </member>
        <member name="M:TED.TablePredicate`3.#ctor(System.String,TED.Interpreter.IColumnSpec{`0},TED.Interpreter.IColumnSpec{`1},TED.Interpreter.IColumnSpec{`2})">
            <summary>
            Make a new table predicate with the specified name
            </summary>
            <param name="name">Name of the predicate</param>
            <param name="arg1">Default variable for the first argument</param>
            <param name="arg2">Default variable for the second argument</param>
            <param name="arg3">Default variable for the third argument</param>
        </member>
        <member name="M:TED.TablePredicate`3.#ctor(System.String,System.Action{TED.Tables.Table},TED.Interpreter.IColumnSpec{`0},TED.Interpreter.IColumnSpec{`1},TED.Interpreter.IColumnSpec{`2})">
            <summary>
            Make a new table predicate with the specified name
            </summary>
            <param name="name">Name of the predicate</param>
            <param name="updateProc">Procedure to call to update the contents of the table.  This should only be used for tables that are the results of operators</param>
            <param name="arg1">Default variable for the first argument</param>
            <param name="arg2">Default variable for the second argument</param>
            <param name="arg3">Default variable for the third argument</param>
        </member>
        <member name="P:TED.TablePredicate`3.Length">
            <summary>
            The number of rows in the table (i.e. the number of tuples in the extension of the predicate)
            </summary>
        </member>
        <member name="M:TED.TablePredicate`3.AddRow(`0@,`1@,`2@)">
            <summary>
            Manually add a row (ground instance) to the extension of the predicate
            This cannot be mixed with rules using If.  If you want to have rules for the predicate
            use Fact() instead of AddRow.
            </summary>
        </member>
        <member name="M:TED.TablePredicate`3.AddRows(System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1,`2}})">
            <summary>
            Add a set of rows from a generator
            </summary>
        </member>
        <member name="M:TED.TablePredicate`3.FromCsv(System.String,System.String,TED.Interpreter.IColumnSpec{`0},TED.Interpreter.IColumnSpec{`1},TED.Interpreter.IColumnSpec{`2})">
            <summary>
            Read an extensional predicate from a CSV file
            </summary>
            <param name="name">Predicate name</param>
            <param name="path">Path to the CSV file</param>
            <param name="arg1">First argument</param>
            <param name="arg2">Second argument</param>
            <param name="arg3">Third argument</param>
            <returns>The TablePredicate</returns>
        </member>
        <member name="M:TED.TablePredicate`3.FromCsv(System.String,TED.Interpreter.IColumnSpec{`0},TED.Interpreter.IColumnSpec{`1},TED.Interpreter.IColumnSpec{`2})">
            <summary>
            Read an extensional predicate from a CSV file
            </summary>
            <param name="path">Path to the CSV file</param>
            <param name="arg1">First argument</param>
            <param name="arg2">Second argument</param>
            <param name="arg3">Third argument</param>
            <returns>The TablePredicate</returns>
        </member>
        <member name="M:TED.TablePredicate`3.GetUntypedRowData(System.UInt32,System.Object[])">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`3.RowToStrings(System.UInt32,System.String[])">
            <summary>
            Convert the columns of the specified row to strings and write them to buffer
            </summary>
        </member>
        <member name="M:TED.TablePredicate`3.RowToCsv(System.UInt32,System.String[])">
            <summary>
            Convert the columns of the specified row to strings and write them to buffer
            </summary>
        </member>
        <member name="M:TED.TablePredicate`3.UpdateRows(TED.TablePredicate.Update{System.ValueTuple{`0,`1,`2}})">
            <summary>
            Call method on every row of the table, passing it a reference so it can rewrite it as it likes
            </summary>
            <param name="u"></param>
        </member>
        <member name="M:TED.TablePredicate`3.Append(TED.TablePredicate{`0,`1,`2})">
            <summary>
            Add rows of t to rows of this predicate
            </summary>
        </member>
        <member name="M:TED.TablePredicate`3.If(TED.Interpreter.Goal[])">
            <summary>
            Add a rule using the default arguments as the head.
            </summary>
            <param name="body">subgoals</param>
            <returns>the original predicate</returns>
        </member>
        <member name="M:TED.TablePredicate`3.Where(TED.Interpreter.Goal[])">
            <summary>
            Add a rule to the predicate, using its default arguments as the head
            </summary>
            <param name="body">Antecedents for the rule</param>
            <returns>The original predicate (so these can be chained)</returns>
        </member>
        <member name="P:TED.TablePredicate`3.Inputs">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`3.Accumulates(TED.TablePredicate{`0,`1,`2})">
            <summary>
            Declare that on each simulation tick, the contents of the specified tables should be appended to this table.
            </summary>
            <param name="input">Predicate to append to this predicate on each tick</param>
            <returns>This predicate</returns>
        </member>
        <member name="P:TED.TablePredicate`3.Add">
            <summary>
            A predicate that is automatically appended to this predicate on every update.
            </summary>
        </member>
        <member name="P:TED.TablePredicate`3.AddUntyped">
            <inheritdoc />
        </member>
        <member name="P:TED.TablePredicate`3.Initially">
            <summary>
            A predicate that is automatically appended to this predicate on every update.
            </summary>
        </member>
        <member name="P:TED.TablePredicate`3.InitialValueTable">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`3.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`3.Projection(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`3.Mutator(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`3.Accessor``2(TED.Var{``1},TED.Var{``0})">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`3.Accessor``3(TED.Var{``1},TED.Var{``2},TED.Var{``0})">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`3.RowComparison(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`3.ColumnValueFromRowNumber``1(TED.Var{``0})">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`3.ColumnTest(System.Int32,System.Object)">
            <inheritdoc />
        </member>
        <member name="T:TED.TablePredicate`4">
            <summary>
            A 4-argument TablePredicate
            </summary>
            <typeparam name="T1">Type of the predicate's 1st argument</typeparam>
            <typeparam name="T2">Type of the predicate's 2nd argument</typeparam>
            <typeparam name="T3">Type of the predicate's 3rd argument</typeparam>
            <typeparam name="T4">Type of the predicate's 4th argument</typeparam>
        </member>
        <member name="P:TED.TablePredicate`4.Item(TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3})">
            <summary>
            Make a Goal from this predicate with the specified argument value.
            </summary>
        </member>
        <member name="M:TED.TablePredicate`4.GetGoal(TED.Term[])">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`4.AddIndex(System.Int32,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`4.AddIndex``2(TED.Var{``0},TED.Var{``1},System.Boolean)">
            <summary>
            Add an index on a pair of columns
            </summary>
            <param name="c1">First column</param>
            <param name="c2">Second column</param>
            <param name="keyIndex">True if the two columns function as a key, i.e. now two rows will have the same values for the two at the same time</param>
            <typeparam name="TColumn1">Type of the first column</typeparam>
            <typeparam name="TColumn2">Type of the second column</typeparam>
        </member>
        <member name="M:TED.TablePredicate`4.AddIndex(System.Int32,System.Int32,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`4.JointKey``2(TED.Var{``0},TED.Var{``1})">
            <summary>
            Add a key index with the two specified columns jointly forming the key
            </summary>
        </member>
        <member name="M:TED.TablePredicate`4.JointIndex``2(TED.Var{``0},TED.Var{``1},System.Nullable{System.Int32})">
            <summary>
            Add an index on the two specified columns 
            </summary>
        </member>
        <member name="M:TED.TablePredicate`4.KeyIndex``1(TED.Var{``0})">
            <summary>
            Get the index for the specified key
            </summary>
            <typeparam name="TKey">Type of the indexed column</typeparam>
            <param name="column">Default variable representing the column</param>
            <returns>The index</returns>
            <exception cref="T:System.InvalidOperationException">If there is no index or it's not a key index</exception>
        </member>
        <member name="M:TED.TablePredicate`4.KeyIndex``1(System.Int32)">
            <summary>
            Get the index for the specified key
            </summary>
            <typeparam name="TKey">Type of the indexed column</typeparam>
            <param name="column">Position the column</param>
            <returns>The index</returns>
            <exception cref="T:System.InvalidOperationException">If there is no index or it's not a key index</exception>
        </member>
        <member name="M:TED.TablePredicate`4.#ctor(System.String,TED.Interpreter.IColumnSpec{`0},TED.Interpreter.IColumnSpec{`1},TED.Interpreter.IColumnSpec{`2},TED.Interpreter.IColumnSpec{`3})">
            <summary>
            Make a new table predicate with the specified name
            </summary>
            <param name="name">Name of the predicate</param>
            <param name="arg1">Default variable for the first argument</param>
            <param name="arg2">Default variable for the second argument</param>
            <param name="arg3">Default variable for the third argument</param>
            <param name="arg4">Default variable for the fourth argument</param>
        </member>
        <member name="M:TED.TablePredicate`4.#ctor(System.String,System.Action{TED.Tables.Table},TED.Interpreter.IColumnSpec{`0},TED.Interpreter.IColumnSpec{`1},TED.Interpreter.IColumnSpec{`2},TED.Interpreter.IColumnSpec{`3})">
            <summary>
            Make a new table predicate with the specified name
            </summary>
            <param name="name">Name of the predicate</param>
            <param name="updateProc">Procedure to call to update the contents of the table.  This should only be used for tables that are the results of operators</param>
            <param name="arg1">Default variable for the first argument</param>
            <param name="arg2">Default variable for the second argument</param>
            <param name="arg3">Default variable for the third argument</param>
            <param name="arg4">Default variable for the fourth argument</param>
        </member>
        <member name="P:TED.TablePredicate`4.Length">
            <summary>
            The number of rows in the table (i.e. the number of tuples in the extension of the predicate)
            </summary>
        </member>
        <member name="M:TED.TablePredicate`4.AddRow(`0@,`1@,`2@,`3@)">
            <summary>
            Manually add a row (ground instance) to the extension of the predicate
            This cannot be mixed with rules using If.  If you want to have rules for the predicate
            use Fact() instead of AddRow.
            </summary>
        </member>
        <member name="M:TED.TablePredicate`4.AddRows(System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1,`2,`3}})">
            <summary>
            Add a set of rows from a generator
            </summary>
        </member>
        <member name="M:TED.TablePredicate`4.FromCsv(System.String,System.String,TED.Interpreter.IColumnSpec{`0},TED.Interpreter.IColumnSpec{`1},TED.Interpreter.IColumnSpec{`2},TED.Interpreter.IColumnSpec{`3})">
            <summary>
            Read an extensional predicate from a CSV file
            </summary>
            <param name="name">Predicate name</param>
            <param name="path">Path to the CSV file</param>
            <param name="arg1">First argument</param>
            <param name="arg2">Second argument</param>
            <param name="arg3">Third argument</param>
            <param name="arg4">Fourth argument</param>
            <returns>The TablePredicate</returns>
        </member>
        <member name="M:TED.TablePredicate`4.FromCsv(System.String,TED.Interpreter.IColumnSpec{`0},TED.Interpreter.IColumnSpec{`1},TED.Interpreter.IColumnSpec{`2},TED.Interpreter.IColumnSpec{`3})">
            <summary>
            Read an extensional predicate from a CSV file
            </summary>
            <param name="path">Path to the CSV file</param>
            <param name="arg1">First argument</param>
            <param name="arg2">Second argument</param>
            <param name="arg3">Third argument</param>
            <param name="arg4">Fourth argument</param>
            <returns>The TablePredicate</returns>
        </member>
        <member name="M:TED.TablePredicate`4.GetUntypedRowData(System.UInt32,System.Object[])">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`4.RowToStrings(System.UInt32,System.String[])">
            <summary>
            Convert the columns of the specified row to strings and write them to buffer
            </summary>
        </member>
        <member name="M:TED.TablePredicate`4.RowToCsv(System.UInt32,System.String[])">
            <summary>
            Convert the columns of the specified row to strings and write them to buffer
            </summary>
        </member>
        <member name="M:TED.TablePredicate`4.UpdateRows(TED.TablePredicate.Update{System.ValueTuple{`0,`1,`2,`3}})">
            <summary>
            Call method on every row of the table, passing it a reference so it can rewrite it as it likes
            </summary>
            <param name="u"></param>
        </member>
        <member name="M:TED.TablePredicate`4.Append(TED.TablePredicate{`0,`1,`2,`3})">
            <summary>
            Add rows of t to rows of this predicate
            </summary>
        </member>
        <member name="M:TED.TablePredicate`4.If(TED.Interpreter.Goal[])">
            <summary>
            Add a rule using the default arguments as the head.
            </summary>
            <param name="body">subgoals</param>
            <returns>the original predicate</returns>
        </member>
        <member name="M:TED.TablePredicate`4.Where(TED.Interpreter.Goal[])">
            <summary>
            Add a rule to the predicate, using its default arguments as the head
            </summary>
            <param name="body">Antecedents for the rule</param>
            <returns>The original predicate (so these can be chained)</returns>
        </member>
        <member name="P:TED.TablePredicate`4.Inputs">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`4.Accumulates(TED.TablePredicate{`0,`1,`2,`3})">
            <summary>
            Declare that on each simulation tick, the contents of the specified tables should be appended to this table.
            </summary>
            <param name="input">Predicate to append to this predicate on each tick</param>
            <returns>This predicate</returns>
        </member>
        <member name="P:TED.TablePredicate`4.Add">
            <summary>
            A predicate that is automatically appended to this predicate on every update.
            </summary>
        </member>
        <member name="P:TED.TablePredicate`4.AddUntyped">
            <inheritdoc />
        </member>
        <member name="P:TED.TablePredicate`4.Initially">
            <summary>
            A predicate that is automatically appended to this predicate on every update.
            </summary>
        </member>
        <member name="P:TED.TablePredicate`4.InitialValueTable">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`4.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`4.Projection(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`4.Mutator(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`4.Accessor``2(TED.Var{``1},TED.Var{``0})">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`4.Accessor``3(TED.Var{``1},TED.Var{``2},TED.Var{``0})">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`4.RowComparison(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`4.ColumnValueFromRowNumber``1(TED.Var{``0})">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`4.ColumnTest(System.Int32,System.Object)">
            <inheritdoc />
        </member>
        <member name="T:TED.TablePredicate`5">
            <summary>
            A 5-argument TablePredicate
            </summary>
            <typeparam name="T1">Type of the predicate's 1st argument</typeparam>
            <typeparam name="T2">Type of the predicate's 2nd argument</typeparam>
            <typeparam name="T3">Type of the predicate's 3rd argument</typeparam>
            <typeparam name="T4">Type of the predicate's 4th argument</typeparam>
            <typeparam name="T5">Type of the predicate's 5th argument</typeparam>
        </member>
        <member name="P:TED.TablePredicate`5.Item(TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3},TED.Term{`4})">
            <summary>
            Make a Goal from this predicate with the specified argument value.
            </summary>
        </member>
        <member name="M:TED.TablePredicate`5.GetGoal(TED.Term[])">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`5.AddIndex(System.Int32,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`5.AddIndex``2(TED.Var{``0},TED.Var{``1},System.Boolean)">
            <summary>
            Add an index on a pair of columns
            </summary>
            <param name="c1">First column</param>
            <param name="c2">Second column</param>
            <param name="keyIndex">True if the two columns function as a key, i.e. now two rows will have the same values for the two at the same time</param>
            <typeparam name="TColumn1">Type of the first column</typeparam>
            <typeparam name="TColumn2">Type of the second column</typeparam>
        </member>
        <member name="M:TED.TablePredicate`5.AddIndex(System.Int32,System.Int32,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`5.JointKey``2(TED.Var{``0},TED.Var{``1})">
            <summary>
            Add a key index with the two specified columns jointly forming the key
            </summary>
        </member>
        <member name="M:TED.TablePredicate`5.JointIndex``2(TED.Var{``0},TED.Var{``1},System.Nullable{System.Int32})">
            <summary>
            Add an index on the two specified columns 
            </summary>
        </member>
        <member name="M:TED.TablePredicate`5.KeyIndex``1(TED.Var{``0})">
            <summary>
            Get the index for the specified key
            </summary>
            <typeparam name="TKey">Type of the indexed column</typeparam>
            <param name="column">Default variable representing the column</param>
            <returns>The index</returns>
            <exception cref="T:System.InvalidOperationException">If there is no index or it's not a key index</exception>
        </member>
        <member name="M:TED.TablePredicate`5.KeyIndex``1(System.Int32)">
            <summary>
            Get the index for the specified key
            </summary>
            <typeparam name="TKey">Type of the indexed column</typeparam>
            <param name="column">Position of the column</param>
            <returns>The index</returns>
            <exception cref="T:System.InvalidOperationException">If there is no index or it's not a key index</exception>
        </member>
        <member name="M:TED.TablePredicate`5.#ctor(System.String,TED.Interpreter.IColumnSpec{`0},TED.Interpreter.IColumnSpec{`1},TED.Interpreter.IColumnSpec{`2},TED.Interpreter.IColumnSpec{`3},TED.Interpreter.IColumnSpec{`4})">
            <summary>
            Make a new table predicate with the specified name
            </summary>
            <param name="name">Name of the predicate</param>
            <param name="arg1">Default variable for the first argument</param>
            <param name="arg2">Default variable for the second argument</param>
            <param name="arg3">Default variable for the third argument</param>
            <param name="arg4">Default variable for the fourth argument</param>
            <param name="arg5">Default variable for the fifth argument</param>
        </member>
        <member name="M:TED.TablePredicate`5.#ctor(System.String,System.Action{TED.Tables.Table},TED.Interpreter.IColumnSpec{`0},TED.Interpreter.IColumnSpec{`1},TED.Interpreter.IColumnSpec{`2},TED.Interpreter.IColumnSpec{`3},TED.Interpreter.IColumnSpec{`4})">
            <summary>
            Make a new table predicate with the specified name
            </summary>
            <param name="name">Name of the predicate</param>
            <param name="updateProc">Procedure to call to update the contents of the table.  This should only be used for tables that are the results of operators</param>
            <param name="arg1">Default variable for the first argument</param>
            <param name="arg2">Default variable for the second argument</param>
            <param name="arg3">Default variable for the third argument</param>
            <param name="arg4">Default variable for the fourth argument</param>
            <param name="arg5">Default variable for the fifth argument</param>
        </member>
        <member name="P:TED.TablePredicate`5.Length">
            <summary>
            The number of rows in the table (i.e. the number of tuples in the extension of the predicate)
            </summary>
        </member>
        <member name="M:TED.TablePredicate`5.AddRow(`0@,`1@,`2@,`3@,`4@)">
            <summary>
            Manually add a row (ground instance) to the extension of the predicate
            This cannot be mixed with rules using If.  If you want to have rules for the predicate
            use Fact() instead of AddRow.
            </summary>
        </member>
        <member name="M:TED.TablePredicate`5.AddRows(System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1,`2,`3,`4}})">
            <summary>
            Add a set of rows from a generator
            </summary>
        </member>
        <member name="M:TED.TablePredicate`5.FromCsv(System.String,System.String,TED.Interpreter.IColumnSpec{`0},TED.Interpreter.IColumnSpec{`1},TED.Interpreter.IColumnSpec{`2},TED.Interpreter.IColumnSpec{`3},TED.Interpreter.IColumnSpec{`4})">
            <summary>
            Read an extensional predicate from a CSV file
            </summary>
            <param name="name">Predicate name</param>
            <param name="path">Path to the CSV file</param>
            <param name="arg1">First argument</param>
            <param name="arg2">Second argument</param>
            <param name="arg3">Third argument</param>
            <param name="arg4">Fourth argument</param>
            <param name="arg5">Fifth argument</param>
            <returns>The TablePredicate</returns>
        </member>
        <member name="M:TED.TablePredicate`5.FromCsv(System.String,TED.Interpreter.IColumnSpec{`0},TED.Interpreter.IColumnSpec{`1},TED.Interpreter.IColumnSpec{`2},TED.Interpreter.IColumnSpec{`3},TED.Interpreter.IColumnSpec{`4})">
            <summary>
            Read an extensional predicate from a CSV file
            </summary>
            <param name="path">Path to the CSV file</param>
            <param name="arg1">First argument</param>
            <param name="arg2">Second argument</param>
            <param name="arg3">Third argument</param>
            <param name="arg4">Fourth argument</param>
            <param name="arg5">Fifth argument</param>
            <returns>The TablePredicate</returns>
        </member>
        <member name="M:TED.TablePredicate`5.GetUntypedRowData(System.UInt32,System.Object[])">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`5.RowToStrings(System.UInt32,System.String[])">
            <summary>
            Convert the columns of the specified row to strings and write them to buffer
            </summary>
        </member>
        <member name="M:TED.TablePredicate`5.RowToCsv(System.UInt32,System.String[])">
            <summary>
            Convert the columns of the specified row to strings and write them to buffer
            </summary>
        </member>
        <member name="M:TED.TablePredicate`5.UpdateRows(TED.TablePredicate.Update{System.ValueTuple{`0,`1,`2,`3,`4}})">
            <summary>
            Call method on every row of the table, passing it a reference so it can rewrite it as it likes
            </summary>
            <param name="u"></param>
        </member>
        <member name="M:TED.TablePredicate`5.Append(TED.TablePredicate{`0,`1,`2,`3,`4})">
            <summary>
            Add rows of t to rows of this predicate
            </summary>
        </member>
        <member name="M:TED.TablePredicate`5.If(TED.Interpreter.Goal[])">
            <summary>
            Add a rule using the default arguments as the head.
            </summary>
            <param name="body">subgoals</param>
            <returns>the original predicate</returns>
        </member>
        <member name="M:TED.TablePredicate`5.Where(TED.Interpreter.Goal[])">
            <summary>
            Add a rule to the predicate, using its default arguments as the head
            </summary>
            <param name="body">Antecedents for the rule</param>
            <returns>The original predicate (so these can be chained)</returns>
        </member>
        <member name="P:TED.TablePredicate`5.Inputs">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`5.Accumulates(TED.TablePredicate{`0,`1,`2,`3,`4})">
            <summary>
            Declare that on each simulation tick, the contents of the specified tables should be appended to this table.
            </summary>
            <param name="input">Predicate to append to this predicate on each tick</param>
            <returns>This predicate</returns>
        </member>
        <member name="P:TED.TablePredicate`5.Add">
            <summary>
            A predicate that is automatically appended to this predicate on every update.
            </summary>
        </member>
        <member name="P:TED.TablePredicate`5.AddUntyped">
            <inheritdoc />
        </member>
        <member name="P:TED.TablePredicate`5.Initially">
            <summary>
            A predicate that is automatically appended to this predicate on every update.
            </summary>
        </member>
        <member name="P:TED.TablePredicate`5.InitialValueTable">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`5.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`5.Projection(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`5.Mutator(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`5.Accessor``2(TED.Var{``1},TED.Var{``0})">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`5.Accessor``3(TED.Var{``1},TED.Var{``2},TED.Var{``0})">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`5.RowComparison(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`5.ColumnValueFromRowNumber``1(TED.Var{``0})">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`5.ColumnTest(System.Int32,System.Object)">
            <inheritdoc />
        </member>
        <member name="T:TED.TablePredicate`6">
            <summary>
            A 6-argument TablePredicate
            </summary>
            <typeparam name="T1">Type of the predicate's 1st argument</typeparam>
            <typeparam name="T2">Type of the predicate's 2nd argument</typeparam>
            <typeparam name="T3">Type of the predicate's 3rd argument</typeparam>
            <typeparam name="T4">Type of the predicate's 4th argument</typeparam>
            <typeparam name="T5">Type of the predicate's 5th argument</typeparam>
            <typeparam name="T6">Type of the predicate's 6th argument</typeparam>
        </member>
        <member name="P:TED.TablePredicate`6.Item(TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3},TED.Term{`4},TED.Term{`5})">
            <summary>
            Make a Goal from this predicate with the specified argument value.
            </summary>
        </member>
        <member name="M:TED.TablePredicate`6.GetGoal(TED.Term[])">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`6.AddIndex(System.Int32,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`6.AddIndex``2(TED.Var{``0},TED.Var{``1},System.Boolean)">
            <summary>
            Add an index on a pair of columns
            </summary>
            <param name="c1">First column</param>
            <param name="c2">Second column</param>
            <param name="keyIndex">True if the two columns function as a key, i.e. now two rows will have the same values for the two at the same time</param>
            <typeparam name="TColumn1">Type of the first column</typeparam>
            <typeparam name="TColumn2">Type of the second column</typeparam>
        </member>
        <member name="M:TED.TablePredicate`6.AddIndex(System.Int32,System.Int32,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`6.JointKey``2(TED.Var{``0},TED.Var{``1})">
            <summary>
            Add a key index with the two specified columns jointly forming the key
            </summary>
        </member>
        <member name="M:TED.TablePredicate`6.JointIndex``2(TED.Var{``0},TED.Var{``1},System.Nullable{System.Int32})">
            <summary>
            Add an index on the two specified columns 
            </summary>
        </member>
        <member name="M:TED.TablePredicate`6.KeyIndex``1(TED.Var{``0})">
            <summary>
            Get the index for the specified key
            </summary>
            <typeparam name="TKey">Type of the indexed column</typeparam>
            <param name="column">Default variable representing the column</param>
            <returns>The index</returns>
            <exception cref="T:System.InvalidOperationException">If there is no index or it's not a key index</exception>
        </member>
        <member name="M:TED.TablePredicate`6.KeyIndex``1(System.Int32)">
            <summary>
            Get the index for the specified key
            </summary>
            <typeparam name="TKey">Type of the indexed column</typeparam>
            <param name="column">Position of the column</param>
            <returns>The index</returns>
            <exception cref="T:System.InvalidOperationException">If there is no index or it's not a key index</exception>
        </member>
        <member name="M:TED.TablePredicate`6.#ctor(System.String,TED.Interpreter.IColumnSpec{`0},TED.Interpreter.IColumnSpec{`1},TED.Interpreter.IColumnSpec{`2},TED.Interpreter.IColumnSpec{`3},TED.Interpreter.IColumnSpec{`4},TED.Interpreter.IColumnSpec{`5})">
            <summary>
            Make a new table predicate with the specified name
            </summary>
            <param name="name">Name of the predicate</param>
            <param name="arg1">Default variable for the first argument</param>
            <param name="arg2">Default variable for the second argument</param>
            <param name="arg3">Default variable for the third argument</param>
            <param name="arg4">Default variable for the fourth argument</param>
            <param name="arg5">Default variable for the fifth argument</param>
            <param name="arg6">Default variable for the sixth argument</param>
        </member>
        <member name="M:TED.TablePredicate`6.#ctor(System.String,System.Action{TED.Tables.Table},TED.Interpreter.IColumnSpec{`0},TED.Interpreter.IColumnSpec{`1},TED.Interpreter.IColumnSpec{`2},TED.Interpreter.IColumnSpec{`3},TED.Interpreter.IColumnSpec{`4},TED.Interpreter.IColumnSpec{`5})">
            <summary>
            Make a new table predicate with the specified name
            </summary>
            <param name="name">Name of the predicate</param>
            <param name="updateProc">Procedure to call to update the contents of the table.  This should only be used for tables that are the results of operators</param>
            <param name="arg1">Default variable for the first argument</param>
            <param name="arg2">Default variable for the second argument</param>
            <param name="arg3">Default variable for the third argument</param>
            <param name="arg4">Default variable for the fourth argument</param>
            <param name="arg5">Default variable for the fifth argument</param>
            <param name="arg6">Default variable for the sixth argument</param>
        </member>
        <member name="P:TED.TablePredicate`6.Length">
            <summary>
            The number of rows in the table (i.e. the number of tuples in the extension of the predicate)
            </summary>
        </member>
        <member name="M:TED.TablePredicate`6.AddRow(`0@,`1@,`2@,`3@,`4@,`5@)">
            <summary>
            Manually add a row (ground instance) to the extension of the predicate
            This cannot be mixed with rules using If.  If you want to have rules for the predicate
            use Fact() instead of AddRow.
            </summary>
        </member>
        <member name="M:TED.TablePredicate`6.AddRows(System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1,`2,`3,`4,`5}})">
            <summary>
            Add a set of rows from a generator
            </summary>
        </member>
        <member name="M:TED.TablePredicate`6.FromCsv(System.String,System.String,TED.Interpreter.IColumnSpec{`0},TED.Interpreter.IColumnSpec{`1},TED.Interpreter.IColumnSpec{`2},TED.Interpreter.IColumnSpec{`3},TED.Interpreter.IColumnSpec{`4},TED.Interpreter.IColumnSpec{`5})">
            <summary>
            Read an extensional predicate from a CSV file
            </summary>
            <param name="name">Predicate name</param>
            <param name="path">Path to the CSV file</param>
            <param name="arg1">First argument</param>
            <param name="arg2">Second argument</param>
            <param name="arg3">Third argument</param>
            <param name="arg4">Fourth argument</param>
            <param name="arg5">Fifth argument</param>
            <param name="arg6">Sixth argument</param>
            <returns>The TablePredicate</returns>
        </member>
        <member name="M:TED.TablePredicate`6.FromCsv(System.String,TED.Interpreter.IColumnSpec{`0},TED.Interpreter.IColumnSpec{`1},TED.Interpreter.IColumnSpec{`2},TED.Interpreter.IColumnSpec{`3},TED.Interpreter.IColumnSpec{`4},TED.Interpreter.IColumnSpec{`5})">
            <summary>
            Read an extensional predicate from a CSV file
            </summary>
            <param name="path">Path to the CSV file</param>
            <param name="arg1">First argument</param>
            <param name="arg2">Second argument</param>
            <param name="arg3">Third argument</param>
            <param name="arg4">Fourth argument</param>
            <param name="arg5">Fifth argument</param>
            <param name="arg6">Sixth argument</param>
            <returns>The TablePredicate</returns>
        </member>
        <member name="M:TED.TablePredicate`6.GetUntypedRowData(System.UInt32,System.Object[])">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`6.RowToStrings(System.UInt32,System.String[])">
            <summary>
            Convert the columns of the specified row to strings and write them to buffer
            </summary>
        </member>
        <member name="M:TED.TablePredicate`6.RowToCsv(System.UInt32,System.String[])">
            <summary>
            Convert the columns of the specified row to strings and write them to buffer
            </summary>
        </member>
        <member name="M:TED.TablePredicate`6.UpdateRows(TED.TablePredicate.Update{System.ValueTuple{`0,`1,`2,`3,`4,`5}})">
            <summary>
            Call method on every row of the table, passing it a reference so it can rewrite it as it likes
            </summary>
            <param name="u"></param>
        </member>
        <member name="M:TED.TablePredicate`6.Append(TED.TablePredicate{`0,`1,`2,`3,`4,`5})">
            <summary>
            Add rows of t to rows of this predicate
            </summary>
        </member>
        <member name="M:TED.TablePredicate`6.If(TED.Interpreter.Goal[])">
            <summary>
            Add a rule using the default arguments as the head.
            </summary>
            <param name="body">subgoals</param>
            <returns>the original predicate</returns>
        </member>
        <member name="M:TED.TablePredicate`6.Where(TED.Interpreter.Goal[])">
            <summary>
            Add a rule to the predicate, using its default arguments as the head
            </summary>
            <param name="body">Antecedents for the rule</param>
            <returns>The original predicate (so these can be chained)</returns>
        </member>
        <member name="P:TED.TablePredicate`6.Inputs">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`6.Accumulates(TED.TablePredicate{`0,`1,`2,`3,`4,`5})">
            <summary>
            Declare that on each simulation tick, the contents of the specified tables should be appended to this table.
            </summary>
            <param name="input">Predicate to append to this predicate on each tick</param>
            <returns>This predicate</returns>
        </member>
        <member name="P:TED.TablePredicate`6.Add">
            <summary>
            A predicate that is automatically appended to this predicate on every update.
            </summary>
        </member>
        <member name="P:TED.TablePredicate`6.AddUntyped">
            <inheritdoc />
        </member>
        <member name="P:TED.TablePredicate`6.Initially">
            <summary>
            A predicate that is automatically appended to this predicate on every update.
            </summary>
        </member>
        <member name="P:TED.TablePredicate`6.InitialValueTable">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`6.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`6.Projection(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`6.Mutator(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`6.Accessor``2(TED.Var{``1},TED.Var{``0})">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`6.Accessor``3(TED.Var{``1},TED.Var{``2},TED.Var{``0})">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`6.RowComparison(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`6.ColumnValueFromRowNumber``1(TED.Var{``0})">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`6.ColumnTest(System.Int32,System.Object)">
            <inheritdoc />
        </member>
        <member name="T:TED.TablePredicate`7">
            <summary>
            A 7-argument TablePredicate
            </summary>
            <typeparam name="T1">Type of the predicate's 1st argument</typeparam>
            <typeparam name="T2">Type of the predicate's 2nd argument</typeparam>
            <typeparam name="T3">Type of the predicate's 3rd argument</typeparam>
            <typeparam name="T4">Type of the predicate's 4th argument</typeparam>
            <typeparam name="T5">Type of the predicate's 5th argument</typeparam>
            <typeparam name="T6">Type of the predicate's 6th argument</typeparam>
            <typeparam name="T7">Type of the predicate's 7th argument</typeparam>
        </member>
        <member name="P:TED.TablePredicate`7.Item(TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3},TED.Term{`4},TED.Term{`5},TED.Term{`6})">
            <summary>
            Make a Goal from this predicate with the specified argument value.
            </summary>
        </member>
        <member name="M:TED.TablePredicate`7.GetGoal(TED.Term[])">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`7.AddIndex(System.Int32,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`7.AddIndex``2(TED.Var{``0},TED.Var{``1},System.Boolean)">
            <summary>
            Add an index on a pair of columns
            </summary>
            <param name="c1">First column</param>
            <param name="c2">Second column</param>
            <param name="keyIndex">True if the two columns function as a key, i.e. now two rows will have the same values for the two at the same time</param>
            <typeparam name="TColumn1">Type of the first column</typeparam>
            <typeparam name="TColumn2">Type of the second column</typeparam>
        </member>
        <member name="M:TED.TablePredicate`7.AddIndex(System.Int32,System.Int32,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`7.JointKey``2(TED.Var{``0},TED.Var{``1})">
            <summary>
            Add a key index with the two specified columns jointly forming the key
            </summary>
        </member>
        <member name="M:TED.TablePredicate`7.JointIndex``2(TED.Var{``0},TED.Var{``1},System.Nullable{System.Int32})">
            <summary>
            Add an index on the two specified columns 
            </summary>
        </member>
        <member name="M:TED.TablePredicate`7.KeyIndex``1(TED.Var{``0})">
            <summary>
            Get the index for the specified key
            </summary>
            <typeparam name="TKey">Type of the indexed column</typeparam>
            <param name="column">Default variable representing the column</param>
            <returns>The index</returns>
            <exception cref="T:System.InvalidOperationException">If there is no index or it's not a key index</exception>
        </member>
        <member name="M:TED.TablePredicate`7.KeyIndex``1(System.Int32)">
            <summary>
            Get the index for the specified key
            </summary>
            <typeparam name="TKey">Type of the indexed column</typeparam>
            <param name="column">Position of the column</param>
            <returns>The index</returns>
            <exception cref="T:System.InvalidOperationException">If there is no index or it's not a key index</exception>
        </member>
        <member name="M:TED.TablePredicate`7.#ctor(System.String,TED.Interpreter.IColumnSpec{`0},TED.Interpreter.IColumnSpec{`1},TED.Interpreter.IColumnSpec{`2},TED.Interpreter.IColumnSpec{`3},TED.Interpreter.IColumnSpec{`4},TED.Interpreter.IColumnSpec{`5},TED.Interpreter.IColumnSpec{`6})">
            <summary>
            Make a new table predicate with the specified name
            </summary>
            <param name="name">Name of the predicate</param>
            <param name="arg1">Default variable for the first argument</param>
            <param name="arg2">Default variable for the second argument</param>
            <param name="arg3">Default variable for the third argument</param>
            <param name="arg4">Default variable for the fourth argument</param>
            <param name="arg5">Default variable for the fifth argument</param>
            <param name="arg6">Default variable for the sixth argument</param>
            <param name="arg7">Default variable for the seventh argument</param>
        </member>
        <member name="M:TED.TablePredicate`7.#ctor(System.String,System.Action{TED.Tables.Table},TED.Interpreter.IColumnSpec{`0},TED.Interpreter.IColumnSpec{`1},TED.Interpreter.IColumnSpec{`2},TED.Interpreter.IColumnSpec{`3},TED.Interpreter.IColumnSpec{`4},TED.Interpreter.IColumnSpec{`5},TED.Interpreter.IColumnSpec{`6})">
            <summary>
            Make a new table predicate with the specified name
            </summary>
            <param name="name">Name of the predicate</param>
            <param name="updateProc">Procedure to call to update the contents of the table.  This should only be used for tables that are the results of operators</param>
            <param name="arg1">Default variable for the first argument</param>
            <param name="arg2">Default variable for the second argument</param>
            <param name="arg3">Default variable for the third argument</param>
            <param name="arg4">Default variable for the fourth argument</param>
            <param name="arg5">Default variable for the fifth argument</param>
            <param name="arg6">Default variable for the sixth argument</param>
            <param name="arg7">Default variable for the seventh argument</param>
        </member>
        <member name="P:TED.TablePredicate`7.Length">
            <summary>
            The number of rows in the table (i.e. the number of tuples in the extension of the predicate)
            </summary>
        </member>
        <member name="M:TED.TablePredicate`7.AddRow(`0@,`1@,`2@,`3@,`4@,`5@,`6@)">
            <summary>
            Manually add a row (ground instance) to the extension of the predicate
            This cannot be mixed with rules using If.  If you want to have rules for the predicate
            use Fact() instead of AddRow.
            </summary>
        </member>
        <member name="M:TED.TablePredicate`7.AddRows(System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1,`2,`3,`4,`5,`6}})">
            <summary>
            Add a set of rows from a generator
            </summary>
        </member>
        <member name="M:TED.TablePredicate`7.FromCsv(System.String,System.String,TED.Interpreter.IColumnSpec{`0},TED.Interpreter.IColumnSpec{`1},TED.Interpreter.IColumnSpec{`2},TED.Interpreter.IColumnSpec{`3},TED.Interpreter.IColumnSpec{`4},TED.Interpreter.IColumnSpec{`5},TED.Interpreter.IColumnSpec{`6})">
            <summary>
            Read an extensional predicate from a CSV file
            </summary>
            <param name="name">Predicate name</param>
            <param name="path">Path to the CSV file</param>
            <param name="arg1">First argument</param>
            <param name="arg2">Second argument</param>
            <param name="arg3">Third argument</param>
            <param name="arg4">Fourth argument</param>
            <param name="arg5">Fifth argument</param>
            <param name="arg6">Sixth argument</param>
            <param name="arg7">Seventh argument</param>
            <returns>The TablePredicate</returns>
        </member>
        <member name="M:TED.TablePredicate`7.FromCsv(System.String,TED.Interpreter.IColumnSpec{`0},TED.Interpreter.IColumnSpec{`1},TED.Interpreter.IColumnSpec{`2},TED.Interpreter.IColumnSpec{`3},TED.Interpreter.IColumnSpec{`4},TED.Interpreter.IColumnSpec{`5},TED.Interpreter.IColumnSpec{`6})">
            <summary>
            Read an extensional predicate from a CSV file
            </summary>
            <param name="path">Path to the CSV file</param>
            <param name="arg1">First argument</param>
            <param name="arg2">Second argument</param>
            <param name="arg3">Third argument</param>
            <param name="arg4">Fourth argument</param>
            <param name="arg5">Fifth argument</param>
            <param name="arg6">Sixth argument</param>
            <param name="arg7">Seventh argument</param>
            <returns>The TablePredicate</returns>
        </member>
        <member name="M:TED.TablePredicate`7.GetUntypedRowData(System.UInt32,System.Object[])">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`7.RowToStrings(System.UInt32,System.String[])">
            <summary>
            Convert the columns of the specified row to strings and write them to buffer
            </summary>
        </member>
        <member name="M:TED.TablePredicate`7.RowToCsv(System.UInt32,System.String[])">
            <summary>
            Convert the columns of the specified row to strings and write them to buffer
            </summary>
        </member>
        <member name="M:TED.TablePredicate`7.UpdateRows(TED.TablePredicate.Update{System.ValueTuple{`0,`1,`2,`3,`4,`5,`6}})">
            <summary>
            Call method on every row of the table, passing it a reference so it can rewrite it as it likes
            </summary>
            <param name="u"></param>
        </member>
        <member name="M:TED.TablePredicate`7.Append(TED.TablePredicate{`0,`1,`2,`3,`4,`5,`6})">
            <summary>
            Add rows of t to rows of this predicate
            </summary>
        </member>
        <member name="M:TED.TablePredicate`7.If(TED.Interpreter.Goal[])">
            <summary>
            Add a rule using the default arguments as the head.
            </summary>
            <param name="body">subgoals</param>
            <returns>the original predicate</returns>
        </member>
        <member name="M:TED.TablePredicate`7.Where(TED.Interpreter.Goal[])">
            <summary>
            Add a rule to the predicate, using its default arguments as the head
            </summary>
            <param name="body">Antecedents for the rule</param>
            <returns>The original predicate (so these can be chained)</returns>
        </member>
        <member name="P:TED.TablePredicate`7.Inputs">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`7.Accumulates(TED.TablePredicate{`0,`1,`2,`3,`4,`5,`6})">
            <summary>
            Declare that on each simulation tick, the contents of the specified tables should be appended to this table.
            </summary>
            <param name="input">Predicate to append to this predicate on each tick</param>
            <returns>This predicate</returns>
        </member>
        <member name="P:TED.TablePredicate`7.Add">
            <summary>
            A predicate that is automatically appended to this predicate on every update.
            </summary>
        </member>
        <member name="P:TED.TablePredicate`7.AddUntyped">
            <inheritdoc />
        </member>
        <member name="P:TED.TablePredicate`7.Initially">
            <summary>
            A predicate that is automatically appended to this predicate on every update.
            </summary>
        </member>
        <member name="P:TED.TablePredicate`7.InitialValueTable">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`7.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`7.Projection(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`7.Mutator(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`7.Accessor``2(TED.Var{``1},TED.Var{``0})">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`7.Accessor``3(TED.Var{``1},TED.Var{``2},TED.Var{``0})">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`7.RowComparison(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`7.ColumnValueFromRowNumber``1(TED.Var{``0})">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`7.ColumnTest(System.Int32,System.Object)">
            <inheritdoc />
        </member>
        <member name="T:TED.TablePredicate`8">
            <summary>
            A 8-argument TablePredicate
            </summary>
            <typeparam name="T1">Type of the predicate's 1st argument</typeparam>
            <typeparam name="T2">Type of the predicate's 2nd argument</typeparam>
            <typeparam name="T3">Type of the predicate's 3rd argument</typeparam>
            <typeparam name="T4">Type of the predicate's 4th argument</typeparam>
            <typeparam name="T5">Type of the predicate's 5th argument</typeparam>
            <typeparam name="T6">Type of the predicate's 6th argument</typeparam>
            <typeparam name="T7">Type of the predicate's 7th argument</typeparam>
            <typeparam name="T8">Type of the predicate's 8th argument</typeparam>
        </member>
        <member name="P:TED.TablePredicate`8.Item(TED.Term{`0},TED.Term{`1},TED.Term{`2},TED.Term{`3},TED.Term{`4},TED.Term{`5},TED.Term{`6},TED.Term{`7})">
            <summary>
            Make a Goal from this predicate with the specified argument value.
            </summary>
        </member>
        <member name="M:TED.TablePredicate`8.GetGoal(TED.Term[])">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`8.AddIndex(System.Int32,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`8.AddIndex``2(TED.Var{``0},TED.Var{``1},System.Boolean)">
            <summary>
            Add an index on a pair of columns
            </summary>
            <param name="c1">First column</param>
            <param name="c2">Second column</param>
            <param name="keyIndex">True if the two columns function as a key, i.e. now two rows will have the same values for the two at the same time</param>
            <typeparam name="TColumn1">Type of the first column</typeparam>
            <typeparam name="TColumn2">Type of the second column</typeparam>
        </member>
        <member name="M:TED.TablePredicate`8.AddIndex(System.Int32,System.Int32,System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`8.JointKey``2(TED.Var{``0},TED.Var{``1})">
            <summary>
            Add a key index with the two specified columns jointly forming the key
            </summary>
        </member>
        <member name="M:TED.TablePredicate`8.JointIndex``2(TED.Var{``0},TED.Var{``1},System.Nullable{System.Int32})">
            <summary>
            Add an index on the two specified columns 
            </summary>
        </member>
        <member name="M:TED.TablePredicate`8.KeyIndex``1(TED.Var{``0})">
            <summary>
            Get the index for the specified key
            </summary>
            <typeparam name="TKey">Type of the indexed column</typeparam>
            <param name="column">Default variable representing the column</param>
            <returns>The index</returns>
            <exception cref="T:System.InvalidOperationException">If there is no index or it's not a key index</exception>
        </member>
        <member name="M:TED.TablePredicate`8.KeyIndex``1(System.Int32)">
            <summary>
            Get the index for the specified key
            </summary>
            <typeparam name="TKey">Type of the indexed column</typeparam>
            <param name="column">Position of the column</param>
            <returns>The index</returns>
            <exception cref="T:System.InvalidOperationException">If there is no index or it's not a key index</exception>
        </member>
        <member name="M:TED.TablePredicate`8.#ctor(System.String,TED.Interpreter.IColumnSpec{`0},TED.Interpreter.IColumnSpec{`1},TED.Interpreter.IColumnSpec{`2},TED.Interpreter.IColumnSpec{`3},TED.Interpreter.IColumnSpec{`4},TED.Interpreter.IColumnSpec{`5},TED.Interpreter.IColumnSpec{`6},TED.Interpreter.IColumnSpec{`7})">
            <summary>
            Make a new table predicate with the specified name
            </summary>
            <param name="name">Name of the predicate</param>
            <param name="arg1">Default variable for the first argument</param>
            <param name="arg2">Default variable for the second argument</param>
            <param name="arg3">Default variable for the third argument</param>
            <param name="arg4">Default variable for the fourth argument</param>
            <param name="arg5">Default variable for the fifth argument</param>
            <param name="arg6">Default variable for the sixth argument</param>
            <param name="arg7">Default variable for the seventh argument</param>
            <param name="arg8">Default variable for the eighth argument</param>
        </member>
        <member name="M:TED.TablePredicate`8.#ctor(System.String,System.Action{TED.Tables.Table},TED.Interpreter.IColumnSpec{`0},TED.Interpreter.IColumnSpec{`1},TED.Interpreter.IColumnSpec{`2},TED.Interpreter.IColumnSpec{`3},TED.Interpreter.IColumnSpec{`4},TED.Interpreter.IColumnSpec{`5},TED.Interpreter.IColumnSpec{`6},TED.Interpreter.IColumnSpec{`7})">
            <summary>
            Make a new table predicate with the specified name
            </summary>
            <param name="name">Name of the predicate</param>
            <param name="updateProc">Procedure to call to update the contents of the table.  This should only be used for tables that are the results of operators</param>
            <param name="arg1">Default variable for the first argument</param>
            <param name="arg2">Default variable for the second argument</param>
            <param name="arg3">Default variable for the third argument</param>
            <param name="arg4">Default variable for the fourth argument</param>
            <param name="arg5">Default variable for the fifth argument</param>
            <param name="arg6">Default variable for the sixth argument</param>
            <param name="arg7">Default variable for the seventh argument</param>
            <param name="arg8">Default variable for the eight argument</param>
        </member>
        <member name="P:TED.TablePredicate`8.Length">
            <summary>
            The number of rows in the table (i.e. the number of tuples in the extension of the predicate)
            </summary>
        </member>
        <member name="M:TED.TablePredicate`8.AddRow(`0@,`1@,`2@,`3@,`4@,`5@,`6@,`7@)">
            <summary>
            Manually add a row (ground instance) to the extension of the predicate
            This cannot be mixed with rules using If.  If you want to have rules for the predicate
            use Fact() instead of AddRow.
            </summary>
        </member>
        <member name="M:TED.TablePredicate`8.AddRows(System.Collections.Generic.IEnumerable{System.ValueTuple{`0,`1,`2,`3,`4,`5,`6,System.ValueTuple{`7}}})">
            <summary>
            Add a set of rows from a generator
            </summary>
        </member>
        <member name="M:TED.TablePredicate`8.FromCsv(System.String,System.String,TED.Interpreter.IColumnSpec{`0},TED.Interpreter.IColumnSpec{`1},TED.Interpreter.IColumnSpec{`2},TED.Interpreter.IColumnSpec{`3},TED.Interpreter.IColumnSpec{`4},TED.Interpreter.IColumnSpec{`5},TED.Interpreter.IColumnSpec{`6},TED.Interpreter.IColumnSpec{`7})">
            <summary>
            Read an extensional predicate from a CSV file
            </summary>
            <param name="name">Predicate name</param>
            <param name="path">Path to the CSV file</param>
            <param name="arg1">First argument</param>
            <param name="arg2">Second argument</param>
            <param name="arg3">Third argument</param>
            <param name="arg4">Fourth argument</param>
            <param name="arg5">Fifth argument</param>
            <param name="arg6">Sixth argument</param>
            <param name="arg7">Seventh argument</param>
            <param name="arg8">Eighth argument</param>
            <returns>The TablePredicate</returns>
        </member>
        <member name="M:TED.TablePredicate`8.FromCsv(System.String,TED.Interpreter.IColumnSpec{`0},TED.Interpreter.IColumnSpec{`1},TED.Interpreter.IColumnSpec{`2},TED.Interpreter.IColumnSpec{`3},TED.Interpreter.IColumnSpec{`4},TED.Interpreter.IColumnSpec{`5},TED.Interpreter.IColumnSpec{`6},TED.Interpreter.IColumnSpec{`7})">
            <summary>
            Read an extensional predicate from a CSV file
            </summary>
            <param name="path">Path to the CSV file</param>
            <param name="arg1">First argument</param>
            <param name="arg2">Second argument</param>
            <param name="arg3">Third argument</param>
            <param name="arg4">Fourth argument</param>
            <param name="arg5">Fifth argument</param>
            <param name="arg6">Sixth argument</param>
            <param name="arg7">Seventh argument</param>
            <param name="arg8">Eighth argument</param>
            <returns>The TablePredicate</returns>
        </member>
        <member name="M:TED.TablePredicate`8.GetUntypedRowData(System.UInt32,System.Object[])">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`8.RowToStrings(System.UInt32,System.String[])">
            <summary>
            Convert the columns of the specified row to strings and write them to buffer
            </summary>
        </member>
        <member name="M:TED.TablePredicate`8.RowToCsv(System.UInt32,System.String[])">
            <summary>
            Convert the columns of the specified row to strings and write them to buffer
            </summary>
        </member>
        <member name="M:TED.TablePredicate`8.UpdateRows(TED.TablePredicate.Update{System.ValueTuple{`0,`1,`2,`3,`4,`5,`6,System.ValueTuple{`7}}})">
            <summary>
            Call method on every row of the table, passing it a reference so it can rewrite it as it likes
            </summary>
            <param name="u"></param>
        </member>
        <member name="M:TED.TablePredicate`8.Append(TED.TablePredicate{`0,`1,`2,`3,`4,`5,`6,`7})">
            <summary>
            Add rows of t to rows of this predicate
            </summary>
        </member>
        <member name="M:TED.TablePredicate`8.If(TED.Interpreter.Goal[])">
            <summary>
            Add a rule using the default arguments as the head.
            </summary>
            <param name="body">subgoals</param>
            <returns>the original predicate</returns>
        </member>
        <member name="M:TED.TablePredicate`8.Where(TED.Interpreter.Goal[])">
            <summary>
            Add a rule to the predicate, using its default arguments as the head
            </summary>
            <param name="body">Antecedents for the rule</param>
            <returns>The original predicate (so these can be chained)</returns>
        </member>
        <member name="P:TED.TablePredicate`8.Inputs">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`8.Accumulates(TED.TablePredicate{`0,`1,`2,`3,`4,`5,`6,`7})">
            <summary>
            Declare that on each simulation tick, the contents of the specified tables should be appended to this table.
            </summary>
            <param name="input">Predicate to append to this predicate on each tick</param>
            <returns>This predicate</returns>
        </member>
        <member name="P:TED.TablePredicate`8.Add">
            <summary>
            A predicate that is automatically appended to this predicate on every update.
            </summary>
        </member>
        <member name="P:TED.TablePredicate`8.AddUntyped">
            <inheritdoc />
        </member>
        <member name="P:TED.TablePredicate`8.Initially">
            <summary>
            A predicate that is automatically appended to this predicate on every update.
            </summary>
        </member>
        <member name="P:TED.TablePredicate`8.InitialValueTable">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`8.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`8.Projection(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`8.Mutator(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`8.Accessor``2(TED.Var{``1},TED.Var{``0})">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`8.Accessor``3(TED.Var{``1},TED.Var{``2},TED.Var{``0})">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`8.RowComparison(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`8.ColumnValueFromRowNumber``1(TED.Var{``0})">
            <inheritdoc />
        </member>
        <member name="M:TED.TablePredicate`8.ColumnTest(System.Int32,System.Object)">
            <inheritdoc />
        </member>
        <member name="P:TED.Tables.ColumnAccessor`2.Item(`1)">
            <summary>
            Get or set the value of the column for whatever row matches the specified key
            </summary>
            <param name="key">Key of the row to access</param>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">If no row has that key</exception>
        </member>
        <member name="T:TED.Tables.ColumnAccessor`3">
            <summary>
            Wraps a column of a table to make it look like a mutable dictionary mapping keys to column values.
            Updating the value will modify the underlying table row.
            </summary>
            <typeparam name="TRow">Type of the table rows</typeparam>
            <typeparam name="TColumn">Type of the column to access</typeparam>
            <typeparam name="TKey">Type of the key used to select a unique row</typeparam>
        </member>
        <member name="P:TED.Tables.ColumnAccessor`3.Item(`2)">
            <inheritdoc />
        </member>
        <member name="T:TED.Tables.GeneralIndex`2">
            <summary>
            A non-key index for a Table.
            If indexing by a column that should have unique values for each row (i.e. a key), then
            use a KeyIndex instead.
            </summary>
            <typeparam name="TRow">Type of the table rows.  This will be a tuple type unless it's a single-column table</typeparam>
            <typeparam name="TColumn">Type of the column we're indexing by</typeparam>
        </member>
        <member name="F:TED.Tables.GeneralIndex`2.buckets">
            <summary>
            Buckets for the hash table.  These contain a column value and the index of the first row in the
            linked list of rows having that column value.  The row after it is stored in nextRow[firstRow].
            Empty buckets have firstRow == AnyTable.NoRow.
            </summary>
        </member>
        <member name="F:TED.Tables.GeneralIndex`2.NextRow">
            <summary>
            Next cells in the linked lists.
            All the rows with a given column value are stored in a linked list, starting with the row indicated
            in the firstRow field of the hashtable bucket for the column value.  The successor to row i is stored in
            nextRow[i], its successor in nextRow[nextRow[i]], etc.  The end of the list is indicated by a nextRow
            value of AnyTable.NoRow.
            </summary>
        </member>
        <member name="F:TED.Tables.GeneralIndex`2.previousRow">
            <summary>
            Previous row in a doubly-linked list of rows in a given bucket
            This is used if Remove() or changing values of the column is to be supported
            </summary>
        </member>
        <member name="F:TED.Tables.GeneralIndex`2.completeDeletions">
            <summary>
            Number keys that have been completely removed since we last reindexed.
            We need to track this since it's possible for the table to fill with deletions, making lookups loop infinitely.
            </summary>
        </member>
        <member name="F:TED.Tables.GeneralIndex`2.mask">
            <summary>
            The length of the buckets array is always a power of 2.  Mask is the length-1, so we can easily
            project a hash value into a bucket number by and'ing the hash value with the mask.
            </summary>
        </member>
        <member name="F:TED.Tables.GeneralIndex`2.table">
            <summary>
            The Table object this is indexing.
            Row numbers in the index are numbers of the rows in this table.
            </summary>
        </member>
        <member name="F:TED.Tables.GeneralIndex`2.Comparer">
            <summary>
            Equality Predicate for TColumn.
            </summary>
        </member>
        <member name="M:TED.Tables.GeneralIndex`2.HashInternal(`1,System.UInt32)">
            <summary>
            Map a column value to an initial hash bucket.
            </summary>
            <param name="value">Column value</param>
            <param name="mask">Mask to AND with to generate a bucket number</param>
            <returns></returns>
        </member>
        <member name="M:TED.Tables.GeneralIndex`2.FirstRowWithValue(`1@)">
            <summary>
            Search the table for the start of the linked list of rows with the specified column value
            If no linked list is found, return AnyTable.NoRow.
            </summary>
        </member>
        <member name="M:TED.Tables.GeneralIndex`2.NextRowWithValue(System.UInt32)">
            <summary>
            Return the next row after the specified row in the link list of rows with a given column value.
            </summary>
        </member>
        <member name="P:TED.Tables.GeneralIndex`2.IsKey">
            <summary>
            This is not a key index
            </summary>
        </member>
        <member name="M:TED.Tables.GeneralIndex`2.Add(System.UInt32)">
            <summary>
            Add the row at the specified position in the table to the index.
            This will read the row from the table to get its column value for the purpose of indexing.
            </summary>
            <param name="row">Row number of the row we're adding</param>
        </member>
        <member name="M:TED.Tables.GeneralIndex`2.Expand">
            <summary>
            Called after the original Table is doubled in size.
            Double the size of this table, and reindex it.
            </summary>
        </member>
        <member name="M:TED.Tables.GeneralIndex`2.Clear">
            <summary>
            Erase all the data in the index
            </summary>
        </member>
        <member name="M:TED.Tables.GeneralIndex`2.Reindex">
            <summary>
            Add all the rows in the table to the index.
            Call Clear() first.
            </summary>
        </member>
        <member name="M:TED.Tables.GeneralIndex`2.RowsMatching(`1)">
            <summary>
            Tuples in the table matching the specified column value
            </summary>
        </member>
        <member name="M:TED.Tables.GeneralIndex`2.RowsMatchingCount(`1)">
            <summary>
            The number of columns in the table with the specified value.
            </summary>
        </member>
        <member name="T:TED.Tables.IndexMode">
            <summary>
            Specifies indexing to be used for a column of a TablePredicate
            </summary>
        </member>
        <member name="F:TED.Tables.IndexMode.None">
            <summary>
            No index
            </summary>
        </member>
        <member name="F:TED.Tables.IndexMode.Key">
            <summary>
            Index as a key
            </summary>
        </member>
        <member name="F:TED.Tables.IndexMode.NonKey">
            <summary>
            Index but not as a key
            </summary>
        </member>
        <member name="T:TED.Tables.KeyIndex`2">
            <summary>
            An index to a table that indexes by a column that is a key (has unique values for each row in the table)
            </summary>
            <typeparam name="TRow">Type of the rows of the table; this will be a tuple type unless it is a single-column table</typeparam>
            <typeparam name="TKey">Type of the column we're indexing on</typeparam>
        </member>
        <member name="F:TED.Tables.KeyIndex`2.buckets">
            <summary>
            Hash table buckets mapping key values to row numbers
            </summary>
        </member>
        <member name="F:TED.Tables.KeyIndex`2.mask">
            <summary>
            Mask to and with a hash to get a bucket number
            </summary>
        </member>
        <member name="F:TED.Tables.KeyIndex`2.table">
            <summary>
            Underlying table we're indexing
            </summary>
        </member>
        <member name="F:TED.Tables.KeyIndex`2.Comparer">
            <summary>
            Equality predicate for TKey
            </summary>
        </member>
        <member name="M:TED.Tables.KeyIndex`2.HashInternal(`1,System.UInt32)">
            <summary>
            Hash functions mapping a key value and a mask to a bucket number
            </summary>
        </member>
        <member name="P:TED.Tables.KeyIndex`2.Item(`1@)">
            <summary>
            Return a reference to the row with the specified key.
            This will blow up if there is no such row.
            </summary>
        </member>
        <member name="M:TED.Tables.KeyIndex`2.ContainsKey(`1@)">
            <summary>
            Test if the table contains a row with the specified key
            </summary>
        </member>
        <member name="M:TED.Tables.KeyIndex`2.RowWithKey(`1@)">
            <summary>
            Row containing this key, if any
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:TED.Tables.KeyIndex`2.IsKey">
            <summary>
            Yes, this is a key index
            </summary>
        </member>
        <member name="P:TED.Tables.KeyIndex`2.ProbesPerInsertion">
            <summary>
            Average number of probes of the table until an insertion finds a free slot
            </summary>
        </member>
        <member name="M:TED.Tables.KeyIndex`2.Add(System.UInt32)">
            <summary>
            Add the row with the specified row number to the table
            </summary>
            <param name="row">Number of the row</param>
            <exception cref="T:TED.DuplicateKeyException">If there is always a row in the table containing that key value</exception>
        </member>
        <member name="M:TED.Tables.KeyIndex`2.Expand">
            <summary>
            Double the size of the index's hash table and reindex.
            Called after the underlying table has doubled in side.
            </summary>
        </member>
        <member name="M:TED.Tables.KeyIndex`2.Clear">
            <summary>
            Erase the index
            </summary>
        </member>
        <member name="M:TED.Tables.KeyIndex`2.Reindex">
            <summary>
            Reindex the table.  Call Clear() first.
            </summary>
        </member>
        <member name="T:TED.Tables.Table">
            <summary>
            Untyped base class for all tables
            Tables are essentially a custom version of the List class that is optimized for this application.
            Tables are *not* TablePredicates, but each TablePredicate has a Table in it to hold its data.
            </summary>
        </member>
        <member name="P:TED.Tables.Table.Name">
            <summary>
            Name of table for debugging purposes
            </summary>
        </member>
        <member name="M:TED.Tables.Table.ToString">
            <inheritdoc />
        </member>
        <member name="T:TED.Tables.Table.Projection`2">
            <summary>
            Returns the key value given the row
            </summary>
        </member>
        <member name="M:TED.Tables.Table.JointProjection``3(TED.Tables.Table.Projection{``0,``1},TED.Tables.Table.Projection{``0,``2})">
            <summary>
            Given two column projections, make a projection that returns the two as a tuple.
            </summary>
            <param name="p1">Projection for the first column</param>
            <param name="p2">Projection for the second column</param>
            <typeparam name="TRow">Row type</typeparam>
            <typeparam name="TColumn1">Type of the first column</typeparam>
            <typeparam name="TColumn2">Type of the second column</typeparam>
            <returns>Combined projection</returns>
        </member>
        <member name="T:TED.Tables.Table.Mutator`2">
            <summary>
            Modifies the value of a column in a row.
            </summary>
            <param name="row">The row to modify (in place)</param>
            <param name="newValue">New value for the column</param>
        </member>
        <member name="F:TED.Tables.Table.NoRow">
            <summary>
            Row index to return when not no matching row is found
            Also used to mark the end of a linked list of rows
            </summary>
        </member>
        <member name="F:TED.Tables.Table.DeletedRow">
            <summary>
            Used to mark linked lists for hash buckets that are allocated but have empty lists
            This happens when something is added to an index but then all rows with that value are removed.
            </summary>
        </member>
        <member name="M:TED.Tables.Table.ValidRow(System.UInt32)">
            <summary>
            True when the row number is neither NoRow (end of a linked list of rows)
            nor DeletedRow (marks a hash bucket that's allocated but has an empty list in it).
            </summary>
            <param name="row"></param>
            <returns></returns>
        </member>
        <member name="P:TED.Tables.Table.Length">
            <summary>
            Number of rows in the table, regardless of the size of the underlying array.
            </summary>
        </member>
        <member name="M:TED.Tables.Table.Clear">
            <summary>
            Remove all rows from the table
            </summary>
        </member>
        <member name="F:TED.Tables.Table.Indices">
            <summary>
            List of all the Indices into the table, be they KeyIndex or GeneralIndex.
            </summary>
        </member>
        <member name="P:TED.Tables.Table.Unique">
            <summary>
            If true, the rows of the table are required to be different from one another.
            In other words, this is a set rather than a bag.  Unique tables keep a hash table
            of all the rows (using a RowSet object) and use this to suppress adding duplicate rows.
            In addition, their TablePredicates can be queries in constant time rather than linear time
            when the call has all its arguments instantiated.
            </summary>
        </member>
        <member name="M:TED.Tables.Table.AddIndex(TED.Tables.TableIndex)">
            <summary>
            Add an index to the table.
            This will not test for a duplicate index on the same column.
            </summary>
        </member>
        <member name="M:TED.Tables.Table.IndexFor(System.Int32[])">
            <summary>
            Find the index for the specified columns
            </summary>
        </member>
        <member name="M:TED.Tables.Table.SetReclamationRowTest(System.Delegate)">
            <summary>
            Set the test used to decide if a row should be reclaimed
            </summary>
            <param name="t">A RowTest that returns true if a row should be reclaimed</param>
        </member>
        <member name="M:TED.Tables.Table.Reclaim">
            <summary>
            Force deletion of reclaimable rows.
            This will not grow the underlying array.
            </summary>
        </member>
        <member name="F:TED.Tables.Table.PostCompactionTargetLoad">
            <summary>
            For use with tables that support compaction. Target fraction of space that should be used after compaction.
            If more than this fraction of space is in use, the table will expand its space.  Default is 0.5 (50%).
            </summary>
        </member>
        <member name="T:TED.Tables.Table`1">
            <summary>
            A list of rows that hold the extension of a predicate
            </summary>
            <typeparam name="T">Type of the rows of the table (a tuple of the predicate arguments)</typeparam>
        </member>
        <member name="P:TED.Tables.Table`1.Unique">
            <summary>
            If true, enforce that rows of the table are unique, by making a hashtable of them
            </summary>
        </member>
        <member name="F:TED.Tables.Table`1.Data">
            <summary>
            Array holding the rows
            Elements 0 .. data.Length-1 hold the elements
            </summary>
        </member>
        <member name="F:TED.Tables.Table`1.rowSet">
            <summary>
            True if there's space to add another row before having to grow the table
            </summary>
        </member>
        <member name="F:TED.Tables.Table`1.KeyIndex">
            <summary>
            The key index for this table, if any.
            </summary>
        </member>
        <member name="F:TED.Tables.Table`1.ReclaimRowTest">
            <summary>
            If defined, then when the table runs out of space, it will delete all rows satisfying this predicate
            </summary>
        </member>
        <member name="M:TED.Tables.Table`1.EnsureSpace(System.Int32)">
            <summary>
            Make sure there's space for more rows
            If not, make a new array that's twice as big and copy over the data.
            </summary>
            <param name="extra"></param>
        </member>
        <member name="M:TED.Tables.Table`1.Add(`0@)">
            <summary>
            Add a row
            </summary>
            <param name="item">The row to add</param>
        </member>
        <member name="P:TED.Tables.Table`1.Item(System.UInt32)">
            <summary>
            The data of the index'th row
            </summary>
            <param name="index">Position in the table to retrieve the row</param>
            <returns>Row data</returns>
        </member>
        <member name="M:TED.Tables.Table`1.PositionReference(System.UInt32)">
            <summary>
            Return a reference (pointer) to the row at the specified position
            This lets the row to be passed to another method without copying
            </summary>
        </member>
        <member name="T:TED.Tables.Table`1.RowSet">
            <summary>
            Report back all the rows, in order
            This allocates storage, so it shouldn't be used in inner loops.
            </summary>
        </member>
        <member name="M:TED.Tables.Table`1.RowSet.MaybeAddRow(System.UInt32)">
            <summary>
            Add row to set if it's not already in the set.  Return true if it was added.
            </summary>
            <param name="row">row number of the row</param>
            <returns>True if it was added, false if there was already a row equal to the one at this index</returns>
        </member>
        <member name="T:TED.Tables.TableIndex">
            <summary>
            Base type of indices into tables
            </summary>
        </member>
        <member name="F:TED.Tables.TableIndex.Predicate">
            <summary>
            TablePredicate corresponding to the table
            </summary>
        </member>
        <member name="F:TED.Tables.TableIndex.ColumnNumbers">
            <summary>
            Position of the column: 0=first column, 1=second, etc.
            </summary>
        </member>
        <member name="T:TED.Tables.TableIndex.CallGenerator">
            <summary>
            Delegate to generate calls for this table given a goal's IPattern.
            </summary>
        </member>
        <member name="F:TED.Tables.TableIndex.GenerateCall">
            <summary>
            Delegate to generate calls for this table given a goal's IPattern.
            </summary>
        </member>
        <member name="P:TED.Tables.TableIndex.Priority">
            <summary>
            Indices with higher priority numbers are used in preference to indices with smaller numbers
            </summary>
        </member>
        <member name="P:TED.Tables.TableIndex.IsKey">
            <summary>
            If true, this index is for a column that is a key, i.e. rows have unique values for this column
            </summary>
        </member>
        <member name="M:TED.Tables.TableIndex.Add(System.UInt32)">
            <summary>
            Add a row to the index
            </summary>
            <param name="row">Position within the table array of the row to add</param>
        </member>
        <member name="M:TED.Tables.TableIndex.Expand">
            <summary>
            Double the size of the table.
            </summary>
        </member>
        <member name="M:TED.Tables.TableIndex.Clear">
            <summary>
            Remove all data from the index
            </summary>
        </member>
        <member name="M:TED.Tables.TableIndex.Reindex">
            <summary>
            Forcibly rebuild the index
            </summary>
        </member>
        <member name="M:TED.Tables.TableIndex.#ctor(TED.TablePredicate,System.Int32[])">
            <summary>
            The index for the specified column, if any
            </summary>
        </member>
        <member name="M:TED.Tables.TableIndex.CanMatchOn(TED.Interpreter.IPattern)">
            <summary>
            True if all the columns for this index are read mode in the specified pattern.
            </summary>
        </member>
        <member name="M:TED.Tables.TableIndex.MakeIndex``2(TED.TablePredicate,TED.Tables.Table{``0},System.Int32[],TED.Tables.Table.Projection{``0,``1},System.Boolean)">
            <summary>
            Make an index, either keyed or not keyed, depending on the isKey argument
            </summary>
        </member>
        <member name="M:TED.Tables.TableIndex.MakeCall(TED.Interpreter.IPattern)">
            <summary>
            Make a call using arguments p and this index.
            </summary>
        </member>
        <member name="T:TED.Tables.TableIndex`2">
            <summary>
            Typed base class of all table indices
            </summary>
            <typeparam name="TRow">Type of the rows of the table</typeparam>
            <typeparam name="TColumn">Type of the column being indexed</typeparam>
        </member>
        <member name="M:TED.Tables.TableIndex`2.#ctor(TED.TablePredicate,System.Int32[],TED.Tables.Table.Projection{`0,`1})">
            <inheritdoc />
        </member>
        <member name="F:TED.Tables.TableIndex`2.projection">
            <summary>
            Function to extract the column value from a given row
            </summary>
        </member>
        <member name="T:TED.Tables.TableIndex`1">
            <summary>
            Partially typed base class for table indices
            This contains members that need to know the row type but not the column type
            </summary>
            <typeparam name="TRow"></typeparam>
        </member>
        <member name="M:TED.Tables.TableIndex`1.#ctor(TED.TablePredicate,System.Int32[])">
            <inheritdoc />
        </member>
        <member name="M:TED.Tables.TableIndex`1.RowWithKey(`0@)">
            <summary>
            For key indexes only
            Return the row number of the containing the same key as rowData, if any
            </summary>
            <param name="rowData">Row data</param>
            <returns>Row number of row containing the same key as rowData, or Table.NoRow, if it doesn't appear.</returns>
        </member>
        <member name="T:TED.Term">
            <summary>
            Untyped base class of all Terms.  Terms are expressions representing arguments to predicates.
            This only has one direct subclass, Term[T], whose subclasses are variables (Var[T]), constants (Constant[T]),
            and functional expressions (FunctionalExpression[T]).
            </summary>
        </member>
        <member name="P:TED.Term.Type">
            <summary>
            Type of this term
            </summary>
        </member>
        <member name="M:TED.Term.MakeVariable(System.String)">
            <summary>
            Make a variable of the same type as this term
            </summary>
        </member>
        <member name="M:TED.Term.CatchComparisonTypeInitializerProblem(System.Func{TED.Interpreter.Goal},System.String)">
            <summary>
            Kluge to unwrap type initialization exceptions/
            Operators on terms are implemented in a way that's efficient but that causes it
            to throw a type initialization exception rather than a missing method exception
            if you use an operator on a term whose type doesn't define it.  This just catches
            that exception and generates a more meaningful error message.
            </summary>
        </member>
        <member name="M:TED.Term.CatchFunctionalExpressionTypeInitializerProblem``1(System.Func{TED.FunctionalExpression{``0}},System.String)">
            <summary>
            Kluge to unwrap type initialization exceptions/
            Operators on terms are implemented in a way that's efficient but that causes it
            to throw a type initialization exception rather than a missing method exception
            if you use an operator on a term whose type doesn't define it.  This just catches
            that exception and generates a more meaningful error message.
            </summary>
        </member>
        <member name="P:TED.Term.IsPure">
            <summary>
            True if evaluating this has no side effects; the only terms that are not pure are calls to impure functions.
            </summary>
        </member>
        <member name="M:TED.Term.ToSourceExpression(TED.Compiler.Compiler)">
            <summary>
            C# source code that would evaluate to the runtime value of this term.
            </summary>
        </member>
        <member name="M:TED.Term.ToSourceExpressionParenthesized(TED.Compiler.Compiler)">
            <summary>
            Returns the C# source code for this term, as generated by ToSourceExpression, but wraps it in parens if it's a complex expression.
            </summary>
            <returns></returns>
        </member>
        <member name="T:TED.Term`1">
            <summary>
            Base class for terms whose values are type T.
            </summary>
            <typeparam name="T">Type of the value of the variable</typeparam>
        </member>
        <member name="M:TED.Term`1.op_Implicit(`0)~TED.Term{`0}">
            <summary>
            Automatically convert C# constant of type T to Constant terms
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:TED.Term`1.op_Implicit(TED.Function{`0})~TED.Term{`0}">
            <summary>
            Call a 0-arity TedFunction with return type T by name and return Term of type T from the function Call
            </summary>
            <param name="func"></param>
        </member>
        <member name="P:TED.Term`1.Type">
            <inheritdoc />
        </member>
        <member name="M:TED.Term`1.op_Equality(TED.Var{`0},TED.Term{`0})">
            <summary>
            True when the two sides are the same
            </summary>
        </member>
        <member name="M:TED.Term`1.op_Inequality(TED.Var{`0},TED.Term{`0})">
            <summary>
            True when the two sides are different
            </summary>
        </member>
        <member name="M:TED.Term`1.op_Equality(TED.Constant{`0},TED.Term{`0})">
            <summary>
            True when the two sides are the same
            </summary>
        </member>
        <member name="M:TED.Term`1.op_Inequality(TED.Constant{`0},TED.Term{`0})">
            <summary>
            True when the two sides are different
            </summary>
        </member>
        <member name="M:TED.Term`1.op_Equality(TED.Term{`0},TED.Constant{`0})">
            <summary>
            True when the two sides are the same
            </summary>
        </member>
        <member name="M:TED.Term`1.op_Inequality(TED.Term{`0},TED.Constant{`0})">
            <summary>
            True when the two sides are different
            </summary>
        </member>
        <member name="M:TED.Term`1.op_LessThan(TED.Term{`0},TED.Term{`0})">
            <summary>
            Compare the magnitudes of two values
            </summary>
        </member>
        <member name="M:TED.Term`1.op_GreaterThan(TED.Term{`0},TED.Term{`0})">
            <summary>
            Compare the magnitudes of two values
            </summary>
        </member>
        <member name="M:TED.Term`1.op_LessThanOrEqual(TED.Term{`0},TED.Term{`0})">
            <summary>
            Compare the magnitudes of two values
            </summary>
        </member>
        <member name="M:TED.Term`1.op_GreaterThanOrEqual(TED.Term{`0},TED.Term{`0})">
            <summary>
            Compare the magnitudes of two values
            </summary>
        </member>
        <member name="M:TED.Term`1.op_Addition(TED.Term{`0},TED.Term{`0})">
            <summary>
            Add two terms using the existing overload for + for that data type
            </summary>
        </member>
        <member name="M:TED.Term`1.op_Subtraction(TED.Term{`0},TED.Term{`0})">
            <summary>
            Subtract two terms using the existing overload for - for that data type
            </summary>
        </member>
        <member name="M:TED.Term`1.op_UnaryNegation(TED.Term{`0})">
            <summary>
            Negate a term using the existing overload for - for that data type
            </summary>
        </member>
        <member name="M:TED.Term`1.op_Multiply(TED.Term{`0},TED.Term{`0})">
            <summary>
            Multiply two terms using the existing overload for * for that data type
            </summary>
        </member>
        <member name="M:TED.Term`1.op_Division(TED.Term{`0},TED.Term{`0})">
            <summary>
            Divide two terms using the existing overload for / for that data type
            </summary>
        </member>
        <member name="M:TED.Term`1.op_Modulus(TED.Term{`0},TED.Term{`0})">
            <summary>
            Take the modulus of two terms using the existing overload for % for that data type
            </summary>
        </member>
        <member name="M:TED.Term`1.op_BitwiseOr(TED.Term{`0},TED.Term{`0})">
            <summary>
            Take the disjunction of two terms using the existing overload for | for that data type
            </summary>
        </member>
        <member name="M:TED.Term`1.op_BitwiseAnd(TED.Term{`0},TED.Term{`0})">
            <summary>
            Take the conjunction of two terms using the existing overload for ampersand for that data type
            </summary>
        </member>
        <member name="M:TED.Term`1.op_ExclusiveOr(TED.Term{`0},TED.Term{`0})">
            <summary>
            Take the power of two terms using the existing overload for ^ for that data type
            </summary>
        </member>
        <member name="M:TED.Term`1.op_OnesComplement(TED.Term{`0})">
            <summary>
            Invert a term using the existing overload for ~ for that data type
            </summary>
        </member>
        <member name="T:TED.Utilities.CsvReader">
            <summary>
            Extremely simplistic CSV reader.
            Doesn't handle embedded commas, quotes, or newlines in cells.
            </summary>
        </member>
        <member name="F:TED.Utilities.CsvReader._input">
            <summary> TextReader that stores the text file when opened </summary>
        </member>
        <member name="F:TED.Utilities.CsvReader.CellBuffer">
            <summary> Buffer of characters read in that are used to build a string </summary>
        </member>
        <member name="F:TED.Utilities.CsvReader.RowBuffer">
            <summary> List of rows as strings </summary>
        </member>
        <member name="P:TED.Utilities.CsvReader.Peek">
            <summary> Return the next character, without advancing </summary>
        </member>
        <member name="P:TED.Utilities.CsvReader.Read">
            <summary> Return the next character and advance one character </summary>
        </member>
        <member name="M:TED.Utilities.CsvReader.Skip">
            <summary> Advance without returning the next character </summary>
        </member>
        <member name="P:TED.Utilities.CsvReader.End">
            <summary> True if we're at the end of the stream </summary>
        </member>
        <member name="P:TED.Utilities.CsvReader.EndOfLineChar">
            <summary> True if the next character is a newline </summary>
        </member>
        <member name="M:TED.Utilities.CsvReader.AddCellToRow">
            <summary> Moves the cell string buffer into the row buffer </summary>
        </member>
        <member name="M:TED.Utilities.CsvReader.ReadQuotedCell">
            <summary>  Read a quoted column into the cell string buffer. </summary>
        </member>
        <member name="M:TED.Utilities.CsvReader.GetRow">
            <summary> Read a row from the spreadsheet. </summary>
            <returns>Array of column strings</returns>
        </member>
        <member name="M:TED.Utilities.CsvReader.ReadCsv(System.String)">
            <summary> Read a CSV file. </summary>
            <param name="path">Path to the csv file to be read</param>
            <returns>Tuple of the header line as an array of strings and the rest as an array of arrays of strings</returns>
        </member>
        <member name="F:TED.Utilities.CsvReader.ParserTable">
            <summary> Mapping of types to functions that convert a string to the specified type. </summary>
        </member>
        <member name="M:TED.Utilities.CsvReader.DeclareParser(System.Type,System.Func{System.String,System.Object})">
            <summary>
            Assigns a custom method for converting the string in a cell to a particular data type.
            </summary>
            <param name="t">Type to be parsed</param>
            <param name="parser">Function that will return the object given the string</param>
        </member>
        <member name="M:TED.Utilities.CsvReader.TryParse(System.Type,System.String,System.Object@)">
            <summary> Try to convert a string representation of a value to a specific type. </summary>
            <param name="t">Type to convert the string to</param>
            <param name="input">String to be converted to type T</param>
            <param name="result">Object of type T with value converted from the cell string if successful, otherwise null</param>
        </member>
        <member name="M:TED.Utilities.CsvReader.ConvertCell``1(System.String)">
            <summary> Convert a string representation of a value to a specific type. </summary>
            <typeparam name="T">Type to convert the string to</typeparam>
            <param name="cell">String to be converted to type T</param>
            <returns>Object of type T with value converted from the cell string</returns>
        </member>
        <member name="T:TED.Utilities.CsvWriter">
            <summary>
            Handler for custom ToStrings that are used in the creation of CSVs
            </summary>
        </member>
        <member name="F:TED.Utilities.CsvWriter.WriterTable">
            <summary> Mapping of types to functions that convert the specified type to a string. </summary>
        </member>
        <member name="F:TED.Utilities.CsvWriter.CsvBuilder">
            <summary> String builder that creates the entire CSV in one WriteAllText </summary>
        </member>
        <member name="F:TED.Utilities.CsvWriter.RowBuffer">
            <summary> Buffer of strings in an array converted from the content of one row in a table </summary>
        </member>
        <member name="M:TED.Utilities.CsvWriter.DeclareWriter(System.Type,System.Func{System.Object,System.String})">
            <summary> Assigns a custom method for converting a particular data type into a string. </summary>
            <param name="t">Type to be written</param>
            <param name="writer">Function that will return a string given the object</param>
        </member>
        <member name="M:TED.Utilities.CsvWriter.HasDeclaredWriter(System.Type)">
            <summary>Whether or not the given type has a writer func in the WriterTable</summary>
            <param name="t">Type to check in the WriterTable</param>
            <returns>True if the type has a writer function in the WriterTable</returns>
        </member>
        <member name="M:TED.Utilities.CsvWriter.GetDeclaredWriter(System.Type)">
            <summary>The writer func from WriterTable for a given type</summary>
            <param name="t">Type to get a function for from WriterTable</param>
            <returns>The function that maps objects of the given type to a string</returns>
        </member>
        <member name="M:TED.Utilities.CsvWriter.Stringify``1(``0@)">
            <summary> Null-tolerant, tries to get an appropriate CsvWriter falling back on ToString. </summary>
        </member>
        <member name="M:TED.Utilities.CsvWriter.TableToCsv(System.String,TED.TablePredicate)">
            <summary> Writes an entire table out to a CSV file </summary>
            <param name="path">Path to where the CSV file will be written</param>
            <param name="table">Table to write out as a CSV file</param>
        </member>
        <member name="M:TED.Utilities.CsvWriter.WriteAllTables(System.String,TED.Simulation)">
            <summary> Writes every table in a Simulation out to individual CSV files </summary>
            <param name="path">Path to where the CSV files will be written</param>
            <param name="simulation">Simulation that's tables will be written out as CSV files</param>
        </member>
        <member name="T:TED.Utilities.DataflowVisualizer">
            <summary>
            Makes GraphViz visualizations of the data flow from one TED TablePredicate to another
            </summary>
        </member>
        <member name="M:TED.Utilities.DataflowVisualizer.MakeGraph(TED.Program,System.String)">
            <summary>
            Make a visualization of the dataflow between predicates in a Program or Simulation.
            </summary>
            <param name="p"></param>
            <param name="path"></param>
        </member>
        <member name="T:TED.Utilities.GraphViz">
            <summary>
            Represents a graph to be written to a .dot file for rendering using GraphViz
            This is the untyped base class.  Use the version with a type parameter to make a real graph.
            </summary>
        </member>
        <member name="F:TED.Utilities.GraphViz.Attributes">
            <summary>
            Attributes of the graph itself
            </summary>
        </member>
        <member name="F:TED.Utilities.GraphViz.GlobalNodeAttributes">
            <summary>
            Attributes to be applied by default to all nodes
            </summary>
        </member>
        <member name="F:TED.Utilities.GraphViz.GlobalEdgeAttributes">
            <summary>
            Attributes to be applied by default to all edges
            </summary>
        </member>
        <member name="M:TED.Utilities.GraphViz.WriteAttribute(System.Object,System.IO.TextWriter)">
            <summary>
            Write the value part of an attribute/value pair in .dot format
            </summary>
        </member>
        <member name="M:TED.Utilities.GraphViz.WriteAttribute(System.String,System.Object,System.IO.TextWriter)">
            <summary>
            Write an attribute/value pair in .dot format
            </summary>
            <param name="attr">Name of the attribute</param>
            <param name="value">Value of the attribute</param>
            <param name="o">Stream to write to</param>
        </member>
        <member name="M:TED.Utilities.GraphViz.WriteAttribute(System.Collections.Generic.KeyValuePair{System.String,System.Object},System.IO.TextWriter)">
            <summary>
            Write an attribute/value pair in .dot format
            </summary>
            <param name="attr">Name of the attribute + its value</param>
            <param name="o">Stream to write to</param>
        </member>
        <member name="M:TED.Utilities.GraphViz.WriteAttributeList(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}},System.String,System.String,System.IO.TextWriter)">
            <summary>
            Write a series of attribute/value pairs in .dot format
            </summary>
            <param name="attributes">List of attribute/value pairs</param>
            <param name="preamble">string to print before a pair</param>
            <param name="postamble">String to print after a pair</param>
            <param name="o">Stream to print to</param>
        </member>
        <member name="T:TED.Utilities.GraphViz`1">
            <summary>
            A graph to be written to a .dot file for visualization using GraphViz
            </summary>
            <typeparam name="T">The data type of the nodes in the graph</typeparam>
        </member>
        <member name="F:TED.Utilities.GraphViz`1.DefaultNodeAttributes">
            <summary>
            Optional function to compute attributes of a node
            </summary>
        </member>
        <member name="F:TED.Utilities.GraphViz`1.DefaultEdgeAttributes">
            <summary>
            Optional function to compute attributes of an edge
            </summary>
        </member>
        <member name="F:TED.Utilities.GraphViz`1.NodeId">
            <summary>
            Function to compute the ID string to use for a node in the file, as distinct from its label
            By default, this just assigns a serial number to each node.  But you can specify your own function.
            </summary>
        </member>
        <member name="F:TED.Utilities.GraphViz`1.NodeLabel">
            <summary>
            Function to compute the label to display inside a node
            </summary>
        </member>
        <member name="F:TED.Utilities.GraphViz`1.NodeCluster">
            <summary>
            Function to compute the cluster to assign a node to, if any.
            </summary>
        </member>
        <member name="F:TED.Utilities.GraphViz`1.IdOf">
            <summary>
            The internal ID string assigned to a node
            This is not defined until the node is added to the graph
            </summary>
        </member>
        <member name="F:TED.Utilities.GraphViz`1.nodes">
            <summary>
            The set of all nodes in the graph
            </summary>
        </member>
        <member name="P:TED.Utilities.GraphViz`1.Nodes">
            <summary>
            The set of all nodes in the graph
            </summary>
        </member>
        <member name="F:TED.Utilities.GraphViz`1.NodeAttributes">
            <summary>
            The attributes assigned to a given node
            </summary>
        </member>
        <member name="M:TED.Utilities.GraphViz`1.#ctor">
            <summary>
            Make a graph to be rendered using GraphViz.
            </summary>
        </member>
        <member name="M:TED.Utilities.GraphViz`1.AddNode(`0)">
            <summary>
            Add a node to the graph.
            IF the node is already present in the graph, this does nothing.
            </summary>
        </member>
        <member name="M:TED.Utilities.GraphViz`1.AddEdge(TED.Utilities.GraphViz{`0}.Edge)">
            <summary>
            Add the edge.
            If edge is already present, merge the attributes of the edge with the attributes listed here
            </summary>
        </member>
        <member name="M:TED.Utilities.GraphViz`1.AddReachableFrom(System.Collections.Generic.IEnumerable{`0},System.Func{`0,System.Collections.Generic.IEnumerable{TED.Utilities.GraphViz{`0}.Edge}})">
            <summary>
            Add all the nodes listed, and all the nodes reachable from them via the nodeEdges.
            The edges are added too.
            In other words, this adds the connected components of all the nodes in roots.
            </summary>
            <param name="roots">All the nodes to start from</param>
            <param name="nodeEdges">Function to list the set of edges incident on a specified node</param>
        </member>
        <member name="M:TED.Utilities.GraphViz`1.AddReachableFrom(`0,System.Func{`0,System.Collections.Generic.IEnumerable{TED.Utilities.GraphViz{`0}.Edge}})">
            <summary>
            Add this node and all the nodes reachable from it via nodeEdges.  The edges are added too.
            In other words, this adds the specified node's connected component.
            </summary>
            <param name="root">Node to start tracing from</param>
            <param name="nodeEdges">Function to list the set of edges incident on a specified node</param>
        </member>
        <member name="M:TED.Utilities.GraphViz`1.WriteGraph(System.IO.TextWriter)">
            <summary>
            Write the graph to the specified stream
            </summary>
            <param name="o">Stream to write to</param>
        </member>
        <member name="M:TED.Utilities.GraphViz`1.WriteGraph(System.String)">
            <summary>
            Write the graph in .dot format to the specified file.
            </summary>
            <param name="path">Path to the file to write</param>
        </member>
        <member name="M:TED.Utilities.GraphViz`1.WriteEdge(TED.Utilities.GraphViz{`0}.Edge,System.IO.TextWriter)">
            <summary>
            Write an edge in DOT format
            </summary>
        </member>
        <member name="M:TED.Utilities.GraphViz`1.WriteNode(`0,System.IO.TextWriter)">
            <summary>
            Write a node in DOT format
            </summary>
        </member>
        <member name="P:TED.Utilities.GraphViz`1.Edges">
            <summary>
            The set of all edges in the graph
            </summary>
        </member>
        <member name="T:TED.Utilities.GraphViz`1.Edge">
            <summary>
            Represents an edge in a GraphViz graph
            </summary>
        </member>
        <member name="F:TED.Utilities.GraphViz`1.Edge.StartNode">
            <summary>
            Node this edge originates at.
            If this is an undirected edge, then StartNode and EndNode are interchangeable
            </summary>
        </member>
        <member name="F:TED.Utilities.GraphViz`1.Edge.EndNode">
            <summary>
            Node this edge ends at.
            If this is an undirected edge, then StartNode and EndNode are interchangeable
            </summary>
        </member>
        <member name="F:TED.Utilities.GraphViz`1.Edge.Directed">
            <summary>
            Whether this is a directed edge or not
            </summary>
        </member>
        <member name="F:TED.Utilities.GraphViz`1.Edge.Label">
            <summary>
            Text to mark this edge with, or null, if edge is to be unlabeled.
            </summary>
        </member>
        <member name="F:TED.Utilities.GraphViz`1.Edge.Attributes">
            <summary>
            Attributes to be applied to this edge
            </summary>
        </member>
        <member name="M:TED.Utilities.GraphViz`1.Edge.#ctor(`0,`0,System.Boolean,System.String,System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Make an edge
            </summary>
            <param name="startNode">Node the edge should start from.</param>
            <param name="endNode">Node the edge should end at</param>
            <param name="directed">Whether the edge is directed.  If not, startNode and endNode can be switched.</param>
            <param name="label">Text to display along with the edge, or null</param>
            <param name="attributes">Attributes to apply to the edge, if any</param>
        </member>
        <member name="M:TED.Utilities.GraphViz`1.Edge.AddAttributes(TED.Utilities.GraphViz{`0}.Edge)">
            <summary>
            Copy the attributes from the specified edge into this edge's attributes
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:TED.Utilities.GraphViz`1.Edge.AddAttributes(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Object}})">
            <summary>
            Add the specified attributes to this edge
            </summary>
            <param name="attributes"></param>
        </member>
        <member name="M:TED.Utilities.GraphViz`1.Edge.op_Equality(TED.Utilities.GraphViz{`0}.Edge,TED.Utilities.GraphViz{`0}.Edge)">
            <summary>
            True if two edges are the same.
            Edges are the same if they have the same start and end nodes, directedness, and label.
            If the node isn't directed, the the order of start and end nodes doesn't matter.
            Attributes are ignored for purposes of equality.
            </summary>
        </member>
        <member name="M:TED.Utilities.GraphViz`1.Edge.op_Inequality(TED.Utilities.GraphViz{`0}.Edge,TED.Utilities.GraphViz{`0}.Edge)">
            <summary>
            True if the nodes are not the same
            </summary>
        </member>
        <member name="M:TED.Utilities.GraphViz`1.Edge.op_Implicit(System.ValueTuple{`0,`0})~TED.Utilities.GraphViz{`0}.Edge">
            <summary>
            Make an edge from a tuple
            </summary>
        </member>
        <member name="M:TED.Utilities.GraphViz`1.Edge.op_Implicit(System.ValueTuple{`0,`0,System.String})~TED.Utilities.GraphViz{`0}.Edge">
            <summary>
            Make an edge from a tuple
            </summary>
        </member>
        <member name="M:TED.Utilities.GraphViz`1.Edge.op_Implicit(System.ValueTuple{`0,`0,System.String,System.Boolean})~TED.Utilities.GraphViz{`0}.Edge">
            <summary>
            Make an edge from a tuple
            </summary>
        </member>
        <member name="M:TED.Utilities.GraphViz`1.Edge.Equals(System.Object)">
            <summary>
            True if obj is an edge that is == to this edge
            Edges are the same if they have the same start and end nodes, directedness, and label.
            If the node isn't directed, the the order of start and end nodes doesn't matter.
            Attributes are ignored for purposes of equality.
            </summary>
        </member>
        <member name="M:TED.Utilities.GraphViz`1.Edge.GetHashCode">
            <summary>
            Return a hash code for the edge.  If the edge is directed, then it is symmetric in the start and end nodes
            </summary>
        </member>
        <member name="T:TED.Utilities.GraphViz`1.Cluster">
            <summary>
            A cluster of nodes to be grouped together during rendering
            </summary>
        </member>
        <member name="F:TED.Utilities.GraphViz`1.Cluster.Name">
            <summary>
            Name of the cluster
            </summary>
        </member>
        <member name="F:TED.Utilities.GraphViz`1.Cluster.Nodes">
            <summary>
            Nodes in the cluster
            </summary>
        </member>
        <member name="F:TED.Utilities.GraphViz`1.Cluster.Attributes">
            <summary>
            Attributes rendering for this cluster
            </summary>
        </member>
        <member name="F:TED.Utilities.GraphViz`1.Cluster.SubClusters">
            <summary>
            Other clusters to be rendered inside this cluster
            </summary>
        </member>
        <member name="F:TED.Utilities.GraphViz`1.topLevelClusters">
            <summary>
            Clusters for this graph that are not inside other clusters
            </summary>
        </member>
        <member name="M:TED.Utilities.GraphViz`1.MakeCluster(System.String,TED.Utilities.GraphViz{`0}.Cluster)">
            <summary>
            Add a cluster to the graph
            </summary>
            <param name="name">Name to give to the cluster</param>
            <param name="parent">Cluster inside of which to render this cluster, or null</param>
            <returns></returns>
        </member>
        <member name="P:TED.Utilities.GraphViz`1.Diameter">
            <summary>
            Distance between the two most distant nodes that are still connected.
            </summary>
        </member>
        <member name="T:TED.Utilities.Random">
            <summary>
            Shared RNG used by al all the randomization primitives
            </summary>
        </member>
        <member name="F:TED.Utilities.Random.Rng">
            <summary>
            Shared RNG used by TED.
            Set the seed on this if you want deterministic behavior.
            </summary>
        </member>
        <member name="M:TED.Utilities.Random.SetGlobalSeed(System.Int32)">
            <summary>
            Set the seed of the global random number generator used by TED.
            If this is not called, then randomization has the same behavior as System.Random.
            </summary>
        </member>
        <member name="M:TED.Utilities.Random.MakeRng">
            <summary>
            Generate a new random number generator whose initial seed is determined by the global RNG.
            </summary>
            <returns></returns>
        </member>
        <member name="M:TED.Utilities.Random.Float(System.Random)">
            <summary>
            Generate a random float
            </summary>
        </member>
        <member name="M:TED.Utilities.Random.Roll(System.Random,System.Single)">
            <summary>
            Generate a random Boolean with a specified probability of being true
            </summary>
            <param name="rng">Random number generator</param>
            <param name="probability">Probability of returning true.</param>
        </member>
        <member name="M:TED.Utilities.Random.InRangeExclusive(System.Random,System.Int32,System.Int32)">
            <summary>
            Return a random integer from start to end-1.
            </summary>
        </member>
        <member name="T:TED.Utilities.ReflectionUtilities">
            <summary>
            Convenience functions for System.Reflection
            </summary>
        </member>
        <member name="M:TED.Utilities.ReflectionUtilities.GetOperatorMethodInfo(System.Type,System.String,System.Type,System.Type[])">
            <summary>
            Look up the MethodInfo object for the specified operator of the specified type
            </summary>
            <param name="t">Type to get the operator for</param>
            <param name="name">Internal string name of the method used by C# for the operator, for example, op_Addition, op_LessThan, etc.</param>
            <param name="returnType">Type to be returned by the method</param>
            <param name="parameterTypes">Types to be passed to the parameters</param>
            <returns>The MethodInfo object for the method implementing the operator, or null if the type doesn't implement the operator.</returns>
        </member>
        <member name="T:TED.Utilities.UpdateFlowVisualizer">
            <summary>
            Makes GraphViz visualizations of the data flow from one TED TablePredicate to another
            </summary>
        </member>
        <member name="M:TED.Utilities.UpdateFlowVisualizer.MakeGraph(TED.Program,System.String)">
            <summary>
            Make a visualization of the dataflow between predicates in a Program or Simulation.
            </summary>
            <param name="p"></param>
            <param name="path"></param>
        </member>
        <member name="T:TED.Var`1">
            <summary>
            Represents a variable in a Goal (abstract syntax tree of a call to a predicate)
            This is not the run-time representation of a variable.  That is held in a ValueCell.
            </summary>
            <typeparam name="T">Type of the variable's value</typeparam>
        </member>
        <member name="M:TED.Var`1.#ctor(System.String)">
            <summary>
            Make a new variable
            </summary>
            <param name="name">Human-readable name of the variable</param>
        </member>
        <member name="F:TED.Var`1.Name">
            <summary>
            Name of the variable, for debugging purposes
            </summary>
        </member>
        <member name="P:TED.Var`1.ColumnName">
            <inheritdoc />
        </member>
        <member name="P:TED.Var`1.VariableName">
            <inheritdoc />
        </member>
        <member name="M:TED.Var`1.EquateTo(TED.Term)">
            <inheritdoc />
        </member>
        <member name="M:TED.Var`1.op_Explicit(System.String)~TED.Var{`0}">
            <summary>
            Make a TED variable of the specified type and name
            </summary>
            <param name="s"></param>
        </member>
        <member name="M:TED.Var`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:TED.Var`1.Clone">
            <summary>
            Make a different variable with the same name and type
            </summary>
        </member>
        <member name="P:TED.Var`1.Key">
            <summary>
            Make a column spec for this variable that specifies the column should be indexed as a key
            </summary>
        </member>
        <member name="P:TED.Var`1.Indexed">
            <summary>
            Make a column spec for this variable that specifies this column should be indexed, but is not a key.
            </summary>
        </member>
        <member name="M:TED.Var`1.IndexPriority(System.Int32)">
            <summary>
            Make a column spec for this variable that specifies this column should be indexed, but is not a key, and should have the specified priority.
            </summary>
        </member>
        <member name="P:TED.Var`1.IndexMode">
            <summary>
            For variables being used as formal parameters in predicate declarations: whether this column of the table is indexed or not
            </summary>
        </member>
        <member name="P:TED.Var`1.TypedVariable">
            <inheritdoc cref="T:TED.Interpreter.IColumnSpec" />
        </member>
        <member name="P:TED.Var`1.UntypedVariable">
            <inheritdoc cref="T:TED.Interpreter.IColumnSpec" />
        </member>
        <member name="P:TED.Var`1.Mode">
            <inheritdoc />
        </member>
        <member name="P:TED.Var`1.In">
            <summary>
            For use as a formal argument in a definition; this argument must be an input, i.e. a value that will be known at call time.
            </summary>
        </member>
        <member name="P:TED.Var`1.Out">
            <summary>
            For use as a formal argument in a definition; this argument must be an output, i.e. a variable that will not yet have a value at call time.
            </summary>
        </member>
        <member name="P:TED.Var`1.Constant">
            <summary>
            For use as a formal argument in a definition; this argument must be a literal constant.
            </summary>
        </member>
        <member name="M:TED.Var`1.ToSourceExpression(TED.Compiler.Compiler)">
            <inheritdoc />
        </member>
    </members>
</doc>
